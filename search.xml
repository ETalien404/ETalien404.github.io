<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>嵌入式学习</title>
      <link href="/2025/02/17/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/02/17/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="初识单片机"><a href="#初识单片机" class="headerlink" title="初识单片机"></a>初识单片机</h1><h2 id="基础构造"><a href="#基础构造" class="headerlink" title="基础构造"></a>基础构造</h2><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ISP(In-System Programming)在系统可编程,指电路板上的空白器件可以编程写入最终用户代码, 而不需要从电路板上取下器件,已经编程的器件也可以用 ISP方式擦除或再 编程.  ISP 的时候需要用到(bootloader)自举程序,自举程序存储在 STM32 器件的内部自举  ROM 存储器(系统存储器)中.其主要任务是通过一种可用的串行外设(USART, CAN,  USB, I2C 等)将应用程序下载到内部 Flash 中.每种串行接口都定义了相应的通信协议, 其中包含兼容的命令集和序列.</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通过串口下载,最主要的优点是成本低,缺点是只能用于下载程序,不能硬件仿真.</p><p>普通ISP与一键ISP,普通ISP在下载程序时候需要手动配置BOOT的启动方式,而一键RSP则通过独特的硬件电路和 上位机的配合使用来达到一键下载的功能.</p><h5 id="BOOT的启动方式的选择"><a href="#BOOT的启动方式的选择" class="headerlink" title="BOOT的启动方式的选择"></a>BOOT的启动方式的选择</h5><table><thead><tr><th align="center">BOOT0</th><th align="center">BOOT1</th><th align="center">启动方式</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">内部FLASH(内部仿真器支持)</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">系统存储器(串口支持)</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">内部SRAM</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 硬件学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件新手村 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF个人重点</title>
      <link href="/2025/02/12/CTF%E7%9F%A5%E8%AF%86%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2025/02/12/CTF%E7%9F%A5%E8%AF%86%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF中用到的linux命令-补充中"><a href="#CTF中用到的linux命令-补充中" class="headerlink" title="CTF中用到的linux命令(补充中)"></a>CTF中用到的linux命令(补充中)</h1><p>checkesc 检测文件是否开启了什么保护<br>chmod 777 +文件名 给文件可读可写可执行权限</p><h1 id="汇编语言的基础-补充中"><a href="#汇编语言的基础-补充中" class="headerlink" title="汇编语言的基础(补充中)"></a>汇编语言的基础(补充中)</h1><h2 id="简要认识汇编"><a href="#简要认识汇编" class="headerlink" title="简要认识汇编"></a>简要认识汇编</h2><p>mov rbp(目的操作数),rsp(原操作数)<br>将rsp寄存器的值赋值给rbp<br>简单来说就是rnp&#x3D;rsp;</p><p>add加,sub减,xor异或,and&amp;与操作,call直接调函数.</p><p>lea 计算<br>eg:<br>lea rax,[rbp-0x18] &lt;&#x3D;&#x3D;&gt; rax&#x3D;rbb-0x18;<br>(xor eax ,eax :eax&#x3D;0;)</p><p>jcc系列–满足一定条件跳转</p><p>cmp a1,0x61 : a1-0x61给下面的Jcc系列的语句作为跳转判断的条件.<br>与sub a1,0x61区别: a1&#x3D;a1-0x61而前者没有赋值直接比较</p><p>test 与上面同理,比如rax&amp;rax&#x3D;1一样只不过没有赋值</p><p>关于pop与push<br>1、push是什么?(推进)</p><p>push就是推,延伸为推进.这个它是汇编的一个指令<br>就是把一个元素放入栈中.你可以假想栈是一个放光盘的那种盒子,有底没盖,先push进去的光盘总是要等后push进去的出来后才能出来.</p><p>2、pop是什么?(弹出)</p><p>pop和push相反,它的意思是弹出,就是从栈里弹出一个元素,每次弹出的都是栈顶(光盘盒最上面那个,也就是最后放进去的那个)的那个元素.</p><h2 id="系统理解汇编"><a href="#系统理解汇编" class="headerlink" title="系统理解汇编"></a>系统理解汇编</h2><p>在一段程序中,或者说在我们GDB调试的过程中,有三个寄存器rsp(esp),rbp(ebp),rip(eip)，是我们尤为关注的.rsp指向栈底,rbp指向栈顶.rip则是程序执行指令的当前位置.所以我们计算偏移地址时可以是[rbp-0x…]也可以是[rsp+0x…].那我怎么知道我是用这块内存时别人不去调用这块内存呢?其实有一套配套的指令:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">call</span> (push eip,jmp)</span><br><span class="line">   push ebp<span class="comment">//把esp放入esp指向的地方,esp-4</span></span><br><span class="line">   mov ebp esp</span><br><span class="line">       /|\</span><br><span class="line">        |  <span class="comment">//相反的效果</span></span><br><span class="line">       \|/</span><br><span class="line">   <span class="built_in">leave</span> (mov esp ebp)</span><br><span class="line">   pop ebp<span class="comment">//把esp指的地方赋值给ebp,esp+4</span></span><br><span class="line"><span class="built_in">ret</span>(pop eip)</span><br><span class="line">       </span><br></pre></td></tr></table></figure><p>综上,通过3个指针寄存器,我们可以了解汇编在函数调用的作用,注意到如果rbp在函数内即将指向函数的返回地址时,这时我们有一个思路:</p><p>假如在main函数中并没有后门函数的调用我们可将其中调用函数的返回地址覆盖为后门函数的地址即可get shell.</p><h1 id="GDB-补充中"><a href="#GDB-补充中" class="headerlink" title="GDB(补充中)"></a>GDB(补充中)</h1><p>gdb .&#x2F;文件名–启动!<br>run–我觉得一般用不到,这相当于跑了一遍全过程<br>start–程序启动!<br>ni–单步步进,用来分析寄存器的变化<br>finish 如果进入到某个函数里,步过这个函数</p><p>b *地址设置断点<br>enable&#x2F;disable 启动&#x2F;禁用断点<br>c 执行到断点所在的地址,指向的那一行没有被执行</p><p>x&#x2F;数字+.. +$…  系列<br>x&#x2F;i以汇编的形式实现(x&#x2F;20i $rip)<br>x&#x2F;g以8个字节的形式呈现(x&#x2F;20g $rbp)–十六进制<br>x&#x2F;w以4个字节的形式呈现(x&#x2F;20w $rbp)–十六进制<br>x&#x2F;bd以十进制形式呈现(x&#x2F;20bd $rbp)<br>x&#x2F;s以字符形式呈现(x&#x2F;20s $rbp)</p><p>set 系列(赋值)</p><p>set $rbp&#x3D;10可以给寄存器赋值</p><p>pwndbg:<br>vmmap 在断点后,使用r运行后,运行vmmap可以查看当前程序的系统调用库,获取调试进程中虚拟地址的范围等.</p><h1 id="IDA–世界上最强大的反编译调试工具–不接受反驳"><a href="#IDA–世界上最强大的反编译调试工具–不接受反驳" class="headerlink" title="IDA–世界上最强大的反编译调试工具–不接受反驳"></a>IDA–世界上最强大的反编译调试工具–不接受反驳</h1><p>除了F5反编译外,更多是要看TA的程序执行流程图<br>小技巧:<br>选中一段函数按TAB键,可以直接跳转到call函数的汇编代码<br>右键点copy to assembly方便查看<br>set call type在看参数时好用<br>shift+F12 可以看到所有字符</p><h1 id="函数的调用约定"><a href="#函数的调用约定" class="headerlink" title="函数的调用约定"></a>函数的调用约定</h1><p>__cdecl: C&#x2F;C++默认方式,参数从右向左入栈,主调函数负责栈平衡.</p><p>__stdcall:windows API默认方式,参数从右向左入栈,被调函数负责栈平衡.</p><p>__fastcall:快速调用方式.所谓快速,这种方式选择将参数优先从寄存器传入(ECX和EDX),剩下的参数再从右向左从栈传入.因为栈是位于内存的区域,而寄存器位于CPU内,故存取方式快于内存m,故其名曰”__fastcall”.</p>]]></content>
      
      
      <categories>
          
          <category> hacker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF新手村 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语法注意总结</title>
      <link href="/2025/02/07/C++%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2025/02/07/C++%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>我们常常遇到读取多行字符串,但这时候就有问题了.</p><hr><pre><code>举个例子:#include &lt;iostream&gt;int main&#123;    int a;    int name[20];    std::cin&gt;&gt;a;    //解决std::cin.get();把回车读入    std::cin.getline(name,20);    //这就出现一个严重的问题,cin是到换行符,制表符,回车停下.    //给变量a赋值后回车有下一行的cin.getline读入,约等于不执行.&#125;</code></pre><hr><h1 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h1><p>要探究指针的本质,先看声明和初始化</p><hr><pre><code>eg:int*p;我们通常是(int*)p这么看的为什么?为什么不可以int(*p)这样看?我们说p 指向int 类型,我们还说p的类型是指向int的指针,或int*.可以这样说,p是指针(地址),而*p是int,而不是指针到后面,分为变量域与指针域所以上面的二者意义分别为:1.这强调*p是一个int类型的值2.这强调的是:int*是一种类型—指向int的指针.在哪里添加空格对于编译器来说没有任何区别.</code></pre><hr><p>这里有个特别注意的点:</p><hr><pre><code>eg:int a=23;int *pe=&amp;a;其实,a与*pe     &amp;a与pe等价想一想*,&amp;这2个符号的含义还有:new&lt;--&gt;delete加上指向内存块对应的指针//不建议使用malloc&lt;--&gt;free结构体中的指针eg:struct things&#123;    int good;    int bad;&#125;;things p1=&#123;3,4&#125;;//这里是一个结构(things*)p2=&amp;p1;//注意,我说的是p2这里是指向结构体的一个指针很容易混这里:是前面举例的第二种类型比如:3&lt;--&gt;p1.good;     4&lt;--&gt;p1.bad如果要访问它们就要通过*得到*p2就是结构体p1本身再访问.(*p1).good&lt;==&gt;p1-&gt;good</code></pre><hr><h1 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h1><p>将const用于指针有一些很微妙的地方(指针看起来总是很微妙),我们来详细探讨一下.可以用两种不<br>同的方式将 const 关键字用于指针.第一种方法是让指针指向一个常量对象,这样可以防止使用该指<br>针来修改所指向的值,第二种方法是将指针本身声明为常量,这样可以防止改变指针指向的位置.</p><hr><pre><code>int age=39;const int*pt=&amp;age;pt指向一个const int(39),不能用pt来修改.换句话来说,*pt的值为const,不能被修改</code></pre><hr><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>小点:<br>++,–运算符运用<br>可以表现为:</p><hr><pre><code>a=20;   b=20;a++=20; ++b=21;a=21;   b=21;粗略地讲,a++意味着使用a的当前值计算表达式,然后将a的值加1;而++b的意思是先将b的值加1,然后使用新的值来计算表达式.</code></pre><hr><p>特别的,while还可以用作单片机开发中的延时函数</p><hr><pre><code>void time()&#123;    long wait=0;    while(wait&lt;10000)    &#123;    wait++;    &#125;&#125;</code></pre><hr><p>重点:基于范围的for循环(C++11)<br>基于范围(range-based)的 for循环.这简化了一种常见的循环任务:对数组<br>(或容器类,如vector和array)的每个元素执行相同的操作,如下例所示:</p><hr><pre><code>double prices[5]=&#123;1,2,3,4,5&#125;;for(double x:prices)    cout&lt;&lt;x&lt;&lt;std::endl;其中，x最初表示数组prices 的第一个元素.显示第一个元素后,不断执行循环,而x依次表示数组的其他元素.因此,上述代码显示全部5个元素,每个元素占据一行.总之,该循环显示数组中的每个值.</code></pre><hr><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>几个易混淆的运算符<br>逻辑NOT运算符–!</p><hr><pre><code>eg1:int a=10;if(!a)&#123;a--;&#125;else if(a)&#123;a++;&#125;这两个是不一样的,if类的语句判断括号对应语句内的是否为true,(a)是否为不为0,!反过来为0这在while(!a)中常见.另外要注意优先级的问题:!(x&gt;5)和!x&gt;5不一样后者通常不合法</code></pre><hr><p>(?:)–三目运算符<br>比如: 5&gt;3?10:12 前者为true,后者取前,反之取后</p><hr><pre><code>eg2:int c=a&gt;b?a:b//int c=a; if(a&gt;b) else c=b;</code></pre><hr><h1 id="函数与结构"><a href="#函数与结构" class="headerlink" title="函数与结构"></a>函数与结构</h1><p>简单的举例:</p><hr><pre><code>struct tra_time&#123;    int hours;    int mins;&#125;const int Min_per_hr=60;tra_time sum(tra_time t1,tra_time t2)&#123;    tra_time total;    total.mins=(t1.mins+t2.mins)%Min_per_hr;    total.hours=t1.hours+t2.hours+(t1.mins+t2.mins)/Min_per_hr;    return total;与int等类型的函数返回值一样&#125;void show_time(travel_time t)&#123;    using namespace std;    cout&lt;&lt;t.hours;    cout&lt;&lt;t.mins;&#125;</code></pre><hr><p>传递结构的地址(指针结合)</p><hr><pre><code>原:void show_polar(polar dapos)&#123;    cout&lt;&lt;dapos.distance;    cout&lt;&lt;dapos.angle*Rad;&#125;假设要传递结构的地址而不是整个结构以节省时间和空间,则需要重新编写前面的函数,使用指向结构的指针.首先来看一看如何重新编写show_polar( )函数.需要修改三个地方: 调用函数时,将结构的地址(&amp;pplace)而不是结构本身(pplace)传递给它: 将形参声明为指向polar的指针,即polar *类型.由于函数不应该修改结构,因此使用了const修饰符: 由于形参是指针而不是结构,因此应间接成员运算符(-&gt;),而不是成员运算符(句点). 完成上述修改后,该函数如下所示:   void show_polar(const polar*pda)&#123;    cout&lt;&lt;pad-&gt;distance;    cout&lt;&lt;pad-&gt;angle*Rad;&#125;</code></pre><hr><p>函数与指针</p><p>首先通过一个例子来阐释这一过程.假设要设计一个名为estimate( )的函数,估算编写指定行数的代码<br>所需的时间,并且希望不同的程序员都将使用该函数.对于所有的用户来说,estimate( )中一部分代码都是<br>相同的,但该函数允许每个程序员提供自己的算法来估算时间.为实现这种目标,采用的机制是,将程序<br>员要使用的算法函数的地址传递给estimate( ).为此,必须能够完成下面的工作:</p><p>获取函数的地址;<br>声明一个函数指针;<br>使用函数指针来调用函数.</p><p>1.获取函数的地址<br>获取函数的地址很简单:只要使用函数名(后面不跟参数)即可.也就是说,如果think( )是一个函数,<br>则 think 就是该函数的地址.要将函数作为参数进行传递,必须传递函数名.一定要区分传递的是函数的<br>地址还是函数的返回值:</p><hr><pre><code>process(think);process(think());</code></pre><hr><p>process( )调用使得 process( )函数能够在其内部调用think( )函数.thought( )调用首先调用think( )函数，<br>然后将think( )的返回值传递给thought( )函数. </p><p>2.声明函数指针<br>声明指向某种数据类型的指针时,必须指定指针指向的类型.同样,声明指向函数的指针时,也必须<br>指定指针指向的函数类型.这意味着声明应指定函数的返回类型以及函数的特征标(参数列表).也就是说,<br>声明应像函数原型那样指出有关函数的信息.<br>举个例子:</p><hr><pre><code>函数原型:double pam(int)指针声明:double (*pf)(int);这与pam( )声明类似,这是将pam替换为了(*pf).由于pam是函数,因此(*pf)也是函数.而如果(*pf)是函数，则pf就是函数指针.提示:通常要声明指向特定类型的函数的指针,可以首先编写这种函数的原型,然后用(*pf)替换函数名.这样pf就是这类函数的指针.为提供正确的运算符优先级,必须在声明中使用括号将*pf括起.括号的优先级比*运算符高,因此*pf(int)意味着pf( )是一个返回指针的函数,而(*pf)(int)意味着pf是一个指向函数的指针:double (*pf)(int);pf 是一个指针,指向一个函数,该函数接受一个 int 类型的参数,并返回一个 double 类型的值.括号的使用 (*pf) 表明 * 作用于 pf,因此 pf 是一个指针,而不是函数返回指针的函数.double *pf(int);pf 是函数的名称,该函数接受一个 int 类型的参数.这里的 * 表示函数返回的是一个指针,而不是 pf 本身是一个指针.</code></pre><hr><p>3.使用指针来调用函数<br>现在进入最后一步,即使用指针来调用被指向的函数.线索来自指针声明。前面讲过,(*pf)扮演的<br>角色与函数名相同,因此使用(*pf)时,只需将它看作函数名即可</p><p>引用变量:<br>C和C++ 使用&amp;符号来指示变量的地址.C++给&amp;符号赋予了另一个含义,将其用来声明引<br>用.例如,要将rodents作为rats变量的别名,可以这样做:</p><hr><pre><code>int rats;int &amp; rodents=rats;</code></pre><hr><p>其中,&amp;不是地址运算符,而是类型标识符的一部分.就像声明中的char*指的是指向char的指针一样,<br>int &amp;指的是指向int的引用.上述引用声明允许将rats和rodents互换—它们指向相同的值和内存单元.<br>本质上是变量只有一个,但名称却有多个.</p><p>引用的属性和特别之处<br>在函数中,引用的参数在函数运行的过程中本身的值会被修改(按引用传递)<br>举例:</p><hr><pre><code>int func1(int x)&#123;  x*=x;  return x;//传入的参数x并不会被改变.&#125;int func2(int &amp;x)&#123;    x*=x;    return x;//按引用传递,传入的参数本身会被修改&#125;</code></pre><hr><p>临时变量,引用参数和const<br>如果实参与引用参数不匹配, C++ 将生成临时变量.当前仅当参数为const 引用时,C++ 才允许这<br>样做,但以前不是这样.下面来看看何种情况下,C++将生成临时变量,以及为何对const引用的限制是<br>合理的.<br>首先,什么时候将创建临时变量呢?如果引用参数是const,则编译器将在下面两种情况下生成临时<br>变量:<br>实参的类型正确,但不是左值:<br>实参的类型不正确,但可以转换为正确的类型.<br>左值是什么呢?左值参数是可被引用的数据对象,例如,变量,数组元素,结构成员,引用和解除引<br>用的指针都是左值.非左值包括字面常量(用引号括起的字符串除外,它们由其地址表示)和包含多项的<br>表达式.在C语言中,左值最初指的是可出现在赋值语句左边的实体,但这是引入关键字const之前的情<br>况.现在,常规变量和 const 变量都可视为左值,因为可通过地址访问它们.但常规变量属于可修改的左<br>值,而const变量属于不可修改的左值. </p><p>注意:如果函数调用的参数不是左值或与相应的const 引用参数的类型不匹配,则C++将创建类型正<br>确的匿名变量,将函数调用的参数的值传递给该匿名变量,并让参数来引用该变量.<br>应尽可能使用const 将引用参数声明为常量数据的引用的理由有三个:<br>使用const可以避免无意中修改数据的编程错误<br>使用const使函数能够处理const和非const实参,否则将只能接受非const数据<br>使用const引用使函数能够正确生成并使用临时变量.<br>因此应尽可能将引用形参声明为const</p><p>C++11 新增了另一种引用—右值引用(rvalue reference)这种引用可指向右值,是使用&amp;&amp;声明的:<br>新增右值引用的主要目的是,让库设计人员能够提供有些操作的更有效实现.</p><hr><pre><code>int &amp;&amp; r=std::sqrt(36);std::cout&lt;&lt;r;//6</code></pre><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="结构引用"><a href="#结构引用" class="headerlink" title="结构引用"></a>结构引用</h2><p>举个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">free_throws</span></span><br><span class="line">&#123;</span><br><span class="line">   std::string name;</span><br><span class="line"> <span class="type">int</span> made;</span><br><span class="line">       <span class="type">int</span> sttempts;</span><br><span class="line"><span class="type">float</span> percent;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//则可以这样编写函数原型,在函数中将 指向该结构的引用作为参数:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp;ft)</span></span>;</span><br><span class="line">   <span class="comment">//如果不希望函数修改传入的结构，  可使用const:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> free_throws &amp;ft)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="类对象引用"><a href="#类对象引用" class="headerlink" title="类对象引用"></a>类对象引用</h2><p>​将类对象传递给函数时，,C++通常的做法是使用引用.例如,可以通过使用引用,让函数将类string,ostream,istream,ofstream 和 ifstream 等类的对象作为参数.</p><p>看下面这三个函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">version1</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string temp;</span><br><span class="line">        temp=s2+s1+s2;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最简单,它接受两个string 参数,并使用 string 类的相加功能来创建一个满足要求的新字符串.这两个函数参数都是const引用.如果使   用string对象作为参数，最终结果将不变:</span></span><br><span class="line">    <span class="comment">//string version4(string s1,string s2)</span></span><br><span class="line">    <span class="comment">//在这种情况下,s1和s2将为string对象.使用引用的效率更高,因为函数不需要创建新string对象,并将原来对象中的数据复制到新对象中. 限定符const指出,该函数将使用原来的string对象,但不会修改它.temp 是一个新的string对象,只在函数version1()中有效,该函数执行完毕后,它将不再存在.因此,返回指向temp 的引用不可行,因此该函数的返回类型为string,这意味着temp 的内容将被复制到一个临时存储单元中，然后在main()中,该存储单元的内容被复制到一个名为result的string中:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">version2</span><span class="params">(string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s1=s2+s1+s2;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//改函数可以修改s1,因为不同于s2,s1没有被声明为const.</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">version3</span><span class="params">(string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string temp;</span><br><span class="line">        temp=s2+s1+s2;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//它存在一个致命的缺陷:返回一个指向 version3( )中声明的变量的引用.这个函数能够通过编译(但编译器会发出警告),但当程序试图执行该函数时将崩溃.具体地说,问题是由下面的赋值语句引发的:</span></span><br><span class="line"><span class="comment">//当内存不足时,构造新字符串的操作会失败,导致部分内存无法正确初始化.如果程序在拼接过程中崩溃(比如因为内存不足),则可能有以下情况:1.未完成对 temp 的初始化:如果 temp 没有被完全构造,则其指针或其他相关资源可能已经被释放.2.s1 或 s2 的内存泄漏:如果 s1 或 s2 的引用在某些情况下导致了额外的内存分配,但这些内存没有被正确释放.</span></span><br><span class="line"></span><br><span class="line">程序试图引用已经释放的内存。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h2><p>使用引用参数的主要原因有两个.  程序员能够修改调用函数中的数据对象.</p><p>通过传递引用而不是整个数据对象，可以提高程序的运行速度.  当数据对象较大时(如结构和类对象).</p><p>第二个原因最重要.这些也是使用指针参数的原因.这是有道理的,因为引用参数实际上是基于指针的代码的另一个接口.那么,什么时候应使用引用,什么时候应使 用指针呢?什么时候应按值传递呢?下面是一些指导原则:对于使用传递的值而不作修改的函数. </p><p>如果数据对象很小,如内置数据类型或小型结构,则按值传递.</p><p>如果数据对象是数组,则使用指针,因为这是唯一的选择,并将指针声明为指向const的指针.  如果数据对象是较大的结构,则使用const指针或const引用,以提高程序的效率.这样可以节省 复制结构所需的时间和空间.  </p><p>如果数据对象是类对象,则使用const 引用.类设计的语义常常要求使用引用,这是C++新增这项特性的主要原因.因此,传递类对象参数的标准方式是按引用传递.</p><p>对于修改调用函数中数据的函数: 如果数据对象是内置数据类型,则使用指针.</p><p>如果看到诸如fixit(&amp;x)这样的代码(其中x是int), 则很明显,该函数将修改x. 如果数据对象是数组,则只能使用指针. </p><p>如果数据对象是结构,则使用引用或指针. </p><p>如果数据对象是类对象,则使用引用. </p><p>当然,这只是一些指导原则,很可能有充分的理由做出其他的选择.例如,对于基本类型,cin使用引用,因此可以使用cin&gt;&gt;n,而不是cin &gt;&gt; &amp;n.</p><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>指的是可以有多个同名的函数,因此对名称进行了重载.这两个术语指的是同一回事,但我们通常使用函数重载.可以通过函数重载来设计一 系列函数—它们完成相同的工作,但使用不同的参数列表.</p><p>重载函数就像是有多种含义的动词.例如,Piggy 小姐可以在棒球场为家乡球队助威(root),也可以 在地里种植(root)菌类作物.根据上下文可以知道在每一种情况下,root的含义是什么.同样,C++使用上下文来确定要使用的重载函数版本.</p><p>函数重载的关键是函数的参数列表—也称为函数特征标(function signature).如果两个函数的参数 数目和类型相同,同时参数的排列顺序也相同,则它们的特征标相同,而变量名是无关紧要的.C++允许定义名称相同的函数,条件是它们的特征标不同.如果参数数目和或参数类型不同,则特征标也不同.例如,可以定义一组原型如下的print( )函数: </p><p>编译器将根据所采取的用法使用有相应特征标的原型,C++将尝试使用标准类型转换强制进行匹配.</p><h2 id="何时使用函数重载"><a href="#何时使用函数重载" class="headerlink" title="何时使用函数重载"></a>何时使用函数重载</h2><p>虽然函数重载很吸引人,但也不要滥用.仅当函数基本上执行相同的任务,但使用不同形式的数据时, 才应采用函数重载.</p><p>使用一个带默认参数的函数要简单些.只需编写一个函数(而不是两个函数),程序也只需为一个函数 (而不是两个)请求内存;需要修改函数时,只需修改一个.然而,如果需要使用不同类型的参数,则默认参数便不管用了,在这种情况下,应该使用函数重载.</p><h3 id="什么是名称修饰"><a href="#什么是名称修饰" class="headerlink" title="什么是名称修饰"></a>什么是名称修饰</h3><p>​C++如何跟踪每一个重载函数呢？它给这些函数指定了秘密身份。使用 C++开发工具中的编辑器编写 和编译程序时，C++编译器将执行一些神奇的操作—名称修饰(name decoration)或名称矫正(name mangling),它根据函数原型中指定的形参类型对每个函数名进行加密.请看下述未经修饰的函数原型:  这种格式对于人类来说很适合;我们知道函数接受两个参数(一个为int类型,另一个为float类型), 并返回一个long值.而编译器将名称转换为不太好看的内部表示,来描述该接口,如下所示:对原始名称进行的表面看来无意义的修饰(或矫正,因人而异)将对参数数目和类型进行编码.添加的一组符号随函数特征标而异,而修饰时使用的约定随编译器而异.</p><h1 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>举个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> n;</span><br><span class="line">       std::cin&gt;&gt;n;</span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           cin&gt;&gt;a[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//可以作为动态数组使用.</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>size( )–返回容器的元素数目</p><p>swap( )–交换两个容器的内容</p><p>begin( )–返回一个指向容器中第一个元素的迭代器</p><p>end( )–返回一个超过容器尾的迭代器</p><p>什么是迭代器?TA是一个广义指针.事实上,TA可以是一个指针,也可以是一个类似指针的操作.迭代器让STL能够为各种不同的容器类(包括那些简单指针无法处理的类)提供统一的接口.每个容器类都定义了一个合适的迭代器,该迭代器的类型是一个名为iterator的typedef其作用域为整个类. 例如,要为vector的double类型规范声明一个迭代器,可以这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator pd;<span class="comment">//iterator是迭代器</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;scores;</span><br><span class="line">pd=scores.<span class="built_in">begin</span>();</span><br><span class="line">*pd=<span class="number">2</span>;</span><br><span class="line">++pd;</span><br><span class="line"><span class="comment">//迭代器的行为就像指针.C++11及以上有以下操作:</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator pd=scores.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line"><span class="keyword">auto</span> pd=scores.<span class="built_in">begin</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到前面的示例.什么是超过结尾(past-the-end)呢?它是一种迭代器,指向容器最后一个元素后面的那个元素.这与C-风格字符串最后一个字符后面的空字符类似,只是空字符是一个值,而”超过结尾” 是一个指向元素的指针(迭代器).end( )成员函数标识超过结尾的位置.如果将迭代器设置为容器的第一 个元素,并不断地递增，则最终它将到达容器结尾,从而遍历整个容器的内容.因此,如果 scores 和 pd 的定义与前面的示例中相同,则可以用下面的代码来显示容器的内容:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(pd=scores.<span class="built_in">begin</span>();pd!=scores.<span class="built_in">end</span>();pd++)</span><br><span class="line">  &#123;</span><br><span class="line">      cout&lt;&lt;*pd&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所有容器都包含刚才讨论的那些方法.vector 模板类也包含一些只有某些 STL 容器才有的方法.push_back( )是一个方便的方法,它将元素添加到矢量末尾.这样做时,它将负责内存管理,增加矢量的长度,使之能够容纳新的成员.这意味着可以编写这样的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt;scores;</span><br><span class="line"><span class="type">double</span> temp;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;temp&amp;&amp;temp&gt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       scores.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;scores.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>每次循环都给scores对象增加一个元素.在编写或运行程序时,无需了解元素的数目.只要能够取得足够的内存,程序就可以根据需要增加scores的长度.</p><p>erase( )方法删除矢量中给定区间的元素.它接受两个迭代器参数,这些参数定义了要删除的区间.了 解STL如何使用两个迭代器来定义区间至关重要.第一个迭代器指向区间的起始处,第二个迭代器位于区 间终止处的后一个位置.例如,下述代码删除第一个和第二个元素,即删除begin( )和begin( )+1指向的元素(由于vector提供了随机访问功能,因此vector类迭代器定义了诸如begin( )+2等操作):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="built_in">erase</span>(scores.<span class="built_in">begin</span>(),scores.<span class="built_in">begin</span>()<span class="number">+2</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM新手村 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客寒假算法基础集训营1</title>
      <link href="/2025/01/21/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51/"/>
      <url>/2025/01/21/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51/</url>
      
        <content type="html"><![CDATA[<p>被暴打,拼尽全力还是没有让ACM大人尽兴…<br>顺开,补题…</p><h1 id="A-茕茕孑立之影"><a href="#A-茕茕孑立之影" class="headerlink" title="A 茕茕孑立之影"></a>A 茕茕孑立之影</h1><p>链接:<a href="https://ac.nowcoder.com/acm/contest/95323/A">https://ac.nowcoder.com/acm/contest/95323/A</a></p><p>知识点:数学</p><p>难度: 794</p><p>签到题,考虑倍数很容易想到质数,注意范围!10^18.也就是找一个在规定范围内尽可能大的质数.<br>这里我们注意到10000000000000007是一个符合条件的质数.</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;void func()&#123;int T;cin &gt;&gt; T;for (int i = 0; i &lt; T; i++)&#123;    int n;    cin &gt;&gt; n;        int ans = 0;    int* arr = (int*)malloc(n*sizeof(int));    for (int j = 0; j &lt; n; j++)    &#123;        cin &gt;&gt; arr[j];    &#125;    for (int j = 0; j &lt; n; j++)    &#123;        if (arr[j] == 1)        &#123;            printf(&quot;-1\n&quot;);            ans = 1;            break;        &#125;    &#125;    if (ans == 0)    &#123;        ll a = 10000000000000007;        printf(&quot;%lld\n&quot;, a);    &#125;    free(arr);&#125;&#125;int main() &#123;func();&#125;</code></pre><hr><h1 id="B-一气贯通之刃"><a href="#B-一气贯通之刃" class="headerlink" title="B 一气贯通之刃"></a>B 一气贯通之刃</h1><p>链接: <a href="https://ac.nowcoder.com/acm/contest/95323/B">https://ac.nowcoder.com/acm/contest/95323/B</a></p><p>知识点:树</p><p>难度: 875</p><p>数据结构,算是基础题.给定一棵树,要求一次遍历所有节点.<br>考查map的用法,看样例就可以知道,如果要一次遍历完,只需要找到只出现过一次的节点,当然要排除由多分支产生的一次节点.<br>感觉做复杂了…</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;void func()&#123;int n;cin &gt;&gt; n;map&lt;int, int&gt;mp;int** arr = (int**)malloc(n * sizeof(int*));//动态创建二维数组for (int i = 0; i &lt; n; i++)&#123;    arr[i] = (int*)malloc(2 * sizeof(int));//将列数定为2&#125;for (int i = 0; i &lt; n-1; i++)&#123;    for (int j = 0; j &lt; 2; j++)    &#123;        cin &gt;&gt; arr[i][j];        mp[arr[i][j]]++;  //hash list    &#125;&#125;int ans = 0;//记录分支数if (mp.size() != n)//判断种类,!=n直接排除&#123;    printf(&quot;-1\n&quot;);&#125;else&#123;    for (auto i = mp.begin(); i != mp.end(); i++) &#123;        if (i-&gt;second == 1)        &#123;            ans++;        &#125;    &#125;    if (ans != 2)//判断是否只有一个分支    &#123;        printf(&quot;-1\n&quot;);    &#125;    else    &#123;        for (auto i = mp.begin(); i != mp.end(); i++) &#123;            if (i-&gt;second == 1)            &#123;                cout &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot;;//按键值对进行输出            &#125;        &#125;    &#125;&#125;for (int i = 0; i &lt; n; i++)&#123;    free(arr[i]);&#125;free(arr);&#125;int main() &#123;func();&#125;</code></pre><hr><h1 id="D-双生双宿之决"><a href="#D-双生双宿之决" class="headerlink" title="D 双生双宿之决"></a>D 双生双宿之决</h1><p>链接:<a href="https://ac.nowcoder.com/acm/contest/95323/D">https://ac.nowcoder.com/acm/contest/95323/D</a></p><p>知识点:模拟,排序&#x2F;stl</p><p>难度: 621</p><p>签到题,按照题目的要求来就行,可以排序,也可以不排序.<br>限定条件:2种元素,次数相同.</p><hr><pre><code>有排序:#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;void func()&#123;int T;cin &gt;&gt; T;for (int j = 0; j &lt; T; j++)&#123;    int n;    cin &gt;&gt; n;    int* arr = (int*)malloc(n * sizeof(int));    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; arr[i];    &#125;    sort(arr, arr + n);    int ans = 0;    if (arr[n / 2] == arr[n / 2 - 1])    &#123;        ans = 1;    &#125;          if (n % 2 != 0)  &#123;   ans = 1;  &#125;      for (int i = 1; i &lt; n / 2; i++)    &#123;        if (arr[i] != arr[i - 1])        &#123;            ans = 1;            break;        &#125;    &#125;    for (int i = n / 2 + 1; i &lt; n; i++)    &#123;        if (arr[i] != arr[i - 1])        &#123;            ans = 1;            break;        &#125;    &#125;            if (ans == 0)    &#123;        printf(&quot;Yes\n&quot;);    &#125;    else    &#123;        printf(&quot;No\n&quot;);    &#125;    free(arr);&#125;&#125; int main() &#123;func();return 0;&#125;无排序:#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;void func()&#123;int T;cin &gt;&gt; T;for (int i = 0; i &lt; T; i++)&#123;    int n;    cin &gt;&gt; n;    int ans1 = 0;    int ans2 = 0;    map&lt;int, int&gt;mp;    int* arr = (int*)malloc(n*sizeof(int));    for (int j = 0; j &lt; n; j++)    &#123;        cin &gt;&gt; arr[j];        mp[arr[j]]++;    &#125;    int crr[10] = &#123; 0 &#125;;    int k = 0;    if (mp.size() != 2)    &#123;        printf(&quot;No\n&quot;);    &#125;    else    &#123;        for (map&lt;int, int&gt;::iterator it = mp.begin(); it != mp.end(); it++)        &#123;            crr[k]=it-&gt;second;            k++;        &#125;        if (crr[0] == crr[1])        &#123;            printf(&quot;Yes\n&quot;);        &#125;        else        &#123;            printf(&quot;No\n&quot;);        &#125;            &#125;    free(arr);  &#125;&#125; int main() &#123;func();&#125;</code></pre><hr><h1 id="G-井然有序之衡"><a href="#G-井然有序之衡" class="headerlink" title="G 井然有序之衡"></a>G 井然有序之衡</h1><p>链接: <a href="https://ac.nowcoder.com/acm/contest/95323/G">https://ac.nowcoder.com/acm/contest/95323/G</a></p><p>知识点:贪心、排序</p><p>难度: 932</p><p>同样是签到题,思路也很好想,我们需要找出TA不变的是什么.是sum!只需要动态开2个数组,一个输入(要排序),一个校对.<br>比较2个数组相同位置元素的差的绝对值,由于统计2次,所以得除以2.<br>注意范围:int会爆得开long long</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;void func()&#123;int n;cin &gt;&gt; n;int* arr = (int*)malloc(n*sizeof(int));int* arr1 = (int*)malloc(n * sizeof(int));ll sum1 = 0;ll sum2 = 0;for (int i = 0; i &lt; n; i++)&#123;    cin &gt;&gt; arr[i];    sum1 += arr[i];&#125;sort(arr, arr + n);for (int i = 0; i &lt; n; i++)&#123;    sum2 += i+1;    arr1[i] = i+1;&#125;int ans = 0;for (int i = 0; i &lt; n; i++)&#123;         if (sum1 != sum2)    &#123;        printf(&quot;-1\n&quot;);        ans = 1;        break;    &#125;&#125;ll sum = 0;if (ans == 0)&#123;    for (int i = 0; i &lt; n; i++)    &#123;        if (arr1[i] != arr[i])        &#123;            sum += fabs(arr1[i] - arr[i]);                    &#125;    &#125;    sum = sum / 2;    printf(&quot;%lld&quot;, sum);&#125;free(arr);free(arr1);&#125;int main() &#123;func();&#125;</code></pre><hr><h1 id="H-井然有序之窗"><a href="#H-井然有序之窗" class="headerlink" title="H 井然有序之窗"></a>H 井然有序之窗</h1><p>链接: <a href="https://ac.nowcoder.com/acm/contest/95323/H">https://ac.nowcoder.com/acm/contest/95323/H</a></p><p>知识点:贪心,优先队列</p><p>难度: 1603</p><p>上难度了,不会做,就算在补题时写出来依旧困难.关键是怎么最优化排列,这么想?<br>拿样例来说:<br>4<br>3  4<br>1  4<br>2  3<br>1  3<br>这样看,毫无章法,给TA排序下:<br>4<br>1  3<br>1  4<br>2  3<br>3  4<br>这样看是不是舒服多了?我们排列两次,先按左端点升序,再按右升序,实际上本题的核心就是按左端点且区间min放这n个数.<br>考虑数据进出,优先队列.</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;struct range&#123; int l, r, pos;bool operator&lt;(const range&amp; other)const&#123;    return (l &lt; other.l) || (l == other.l &amp;&amp; r &lt; other.r);&#125;//重载,先基于左端点排序,相等则基于右端点排序.&#125;;struct CompareR&#123;bool operator()(const range&amp; a, const range&amp; b)&#123;    return a.r &gt; b.r;&#125;//比较函数对象,用于比较两个range右端点.&#125;;int main() &#123;int n;cin &gt;&gt; n;vector&lt;range&gt; ranges;//存在向量ranges中for (int i = 0; i &lt; n; i++)&#123;    int l, r;    cin &gt;&gt; l &gt;&gt; r;    ranges.push_back(&#123; l,r,i &#125;);&#125;//存在向量ranges中sort(ranges.begin(), ranges.end());//先排序priority_queue&lt;range, vector&lt;range&gt;, CompareR&gt;pq;vector&lt;int&gt;res(n);int index = 0;//定义了一个最大堆pq,使用CompareR作为比较标准.还定义了一个结果向量res,用于存储每个区间的代表点,以及一个索引index用于遍历ranges.for (int k = 1; k &lt;= n; k++)&#123;    while (index &lt; n &amp;&amp; ranges[index].l &lt;= k)    &#123;        pq.push(ranges[index++]);    &#125;    while (pq.empty() == 0 &amp;&amp; pq.top().r &lt; k) pq.pop();    if (pq.empty())    &#123;        cout &lt;&lt; -1;        return 0;    &#125;    auto [l, r, pos] = pq.top();    pq.pop();    res[pos] = k;&#125;//这个循环遍历从1到n的每个点k,尝试为每个区间找到一个代表点.//它首先将所有左端点小于等于k的区间加入堆中.然后移除所有右端点小于k的区间(因为它们不包含k).//如果堆为空,意味着没有区间包含当前的k,程序输出-1并结束.否则,取出堆顶元素(即右端点最大的区间),将k作为该区间的代表点存储在res中.for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot;;//最后遍历结果向量res,输出每个区间的代表点//等价于:// for (size_t i = 0; i &lt; res.size(); ++i)// &#123;//   int x = res[i];//   cout &lt;&lt; x &lt;&lt; &quot; &quot;;// &#125;return 0;&#125;</code></pre><hr><h1 id="E-双生双宿之错"><a href="#E-双生双宿之错" class="headerlink" title="E 双生双宿之错"></a>E 双生双宿之错</h1><p>链接: <a href="https://ac.nowcoder.com/acm/contest/95323/E">https://ac.nowcoder.com/acm/contest/95323/E</a></p><p>知识点:排序，中位数定理</p><p>难度: 1782</p><p>知道或者能推出结论就不难,本质上是数学的一条线段上一个动点到多定点的距离和最小,只不过此题先二分,分别求其到中位数的距离.<br>但要考虑两段中位数相等时的问题,要分两种情况:<br>1.前面一半集体到中位数-1的距离,后一半到中位数的距离<br>2.前一半集体到中位数的距离,后一半到中位数-1的距离<br>二者要取min</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;ll calculate_cost(const vector&lt;int&gt;&amp; arr, int start, int end, int target)&#123;ll cost = 0;for (int i = start; i &lt; end; i++)&#123;    cost += fabs(arr[i]-target);&#125;return cost;&#125;void func()&#123;int T;cin &gt;&gt; T;for (int i = 0; i &lt; T; i++)&#123;    int n;    cin &gt;&gt; n;    vector&lt;int&gt;arr(n);    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; arr[i];    &#125;    sort(arr.begin(),arr.end());    int half = n / 2;    int a, b;    if (half % 2 == 0)    &#123;        a = (arr[half / 2 - 1] + arr[half / 2]) / 2;    &#125;    else    &#123;        a = arr[half / 2];    &#125;    if (half % 2 == 0)    &#123;        b = (arr[half+half / 2 - 1] + arr[half+half / 2]) / 2;    &#125;    else    &#123;        b = arr[half+half / 2];    &#125;    if (a != b)    &#123;        ll cost = calculate_cost(arr, 0, half, a) + calculate_cost(arr, half, n, b);        cout &lt;&lt; cost &lt;&lt; &quot;\n&quot;;    &#125;    else    &#123;        int option1_x = a - 1;        int option1_y = a;        ll cost1 = calculate_cost(arr, 0, half, option1_x) + calculate_cost(arr, half, n, option1_y);        int option2_x = a;        int option2_y = a + 1;        ll cost2 = calculate_cost(arr, 0, half, option2_x) + calculate_cost(arr, half, n, option2_y);        cout &lt;&lt; min(cost1, cost2) &lt;&lt; &quot;\n&quot;;    &#125;  &#125;&#125;int main() &#123;func();return 0;&#125;</code></pre><hr><h1 id="M-数值膨胀之美"><a href="#M-数值膨胀之美" class="headerlink" title="M 数值膨胀之美"></a>M 数值膨胀之美</h1><p>链接: <a href="https://ac.nowcoder.com/acm/contest/95323/M">https://ac.nowcoder.com/acm/contest/95323/M</a></p><p>知识点: 贪心,模拟,线段树,ST表.</p><p>难度: 1274</p><p>数据弱了,可以混过去,但现在不行(沮丧).出的非常好,成功使我被击败…<br>官方思路:<br>如果区间只有一个数,一定会选择min * 2, min * 2之后区间极差有哪些可能?<br>1.Max-2*Min(2Min还是最小值)<br>2.2Min-次小值(2Min比Max大)<br>3.Max-次小值(2Min比Max小,比次小值大)</p><p>已知:极差唯一有可能减小的,就是Min*2但怎么维护 *2区间的mzx,min和剩下的max,min?<br>ST表,线段树.<br>可发现,变化完次小值成了有决定的值,那么就又有方案给次小值乘2.<br>次小值要乘2,那就是最小值到次小值的区间一起乘2.<br>这个区间乘2以后,最小值可能会变成第三最小值,也可能是最小值乘2,最大值有可能是原来的最大值,也有可能是这个区间的最大值乘2</p><p>所以,极差是”乘2的区间的最大值和剩下的最大值取最大”–”乘2的区间的最小值与剩下的最小值取最小”</p><p>剩下的区间的max–就用原数组的max,如果TA被乘2了,那么乘2区间的max才是答案,剩下的区间真的max也不管用.<br>剩下的区间min:<br>1.先结构体排序,指针指向还没乘2的最小数–如果指向的数在乘2的区间中,指针++<br>2.开个容器记录还没被乘2的数–求最小值,删除指定的数,有重复值–multiset</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;pair&lt;int, int&gt;a[150000];int b[150000];void func()&#123;int n;cin &gt;&gt; n;for (int i = 0; i &lt; n; i++)&#123;    cin &gt;&gt; a[i].first;    a[i].second = i;    b[i] = a[i].first;&#125;a[n].first = 2e9;sort(a, a + n);int l = a[0].second, r = a[0].second;int ma = max(a[0].first * 2, a[n - 1].first);int res = ma - min(a[0].first * 2, a[1].first);// 遍历处理每个元素for(i=1; i&lt;n; i++)&#123;    // 扩展左边界到包含当前元素的原始位置    while(a[i].second &lt; l) &#123;        l--;        ma = max(ma, b[l]*2); // 更新最大值（可能与区间代价相关）    &#125;    // 扩展右边界到包含当前元素的原始位置    while(a[i].second &gt; r) &#123;        r++;        ma = max(ma, b[r]*2); // 更新最大值    &#125;    // 更新最优解：当前最大值 - 下一元素的值的两倍（或哨兵值）    res = min(res, ma - min(a[0].first*2, a[i+1].first));&#125;cout &lt;&lt; res;  &#125;int main() &#123;func();return 0;&#125;</code></pre><hr><h1 id="J-硝基甲苯之袭"><a href="#J-硝基甲苯之袭" class="headerlink" title="J 硝基甲苯之袭"></a>J 硝基甲苯之袭</h1><p>链接: <a href="https://ac.nowcoder.com/acm/contest/95323/J">https://ac.nowcoder.com/acm/contest/95323/J</a></p><p>知识点:位运算,数论</p><p>难度:1567</p><p>在解决此题之前我们先了解一个性质:<br>a ^ b &#x3D; c &lt;&#x3D;&gt; a ^ c &#x3D; b<br>那么对于本题:<br>ai^gcd&#x3D;aj<br>设gcd是x<br>cnt[ai]*cnt[aj]是满足ai ^ x&#x3D;aj的对数<br>但是x可未必是ai,aj的gcd,需要验证,是ans就加,不是continue<br>x枚举 2-sqrt(a) ai%x&#x3D;&#x3D;0<br>求ai ^ x &#x3D; d -&gt;cnt[d]</p><hr><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;const int N = 2e5 + 1;int n;cin &gt;&gt; n;vector&lt;int&gt; a(N * 2 + 1);//开一个比较大的数组for(int i = 1; i &lt;= n; i++)&#123;    int x;    cin &gt;&gt; x;    a[x]++;//hash计数&#125;auto ans = 0ll;//ans用于累加满足条件的整数对的总次数.auto get = [&amp;](int x, int y)//get函数接收参数x和y,计算y += x得到k = x + y,然后检查x ^ k是否等于gcd(x,k).若成立,则累加a[x] * a[k]到ans.&#123;    y += x;    if((x ^ y) == gcd(x, y)) ans += 1ll * a[x] * a[y];&#125;;for(int i = 2; i &lt;= N; i += 2)&#123;    for(int j = 1; j * j &lt;= i; j++)&#123;        if(i % j) continue;        get(i, j);        if(j * j != i) get(i, i / j);//将一个定为偶数,另一个在此操作变为奇数,可枚举出所有情况.    &#125;遍历偶数 i,枚举其因数 j.对每个因数 j,调用 get(i,j) 和 get(i, i/j).&#125;cout &lt;&lt; ans &lt;&lt; endl;&#125;</code></pre><hr><h1 id="C-兢兢业业之移"><a href="#C-兢兢业业之移" class="headerlink" title="C 兢兢业业之移"></a>C 兢兢业业之移</h1><p>链接: <a href="https://ac.nowcoder.com/acm/contest/95323/C">https://ac.nowcoder.com/acm/contest/95323/C</a></p><p>知识点: 模拟&#x2F;最短路,超大模拟.</p><p>难度: 1952</p><p>考查代码量</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;int main() &#123;int T = 1;cin &gt;&gt; T; // 输入测试用例数量while (T--) &#123;    int n;    cin &gt;&gt; n; // 输入网格大小n    // 初始化网格，周围填充&#39;1&#39;作为边界    std::vector&lt;std::string&gt; s(n + 2, std::string(n + 2, &#39;1&#39;));    for (int i = 1; i &lt;= n; i++)     &#123;        cin &gt;&gt; s[i]; // 输入每行原始数据        s[i] = &quot;1&quot; + s[i] + &quot;1&quot;; // 左右添加边界&#39;1&#39;    &#125;    vector&lt;vector&lt;int&gt;&gt; ans; // 存储操作记录        // 定义移动函数    auto go = [&amp;](int x, int y, char c)     &#123;        int dx = x, dy = y; // 计算移动后的坐标        dx -= (c == &#39;U&#39;);   // 向上移动行号-1        dx += (c == &#39;D&#39;);   // 向下移动行号+1        dy -= (c == &#39;L&#39;);   // 向左移动列号-1        dy += (c == &#39;R&#39;);   // 向右移动列号+1        swap(s[x][y], s[dx][dy]); // 交换元素        ans.push_back(&#123;x, y, dx, dy&#125;); // 记录操作    &#125;;    // 第一阶段：垂直方向整理（向上推）    for (int i = 1; i &lt;= n; i++)     &#123;        for (int j = 1; j &lt;= n; j++)         &#123;            // 从当前位置向上遍历            for (int k = i; k &gt;= 1; k--)             &#123;                if (s[k][j] == &#39;1&#39; &amp;&amp; s[k-1][j] == &#39;0&#39;)                 &#123;                    go(k, j, &#39;U&#39;); // 将&#39;1&#39;向上移动到&#39;0&#39;的位置                &#125; else break; // 遇到障碍停止            &#125;        &#125;    &#125;    // 第二阶段：水平方向整理（向左推）    for (int i = 1; i &lt;= n; i++)     &#123;        for (int j = 1; j &lt;= n; j++)         &#123;            // 从当前位置向左遍历            for (int k = j; k &gt;= 1; k--)             &#123;                if (s[i][k] == &#39;1&#39; &amp;&amp; s[i][k-1] == &#39;0&#39;)                 &#123;                    go(i, k, &#39;L&#39;); // 将&#39;1&#39;向左移动到&#39;0&#39;的位置                &#125; else break;            &#125;        &#125;    &#125;    // 第三阶段：处理右上区域    for (int i = n/2; i &gt;= 1; i--)    &#123; // 从中间行向上        for (int j = n; j &gt; n/2; j--)         &#123; // 右侧列向左            if (s[i][j] == &#39;0&#39;) continue; // 跳过空位            // 在左上区域寻找空位            int x = 0, y = 0;            for (int k = 1; k &lt;= n/2; k++)             &#123;                for (int l = 1; l &lt;= n/2; l++)                 &#123;                    if (s[k][l] == &#39;1&#39;) continue;                    x = k; y = l;                    break;                &#125;                if (x) break;            &#125;            // 垂直向下移动            for (int k = i; k &lt; x; k++) go(k, j, &#39;D&#39;);            // 水平向左移动            for (int k = j; k &gt; y; k--) go(x, k, &#39;L&#39;);        &#125;    &#125;    // 第四阶段：处理右下区域    for (int i = n; i &gt; n/2; i--)    &#123; // 从底部行向上        for (int j = n/2; j &gt;= 1; j--)         &#123; // 中间列向左            if (s[i][j] == &#39;0&#39;) continue;            // 在左上区域寻找空位            int x = 0, y = 0;            for (int k = 1; k &lt;= n/2; k++)             &#123;                for (int l = 1; l &lt;= n/2; l++)                 &#123;                    if (s[k][l] == &#39;1&#39;) continue;                    x = k; y = l;                    break;                &#125;                if (x) break;            &#125;            // 水平向右移动（实际是向左填充）            for (int k = j; k &lt; y; k++) go(i, k, &#39;R&#39;);            // 垂直向上移动            for (int k = i; k &gt; x; k--) go(k, y, &#39;U&#39;);        &#125;    &#125;    // 输出操作步骤    cout &lt;&lt; ans.size() &lt;&lt; endl;    for (auto&amp; i : ans)    &#123;        for (auto&amp; j : i) cout &lt;&lt; j &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;  &#125;&#125;</code></pre><hr><h1 id="F-双生双宿之探"><a href="#F-双生双宿之探" class="headerlink" title="F.双生双宿之探"></a>F.双生双宿之探</h1><p>知识点: 双指针,前缀和,逻辑,线段树,ST表 </p><p>难度: 2213</p><p>难题,首先考虑暴力n^3肯定超时.<br>稍微优化一下,l到r中数的个数＞2了,r就不要往后走了</p><p>优化的基本思路:1.&lt;循环优化&gt;(1)变成区间端点 (2)拆成多个小区间 &#x2F;&#x2F;一重一重去看能丢掉哪个不(l,r同理,得去掉某一个)<br>               2.&lt;计数优化&gt;前缀和</p><p>先把每一个符合条件的LR最大范围求出来(知道最左边在哪最右边在哪),然后在这个区间里去找符合条件的区间有多少对</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;void func() &#123;int T;cin &gt;&gt; T;for(int i=0; i&lt;T; i++) &#123;  // 处理每个测试用例    int n;    cin &gt;&gt; n;    vector&lt;int&gt; a(n + 1);  // 数组从索引1开始    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];    &#125;    vector&lt;int&gt; f(n + 1);  // 前缀和数组    ll ans = 0;            for (int i = 1; i &lt;= n; i++)             &#123;        set&lt;int&gt; st;        // 记录当前窗口内的不同元素        map&lt;int, int&gt; mp;   // 统计前缀和出现次数        mp[0]++;            // 初始前缀和为0的情况        f[i-1] = 0;         // 初始化前缀和                for (int j = i; j &lt;= n; j++)                 &#123;            st.insert(a[j]);            if (st.size() &gt; 2)             &#123;  // 元素超过2种，调整窗口                i = j;                            st.clear();                               for (; i &gt;= 1; i--)                &#123;                    st.insert(a[i]);                    if (st.size() &gt; 2) break;                &#125;                break;  // 退出内层循环            &#125;            // 更新前缀和            f[j] = f[j-1] + (a[j] == a[i] ? 1 : -1);            ans += mp[f[j]];  // 累加当前前缀和的出现次数            mp[f[j]]++;       // 记录当前前缀和            if (j == n) i = n; // 强制退出外层循环        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;  &#125;&#125;int main()&#123;func();return 0;&#125;</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM新手村 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法技巧1(个人总结--持续更新中)</title>
      <link href="/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
      <url>/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>本篇文章总结了一些笔者对算法竞赛中一些常用的数学算法方法,可极大节省时间空间复杂度.<br>持续更新中……</p><hr><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>为了更好引入此概念,牛客上有一道经典的算法题,将它归类到位运算中(本质上就是这个).<br>题目如下:</p><p>链接:<a href="https://ac.nowcoder.com/acm/contest/996/A">https://ac.nowcoder.com/acm/contest/996/A</a><br>来源:牛客网</p><p>题目描述<br>求a的b次方对p取模的值,其中0≤a,b,p≤10^9,p&gt;0</p><p>输入描述:<br>三个用空格隔开的整数a,b和p.<br>输出描述:<br>一个整数表示a^b(mod)p的值.</p><p>看起来简单吧?只需要for循环再取mod就可收工了.但看看范围,很明显直接爆了或者超时.<br>你就算开long long 都没用!</p><p>分析:</p><p>本质上问题的解决还是在于a^b,这太大了,以至于分开求模再次方也无济于事.<br>这时候,有没有一种少一些循环且高效的算法呢?<br>不妨想想计算机是如何存储数据的.<br>不妨设想b为2的n次方.</p><p>就令b&#x3D;64.演示如下:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a^<span class="number">1</span>*a^<span class="number">1</span>=a^<span class="number">2</span></span><br><span class="line">a^<span class="number">2</span>*a^<span class="number">2</span>=a^<span class="number">4</span></span><br><span class="line">a^<span class="number">4</span>*a^<span class="number">4</span>=a^<span class="number">8</span></span><br><span class="line">a^<span class="number">8</span>*a^<span class="number">8</span>=a^<span class="number">16</span></span><br><span class="line">a^<span class="number">16</span>*a^<span class="number">16</span>=a^<span class="number">32</span></span><br><span class="line">a^<span class="number">32</span>*a^<span class="number">32</span>=a^<span class="number">64</span></span><br></pre></td></tr></table></figure><hr><p>本质是倍增原理,将a的数量翻倍.<br>那么不为2的情况呢?</p><p>来个b&#x3D;105.那么…</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a^<span class="number">105</span>=a*a^<span class="number">8</span>*a^<span class="number">32</span>*a^<span class="number">64</span></span><br><span class="line"></span><br><span class="line">(<span class="number">105</span>)<span class="number">10</span>=(<span class="number">1101001</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">1</span>)<span class="number">10</span>  =(<span class="number">0000001</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">8</span>)<span class="number">10</span>  =(<span class="number">0001000</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">32</span>)<span class="number">10</span> =(<span class="number">0100000</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">64</span>)<span class="number">10</span> =(<span class="number">1000000</span>)<span class="number">2</span></span><br><span class="line"><span class="comment">//综合起来,看下伪代码:</span></span><br><span class="line"></span><br><span class="line">function <span class="built_in">binexp</span>(a,b)</span><br><span class="line">    r=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b!=<span class="number">0</span> <span class="comment">//从低到高不断遍历每一位</span></span><br><span class="line">       <span class="keyword">if</span> n mod <span class="number">2</span>==<span class="number">1</span> <span class="comment">//如果遍历是1 优化:n&amp;1</span></span><br><span class="line">          r = r*a <span class="comment">//乘上各循环所对应的a的倍增数</span></span><br><span class="line">       a =a*a <span class="comment">//倍增a</span></span><br><span class="line">       b=[b/<span class="number">2</span>]<span class="comment">//优化:b&gt;&gt;1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"> 时间复杂度;<span class="built_in">O</span>(logn)</span><br></pre></td></tr></table></figure><hr><p>呼,接下来不就简单了吗?</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b, p,ans;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">ans = <span class="number">1</span> % p;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=ans*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a * a % p;</span><br><span class="line">    b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><p>嘻嘻,同样类型,思路上是一样的但是细节上还是略有差别.<br>还是举例牛客,看题!</p><p>链接:<a href="https://ac.nowcoder.com/acm/contest/996/C">https://ac.nowcoder.com/acm/contest/996/C</a><br>来源:牛客网</p><p>题目描述<br>求a乘b对p取模的值,其中1≤a,b,p≤10^18<br>输入描述:<br>第一行a,第二行b,第三行p.<br>输出描述:<br>一个整数,表示a×b(mod)p的值.</p><p>有了上一题的基础,理解起来想必容易很多.<br>但算法的细节还是不一样的.<br>这是将后面一个乘数转化为二进制形式计算.</p><p>举个例子吧!</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>*<span class="number">11</span>%<span class="number">5</span></span><br><span class="line"><span class="number">12</span>*<span class="number">11</span>=<span class="number">12</span>*(<span class="number">1011</span>)<span class="number">2</span>=<span class="number">12</span>*<span class="number">2</span>^<span class="number">3</span><span class="number">+12</span>*<span class="number">2</span>^<span class="number">1</span><span class="number">+12</span>*<span class="number">2</span>^<span class="number">0</span>=<span class="number">96</span><span class="number">+24</span><span class="number">+12</span>=<span class="number">132</span></span><br><span class="line">用&amp;与(&gt;&gt;,&lt;&lt;)得出</span><br><span class="line">计算转换为:</span><br><span class="line">((<span class="number">12</span>%<span class="number">5</span>)+(<span class="number">24</span>%<span class="number">5</span>)+(<span class="number">96</span>%<span class="number">5</span>))%<span class="number">5</span>=(<span class="number">2</span><span class="number">+4</span><span class="number">+1</span>)%<span class="number">5</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p>现在就好理解了.</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksc</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(b)<span class="comment">//与上一题一样,从低到高不断遍历每一位</span></span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">if</span>((b&amp;<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            result=(result+a)%p;<span class="comment">//这样理解了为啥是加而不是乘</span></span><br><span class="line">            &#125;</span><br><span class="line">      a = (a + a) % p;</span><br><span class="line">      b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>那么,解决问题!</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b, p,ans;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=(ans+a)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    a = (a + a) % p;</span><br><span class="line">    b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="统计问题"><a href="#统计问题" class="headerlink" title="统计问题"></a>统计问题</h2><p>可以说应该算固定题了.但依旧应用到了分治递归的思想.下面通过牛客上的几道题逐步理解这种思想.</p><p>[NOIP2010]数字统计<br>链接:<a href="https://ac.nowcoder.com/acm/contest/19859/A">https://ac.nowcoder.com/acm/contest/19859/A</a><br>来源:牛客网</p><p>题目描述<br>请统计某个给定范围[L,R]的所有整数中,数字2出现的次数.</p><p>比如给定范围[2,22],数字2在数2中出现了1次,在数12中出现1次,在数20中出现1次,在数21中出现1次,在数22中出现2次,所以数字2在该范围内一共出现了6次.</p><p>输入描述:<br>输入共1行,为两个正整数L和R,之间用一个空格隔开.<br>输出描述:<br>输出共1行，表示数字2出现的次数.<br>备注:<br>1≤L≤R≤10000</p><p>分析:<br>初次见到时,相信很可能会这么想:从L–R全部遍历过去,于是就想用一个for循环将搜寻给定数出现的次数.<br>所以可以写出以下代码:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//声明全局变量</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//我在这里写了函数,用于判断特定数字出现的个数.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (a&gt;<span class="number">0</span>)<span class="comment">//个人觉得这个循环可以作为模板了.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">2</span>)<span class="comment">//如果有得到目标元素就ans++</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a / <span class="number">10</span>; 相当于二进制中的&gt;&gt;将十进制的位数向左移动一位</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> L;</span><br><span class="line">   <span class="type">int</span> R;</span><br><span class="line"> </span><br><span class="line">cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; i++)<span class="comment">//这就是遍历了.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = i;</span><br><span class="line">    <span class="built_in">solve</span>(k);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>评价:难想到的就是如何将高位数也统计到.本质上还是位运算.</p><h2 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h2><p>计算机挑战赛遇到了,大整数相加,相乘.实际上都属于高精度算法一类的.在之后的比赛中对于范围的控制尤为重要.<br>下面更新大整数的高精度算法.</p><h2 id="1-大整数相加"><a href="#1-大整数相加" class="headerlink" title="1.大整数相加"></a>1.大整数相加</h2><p>基本逻辑:对于过长的数据,我们采用数组的形式来处理.因此我们建立两个存放加数的数组和一个存放和的数组.对两个加数数组的每一位相加并进位后,便可获得最终得数,输出即可.</p><p>(1)我们引入两组数字:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> m[<span class="number">500</span>],n[<span class="number">500</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br></pre></td></tr></table></figure><hr><p>用char的原因:(1)我们在后面要使用strlen函数去获取字符串长度.<br>                     (2)方便输入.<br>(2)将每一位”char”型数字逆序存放进整型数组</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">501</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//a,b数组存放加数,c用于存放和</span></span><br><span class="line"><span class="type">int</span> lena，lenb；</span><br><span class="line">lena=<span class="built_in">strlen</span>(m);<span class="comment">//strlen函数是获取数组长度的,如abc的长度为3</span></span><br><span class="line">lenb=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lena;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[lena<span class="number">-1</span>-i]=m[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">/*这一步是为了将&#x27;char&#x27;类型的数组逆序转存为便于计算的‘int’类型</span></span><br><span class="line"><span class="comment">逆序转存:更便于我们后面的进位,比如c[k]大于10我们向c[k+1]进位,逻辑上比正序通顺.*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lenb;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[lenb-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(3)计算并处理进位</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> la,lb,lmax;<span class="comment">//la和lb表示数组长度，lmax是a和b中长度较大的那个数字的长度</span></span><br><span class="line"><span class="keyword">if</span>(la&gt;lb)</span><br><span class="line">&#123;</span><br><span class="line">lmax=la;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lmax=lb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lmax;i++)<span class="comment">//i从1循环到lmax</span></span><br><span class="line">&#123;</span><br><span class="line">c[i]+=a[i]+b[i];<span class="comment">//先将a的第i位和b的第i位相加，即加数相加</span></span><br><span class="line"><span class="keyword">if</span>(c[i]&gt;=<span class="number">10</span>)<span class="comment">//当c的某一位大于10，进位</span></span><br><span class="line">&#123;</span><br><span class="line">c[i<span class="number">+1</span>]+=c[i]/<span class="number">10</span>;<span class="comment">//c[i+1]进c[i]的十位</span></span><br><span class="line">c[i]=c[i]%<span class="number">10</span>;<span class="comment">//保留c[i]的个位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[lmax]&gt;<span class="number">0</span>)<span class="comment">//这一步来判断两个加数相加后最大位数是否发生改变</span></span><br><span class="line">             <span class="comment">//比如1和10相加最大位数还是2，但1和99相加最大位数就变为了3</span></span><br><span class="line">&#123;</span><br><span class="line">lmax++;<span class="comment">//如果比最大加数位数还大一位的数字不为零，那么最大位数加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(4) 逆序输出和</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=lmax<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>完整代码:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span><span class="comment">//用的strlen源自于这个头文件</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">500</span>],n[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">501</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> la,lb,lmax;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br><span class="line">la=<span class="built_in">strlen</span>(m);</span><br><span class="line">lb=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">if</span>(la&gt;lb)</span><br><span class="line">&#123;</span><br><span class="line">lmax=la;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lmax=lb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;la;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[la<span class="number">-1</span>-i]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lb;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[lb-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lmax;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]+=a[i]+b[i];</span><br><span class="line"><span class="keyword">if</span>(c[i]&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">c[i<span class="number">+1</span>]+=c[i]/<span class="number">10</span>;</span><br><span class="line">c[i]=c[i]%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[lmax]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">lmax++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=lmax<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-大整数相减"><a href="#2-大整数相减" class="headerlink" title="2.大整数相减"></a>2.大整数相减</h2><p>加法和减法其实并没有什么区别,但相对于加法,减法所涉及到的范围内更大.以下是易踩坑的地方:<br>1.为什么不能直接用int数组接收数据，而是要用字符串输入(对前面补充的细节)</p><p>错误地认为通过int数组输入时,会如同string类型一样,每个位置只有0~9.事实上,当我输入13时,接收到的并不是1,3.而是13.<br>因此必须先由字符串输入,再通过int数组接收.</p><p>2.被减数大于减数的情况和减数大于被减数的情况有什么不同</p><p>当被减数小于减数时应该倒过来:先换位被减数和减数,再正常计算后,前面加上”-“<br>因此必须比较被减数和减数的大小:<br>运用字符串比较大小:(精髓)由于字符串比较时,只会逐位比较,因此 9 &gt; 80???所以必须加上长度限制.</p><p>3.倒置后的消零处理</p><p>比如100000000-100000000时,未消去0则会输出000000000.<br>因此必须消去.</p><p>直接上题目吧!</p><p>题目描述<br>高精度减法。</p><p>输入格式<br>两个整数 a,b（第二个可能比第一个大）。</p><p>输出格式<br>结果（是负数要输出负号）。</p><p>输入输出样例<br>输入 </p><p>2<br>1<br>输出 </p><p>1<br>说明&#x2F;提示<br>20% 数据 a,b 在 long long 范围内;<br>100% 数据 0&lt;a,b≤10^10086.</p><p>代码如下:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line">string A, B;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000000</span>], b[<span class="number">1000000</span>], c[<span class="number">10000000</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line"><span class="comment">//首先要得到a，b的字符串长度</span></span><br><span class="line"><span class="type">int</span> len_a = <span class="number">0</span>, len_b = <span class="number">0</span>, len_max, temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; A[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">len_a++;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; B[j] != <span class="string">&#x27;\0&#x27;</span>; j++)</span><br><span class="line">len_b++;</span><br><span class="line"><span class="comment">//赋值int数组</span></span><br><span class="line"><span class="comment">/*然后将a，b的字符串分别进行倒序，方便向后一位借1：</span></span><br><span class="line"><span class="comment">例如：输入时是550和350，高位在前，倒序后为055和053，高位在后*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len_a; i++)</span><br><span class="line">a[len_a - i - <span class="number">1</span>] = A[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len_b; j++)</span><br><span class="line">b[len_b - j - <span class="number">1</span>] = B[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//进行高精度减法：1.先得到长的数字长度</span></span><br><span class="line">len_max = len_a &gt; len_b ? len_a : len_b;</span><br><span class="line"><span class="comment">//调试</span></span><br><span class="line"><span class="comment">/*for (i = 0; i &lt; len_max; i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;a=&quot; &lt;&lt; *(a + i) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (j = 0; j &lt; len_max; j++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;b=&quot; &lt;&lt; *(b + j) &lt;&lt; endl;*/</span></span><br><span class="line"><span class="comment">//计算:先判断被减数和减数哪个大,减数大则要换位</span></span><br><span class="line"><span class="keyword">if</span> (A &lt; B &amp;&amp; len_a == len_b || len_a &lt; len_b) &#123; <span class="comment">//通过字符串比较大小，可以得知两个数字的大小</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len_max; i++) &#123;</span><br><span class="line">c[i] = b[i] - a[i] + temp;<span class="comment">//temp为借位操作，当上一位小于0时</span></span><br><span class="line"><span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">temp = <span class="number">-1</span>;</span><br><span class="line">c[i] += <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//temp一定等于-1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="comment">//还需要进行消零操作：有时需要的是1，而不是000001</span></span><br><span class="line"><span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (c[i] == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)<span class="comment">/*当最后一位为零时不可删除，其余前面的零删除，</span></span><br><span class="line"><span class="comment">但是比如200-300=-100，其中后面的零不可以删除，所以选择缩短数列长度，</span></span><br><span class="line"><span class="comment">如此只可能删除有效数字前面的零*/</span></span><br><span class="line">len_max--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">cout &lt;&lt; c[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len_max; i++) &#123;</span><br><span class="line">c[i] = a[i] - b[i] + temp;<span class="comment">//temp为借位操作，当上一位小于0时</span></span><br><span class="line"><span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">temp = <span class="number">-1</span>;</span><br><span class="line">c[i] += <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//temp一定等于0</span></span><br><span class="line"><span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (c[i] == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)<span class="comment">//同样进行消零操作</span></span><br><span class="line">len_max--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">cout &lt;&lt; c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><hr><h2 id="3-大整数乘法"><a href="#3-大整数乘法" class="headerlink" title="3.大整数乘法"></a>3.大整数乘法</h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)我们引入两组数字:</span><br><span class="line">  </span><br><span class="line"><span class="type">char</span> m[<span class="number">2000</span>],n[<span class="number">2000</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br></pre></td></tr></table></figure><hr><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>)将每一位<span class="string">&quot;char&quot;</span>型数字逆序存放进整型数组</span><br><span class="line"><span class="type">int</span> a[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> lm,ln;<span class="comment">//lm、ln分别表示m和n的位数</span></span><br><span class="line">lm=<span class="built_in">strlen</span>(m);<span class="comment">//strlen函数是获取数组长度的,如abc的长度为3</span></span><br><span class="line">ln=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[lm-i<span class="number">-1</span>]=m[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">/*这一步是为了将&#x27;char&#x27;类型的数组逆序转存为便于计算的&#x27;int&#x27;类型</span></span><br><span class="line"><span class="comment">逆序转存：更便于我们后面的进位,比如c[k]大于10我们向c[k+1]进位,逻辑上比正序通顺.*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ln;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[ln-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>)计算并处理进位</span><br><span class="line"></span><br><span class="line">乘法结果位数的三种情况:</span><br><span class="line"></span><br><span class="line">位数等于两乘数位数之和(如<span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span>).</span><br><span class="line">位数等于两位数的和减<span class="number">1</span>(如<span class="number">1</span>*<span class="number">9</span>=<span class="number">9.</span></span><br><span class="line">结果为<span class="number">0</span>(<span class="number">100</span>*<span class="number">0</span>=<span class="number">0</span>).</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;ln;j++)</span><br><span class="line">&#123;</span><br><span class="line">k=i+j;</span><br><span class="line">c[k]+=a[i]*b[j];</span><br><span class="line"><span class="keyword">if</span>(c[k]&gt;=<span class="number">10</span>)<span class="comment">//保证数组中的数字都&lt;10</span></span><br><span class="line">&#123;</span><br><span class="line">c[k<span class="number">+1</span>]+=c[k]/<span class="number">10</span>;<span class="comment">//c[i+1]进c[i]的十位</span></span><br><span class="line">c[k]%=<span class="number">10</span>;<span class="comment">//保留c[i]的个位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(5)逆序输出积</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=lc<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(6)完整代码:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">2000</span>],n[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">4000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="type">int</span> lm,ln,lc;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br><span class="line">lm=<span class="built_in">strlen</span>(m);</span><br><span class="line">ln=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[lm-i<span class="number">-1</span>]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ln;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[ln-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;ln;j++)</span><br><span class="line">&#123;</span><br><span class="line">k=i+j;</span><br><span class="line">c[k]+=a[i]*b[j];</span><br><span class="line"><span class="keyword">if</span>(c[k]&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">c[k<span class="number">+1</span>]+=c[k]/<span class="number">10</span>;</span><br><span class="line">c[k]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[lm+ln<span class="number">-1</span>]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">lc=lm+ln;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lc=lm+ln<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c[lc<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;lc&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">lc--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=lc<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-大整数相除"><a href="#4-大整数相除" class="headerlink" title="4.大整数相除"></a>4.大整数相除</h2><p>核心逻辑——逐位试商法：</p><p>总结:从第一位开始试商,除不下就乘10,除得下相处后余数乘10在加上后一位,逐位顺过去,直到最后一位.</p><p>(1)我们引入两组数字:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> m[<span class="number">5000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,rem=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,m);<span class="comment">//除数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);<span class="comment">//低精度的被除数V</span></span><br></pre></td></tr></table></figure><hr><p>(2)将字符数组m转为整形(这里不用逆序,原因是除法不用处理进位)</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lm;<span class="comment">//数组m的长度</span></span><br><span class="line">lm=<span class="built_in">strlen</span>(m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(3)逐位试商</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)<span class="comment">//lm是被除数长度，从第一位试到最后一位</span></span><br><span class="line">&#123;</span><br><span class="line">c[i]=(rem*<span class="number">10</span>+a[i])/n;<span class="comment">//rem为余数</span></span><br><span class="line">rem=(rem*<span class="number">10</span>+a[i])%n;<span class="comment">//不理解的看上面核心思想部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(4)删除前导0</p><p>和之前的都不一样了,因为之前是逆序的,删除最后一位即可.这个是顺序,代码如下:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(c[<span class="number">0</span>]==<span class="number">0</span>)<span class="comment">//当第一位为0时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)<span class="comment">//将每一位数字前移，第一位数字数据丢失</span></span><br><span class="line">&#123;</span><br><span class="line">c[i]=c[i<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line">lm--;<span class="comment">//第一位删掉了，因此长度也-1</span></span><br><span class="line"><span class="keyword">if</span>(lm&lt;=<span class="number">0</span>)<span class="comment">//如果总长度小于等于0，直接输出0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(5)顺序输出</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(6)完整代码:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">5000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,rem=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5000</span>],c[<span class="number">5000</span>];</span><br><span class="line"><span class="type">int</span> lm,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">lm=<span class="built_in">strlen</span>(m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]=(rem*<span class="number">10</span>+a[i])/n;</span><br><span class="line">rem=(rem*<span class="number">10</span>+a[i])%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]=c[i<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line">lm--;</span><br><span class="line"><span class="keyword">if</span>(lm&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-高精度阶乘"><a href="#5-高精度阶乘" class="headerlink" title="5.高精度阶乘"></a>5.高精度阶乘</h2><p>与乘法类似:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h 250000</span></span><br><span class="line"><span class="type">char</span> print[h] = &#123; <span class="string">&#x27;1&#x27;</span> &#125;;</span><br><span class="line"><span class="type">int</span> num1[h] = &#123; <span class="number">0</span> &#125;, num2[h] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans[h] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> len1 = <span class="number">0</span>, sumlen,k = <span class="number">0</span>;</span><br><span class="line">len1 = <span class="built_in">strlen</span>(print);</span><br><span class="line"><span class="comment">//反转写入数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)num1[k++] = (print[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//将因数拆分反向装入数组</span></span><br><span class="line"><span class="keyword">while</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">num2[k++] = n % <span class="number">10</span>;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟乘法竖式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">&#123;</span><br><span class="line">ans[j + i] += num1[i] * num2[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sumlen = len1 + k;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//进位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sumlen; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans[i] &gt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">ans[i] = ans[i] % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转写入字符串</span></span><br><span class="line"><span class="keyword">while</span> (!ans[sumlen])sumlen--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sumlen; i &gt;= <span class="number">0</span>; i--)print[k++] = ans[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fact</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; print;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h1><h2 id="入门基础"><a href="#入门基础" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="预备知识—二叉树的遍历"><a href="#预备知识—二叉树的遍历" class="headerlink" title="预备知识—二叉树的遍历"></a>预备知识—二叉树的遍历</h3><ul><li>&#x2F;picrooms&#x2F;二叉树-DFS演示.png</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光合远见实验室比赛回顾</title>
      <link href="/2024/10/15/%E5%85%89%E5%90%88%E8%BF%9C%E8%A7%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%AF%94%E8%B5%9B%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/10/15/%E5%85%89%E5%90%88%E8%BF%9C%E8%A7%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%AF%94%E8%B5%9B%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>笔者侥幸通过了测试,趁着还未过去许久,回顾与反思程序设计的不足及改进措施.</p><hr><h2 id="B2114-配对碱基链"><a href="#B2114-配对碱基链" class="headerlink" title="B2114. 配对碱基链"></a>B2114. 配对碱基链</h2><p>题目描述<br>脱氧核糖核酸(DNA)由两条互补的碱基链以双螺旋的方式结合而成.<br>而构成 DNA 的碱基共有4种:</p><p>分别为<br>腺嘌呤(A)<br>鸟嘌呤(G)<br>胸腺嘧啶(T)<br>胞嘧啶(C)<br>我们知道,在两条互补碱基链的对应位置上,腺嘌呤总是和胸腺嘧啶配对,鸟嘌呤总是和胞嘧啶配对.<br>你的任务就是根据一条单链上的碱基序列,给出对应的互补链上的碱基序列.</p><p>输入格式<br>一个字符串,表示一条碱基链.</p><p>这个字符串只含有大写字母<br>A,T,G,C分别表示腺嘌呤,胸腺嘧啶,鸟嘌呤和胞嘧啶.</p><p>字符串长度不超过255.</p><p>输出格式<br>一个只含有大写字母 A,T,G,C 的字符串，为与输入的碱基链互补的碱基链。</p><p>输入数据 1<br>ATATGGATGGTGTTTGGCTCTG</p><p>输出数据 1<br>TATACCTACCACAAACCGAGAC</p><hr><p>个人评价:要点(字符串,数组,循环,条件判断)<br>在考场中本人就犯以下问题:<br>(1)字符数组写好,但一直读入导致输入数据读完还接着读.(for循环一直读入的原因)<br>(2)”&#x3D;&#x3D;”与”&#x3D;”的错误应用.(“&#x3D;&#x3D;”才是等于,”&#x3D;”是赋值（右赋值左）)<br>(3)重复输出.</p><p>正确代码如下:</p><pre><code> #define _CRT_SECURE_NO_WARNINGS #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; using namespace std; int main()&#123;char line[255];scanf(&quot;%s&quot;, line);for (int i = 0; i &lt; 255; i++)&#123;    if (line[i] == &#39;A&#39;)    &#123;        cout &lt;&lt; &#39;T&#39;;    &#125;    else if (line[i] == &#39;T&#39;)    &#123;        cout &lt;&lt; &#39;A&#39;;    &#125;    else if (line[i] == &#39;G&#39;)    &#123;        cout &lt;&lt; &#39;C&#39;;    &#125;    else if (line[i] == &#39;C&#39;)    &#123;        cout &lt;&lt; &#39;G&#39;;    &#125;&#125;return 0;&#125;</code></pre><hr><h2 id="B-矩阵乘法"><a href="#B-矩阵乘法" class="headerlink" title="B. 矩阵乘法"></a>B. 矩阵乘法</h2><p>题目描述:</p><p>n×m 阶的矩阵A乘以m*k 阶的矩阵B得到的矩阵C是n×k阶的,且<br>C[i][j]&#x3D;A[i][0]×B[0][j]+A[i][1]×B[1][j]+……+A[i][m−1]×B[m−1][j]<br>(C[i][j] 表示C矩阵中第i行第j列元素).</p><p>输入格式:<br>第一行为 n,m,k,表示A矩阵是n行m列,B矩阵是m行k列,n,m,k均小于100.</p><p>然后先后输入A和B两个矩阵,A矩阵n行m列,B矩阵 m行k列,矩阵中每个元素的绝对值不会大于1000.</p><p>输出格式</p><p>输出矩阵C,一共 n 行,每行 k 个整数,整数之间以一个空格分开.</p><p>输入数据 1<br>3 2 3<br>1 1<br>1 1<br>1 1<br>1 1 1<br>1 1 1<br>输出数据 1<br>2 2 2<br>2 2 2<br>2 2 2</p><hr><p>个人评价:<br>这是线代!这一定是线代吧!!!不过抛开background不谈,还是要注意范围,线代学到矩阵会特别好懂此题.<br>本质是数学.二维数组+三重for循环表达+格式化输出即可.</p><p>正确代码如下:</p><pre><code>   #define _CRT_SECURE_NO_WARNINGS   #include &lt;cmath&gt;   #include &lt;map&gt;   #include &lt;iostream&gt;   #include&lt;cstring&gt;   #include &lt;stdio.h&gt;   #include &lt;stdlib.h&gt;   using namespace std;    int main ()&#123;int n;int m;int k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;int A[110][110];int B[110][110];int C[110][110];for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; m; ++j)    &#123;        cin &gt;&gt; A[i][j];    &#125;&#125;for (int i = 0; i &lt; m; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        cin &gt;&gt; B[i][j];    &#125;&#125;for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        C[i][j] = 0;        for (int a = 0; a &lt; m; ++a)        &#123;            C[i][j] += A[i][a] * B[a][j]//悲啊!&quot;+&quot;忘了写&quot;+=&quot;表示累加,单纯的&quot;=&quot;会覆盖前一次计算!!!;        &#125;    &#125;&#125;for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        cout &lt;&lt; C[i][j]&lt;&lt;&quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;return 0;&#125;</code></pre><hr><h2 id="D-斐波那契数列"><a href="#D-斐波那契数列" class="headerlink" title="D. 斐波那契数列"></a>D. 斐波那契数列</h2><p>题目描述</p><p>斐波那契数列是指这样的数列:数列的第一个和第二个数都为1,接下来每个数都等于前面2 个数之和.<br>给出一个正整数a,要求斐波那契数列中第 a 个数是多少。</p><p>输入格式</p><p>第 1 行是测试数据的组数n,后面跟着 n 行输入。每组测试数据占 1 行，包括一个正整数a（1≤a≤30).</p><p>输出格式</p><p>输出有 n 行，每行输出对应一个输入.输出应是一个正整数,为斐波那契数列中第 a 个数的大小。</p><p>输入数据<br>1<br>4<br>5<br>2<br>19<br>1<br>输出数据<br>1<br>5<br>1<br>4181<br>1</p><hr><p>个人评价:<br>(函数+递归(只能说出题者没有故意刁难我们出一个超过int类型的数,不然还要%))</p><p>代码如下:</p><pre><code>    #define _CRT_SECURE_NO_WARNINGS    #include &lt;cmath&gt;    #include &lt;map&gt;    #include &lt;iostream&gt;    #include&lt;cstring&gt;    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    using namespace std;    int pell(int n)&#123; if (n == 1)&#123;    return 1;&#125;else if (n == 2)&#123;    return 1;&#125;else&#123;    int a1 = 1, a2 = 1, a3;    for (int i = 0; i &lt; n - 2; i++)    &#123;        a3 = a1+a2;        a1 = a2;        a2 = a3;    &#125;    return a2;&#125;&#125;int main()&#123;int n;int b;cin &gt;&gt; n;for (int i = 0; i &lt; n; i++)&#123;    cin &gt;&gt; b;    cout &lt;&lt; pell(b) &lt;&lt; endl;&#125;return 0;  &#125;</code></pre><hr><h2 id="C-车厢重组"><a href="#C-车厢重组" class="headerlink" title="C.车厢重组"></a>C.车厢重组</h2><p>题目描述:<br>在一个旧式的火车站旁边有一座桥,其桥面可以绕河中心的桥墩水平旋转.<br>一个车站的职工发现桥的长度最多能容纳两节车厢,如果将桥旋转 180 度,则可以把相邻两节车厢的位置交换,用这种方法可以重新排列车厢的顺序.<br>于是他就负责用这座桥将进站的车厢按车厢号从小到大排列.他退休后,火车站决定将这一工作自动化,其中一项重要的工作是编一个程序,输入初始<br>的车厢顺序,计算最少用多少步就能将车厢排序.</p><p>输入格式<br>共两行.</p><p>第一行是车厢总数N(≤10000).</p><p>第二行是N个不同的数表示初始的车厢顺序.<br>(注:实际上数据中并不都在同一行,有可能分行输入)</p><p>输出格式<br>一个整数,最少的旋转次数.</p><p>输入数据 1<br>4<br>4 3 2 1<br>输出数据 1<br>6</p><p>个人反思:开始区分,冒泡排序用的不熟练,会用的写的很快.重新做一遍仍有问题.(具体在代码区)</p><hr><p>代码如下:</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include &lt;stdio.h&gt;           #include &lt;stdlib.h&gt;      #include&lt;stdbool.h&gt;using namespace std;       int b = 0;void BubbleSort(int a[], int size)&#123;for (int i = size - 1; i &gt; 0; --i)&#123;    for (int j = 0; j &lt; i; ++ j)    &#123;        if (a[j] &gt; a[j + 1])        &#123;            int tmp = a[j];            a[j] = a[j + 1];            a[j + 1] = tmp;            b++;  //就是这里统计次数,放在if里面在每次交换时统计次数.        &#125;    &#125;  &#125;&#125; int main()&#123;int N;cin &gt;&gt; N;int a[10001];for (int i = 0; i &lt; N; i++)&#123;    cin &gt;&gt; a[i];&#125;BubbleSort(a, N);cout &lt;&lt; b;return 0;  &#125;</code></pre><hr><h2 id="E-枚举排列"><a href="#E-枚举排列" class="headerlink" title="E. 枚举排列"></a>E. 枚举排列</h2><hr><p>题目描述<br>今有n名学生,要从中选出 k 人排成一列拍照.<br>请按字典序输出所有可能的排列方式.</p><p>输入格式<br>仅一行,两个正整数 n,k.</p><p>输出格式<br>若干行,每行 k 个正整数,表示一种可能的队伍顺序.</p><p>输入数据 1<br>3 2<br>输出数据 1<br>1 2<br>1 3<br>2 1<br>2 3<br>3 1<br>3 2<br>提示<br>对于100% 的数据,1≤k≤n≤10.</p><p>个人反思:深搜…还结合字典序…萌新杀手…<br>具体可看:<a href="https://blog.csdn.net/qq_37050329/article/details/86637183?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223D39BCCB-0B0C-4447-8EFD-CE4040FF37C4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=3D39BCCB-0B0C-4447-8EFD-CE4040FF37C4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86637183-null-">https://blog.csdn.net/qq_37050329/article/details/86637183?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223D39BCCB-0B0C-4447-8EFD-CE4040FF37C4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=3D39BCCB-0B0C-4447-8EFD-CE4040FF37C4&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86637183-null-</a><br>         null.142^v100^pc_search_result_base3&amp;utm_term&#x3D;%E5%AD%97%E5%85%B8%E5%BA%8F&amp;spm&#x3D;1018.2226.3001.4187<br>代码如下:</p><pre><code>  #define _CRT_SECURE_NO_WARNINGS  #include &lt;cmath&gt;  #include &lt;map&gt;  #include&lt;string.h&gt;  #include &lt;iostream&gt;  #include&lt;cstring&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include&lt;stdbool.h&gt;using namespace std;#define MAX_N 10bool used [MAX_N + 1];int path [MAX_N + 1];int n, k;void backtrack(int depth)&#123;if (depth == k)&#123;    for (int i = 0; i &lt; k; i++)    &#123;        printf(&quot;%d &quot;, path[i]);    &#125;printf(&quot;\n&quot;);return;&#125;for (int i = 1; i &lt;= n; i++)&#123;    if (!used[i])    &#123;        used[i] = true;        path[depth] = i;        backtrack(depth + 1);        used[i] = false;    &#125;   &#125; &#125;int main()&#123;scanf(&quot;%d %d&quot;, &amp;n ,&amp;k);memset(used, false, sizeof(used));backtrack(0);return 0;&#125;</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 朝花夕拾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇虚拟机文章</title>
      <link href="/2024/10/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>笔者虚拟机搭建比较简单，是从360管家下的VMware，所以不过多阐述。<br>建议去清华镜像站下载比较方便.</p>]]></content>
      
      
      <categories>
          
          <category> 新手村 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇BLOG搭建文章</title>
      <link href="/2024/10/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG%E6%90%AD%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG%E6%90%AD%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>笔者在这里使用的是hexo+github的个人博客搭建,如有错误请各位大佬指正。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>1.到 <a href="https://nodejs.cn/">https://nodejs.cn/</a> 下载Node.js下载常用版就行。为hexo运行搭建环境。<br>2.（1）github注册。如果English水平不高建议配上网易有道翻译。按web流程进行github注册。<br>  （2）创建代码库，勾选Public，在Repository name中按”用户名.github.io”(一定是这格式！)创建。<br>   (3) 可以自己在code&lt;&gt;选项上进行测试.<br>3. git for windows安装<br>   (1)输入<a href="https://gitforwindows.org/%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E3%80%82">https://gitforwindows.org/进入官网点击下载。</a><br>   (2)git安装默认C盘，可以根据需要自行更改。<br>   (3)勾选 don’t create a start menu folder<br>   (4)注意！！！！！github把master改名main了,配置congif要更改!!也就是branch:master改成branch:main!!<br>   (5)后面默认就行。<br>4.githubShh配置<br>   (1)以管理员身份打开git.bash.exe.<br>   (2)输入命令 ssh-keygen -t rsa -C “github邮箱注册地址”(如果找不到到C盘搜.shh前提是环境安装好)然后回车。<br>   (3)打开github-settings-deploy keys title写用户名，key找到”id rua.pub”复制粘贴。</p><h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>   (1)打开<a href="https://hexo.io/zh-cn/dots/">https://hexo.io/zh-cn/dots/</a><br>   (2)新建文件夹（命名自取）<br>   (3)在此文件夹下用管理员身份打开git.bash.exe.输入npm install hexo-cli -g<br>   (4)安装完用hexo -v验证。（确保路径正确）<br>   (5)在对应路径下输入hexo init初始化.<br>   (6)可以hexo s启动blog.<br>   当然这还未完成，还要挂到github上。<br>   (7)Ctrl+c先关掉。<br>   (8)好了，现在我们还需要装一个git部署插件,输入 snpm install –save hexo-deployer-git回车。<br>   (9)找到_config.yml用记事本打开，划到最底部，找到Depolyment,按如下格式配置。</p><pre><code> type: git repository: 自己的地址 branch:main(注意缩进与空格）</code></pre><p>   (10) hexo d部署(弹出方框输入账号）<br>   (11)成功！！！</p><h2 id="问题反思与感想"><a href="#问题反思与感想" class="headerlink" title="问题反思与感想"></a>问题反思与感想</h2><p>(1)短短几十行，但真正实践起来却要数十倍的时间，实践中，初步了解了0-1的艰难，各种问题层出不穷。<br>eg:路径不对—cd C:\  等去切换。<br>   获取管理员权限。<br>   上面的yml文件未配置好（细节在上）<br>   等。。<br>(2)总之，笔者在此受益颇多,感谢互联网的知识，优秀的作者，让我们前方的路清晰明朗。谢谢！！！</p>]]></content>
      
      
      <categories>
          
          <category> 新手村 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客周赛round64</title>
      <link href="/2024/10/06/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9Bround64/"/>
      <url>/2024/10/06/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9Bround64/</url>
      
        <content type="html"><![CDATA[<p>下面依据(1–10)星级评判本次周赛:</p><h1 id="小红的对错判断"><a href="#小红的对错判断" class="headerlink" title="小红的对错判断"></a>小红的对错判断</h1><p>题目描述<br>小红在判题的时候,经常发现选手把”Yes”输出成”YES”或者”yes”,她希望写一个spj(special judge)来判断选手是否输出了”Yes”.你能帮帮她吗?<br>输入描述:<br>一个长度不超过3的,仅由小写字母或者大写字母组成.<br>输出描述:<br>若字符串可以通过大小写转换变成”Yes”,则输出”accept”.否则输出”wrong answer”.</p><p>评价:  1星,无脑签到题,考查字符串,toupper,tolower函数的用法.如果硬用if,6种情况.</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;void func()&#123;char crr[3] = &#123;0&#125;;scanf(&quot;%s&quot;,crr);for (int i = 0; crr[i]; i++)&#123;    crr[i]=toupper(crr[i]);&#125;if (crr[0] == &#39;Y&#39; &amp;&amp; crr[1] == &#39;E&#39; &amp;&amp; crr[2] == &#39;S&#39;)&#123;    printf(&quot;accept&quot;);&#125;else&#123;    printf(&quot;wrong answer&quot;);&#125;&#125;int main()&#123;func();return 0;&#125;</code></pre><hr><h1 id="小红的幂表达"><a href="#小红的幂表达" class="headerlink" title="小红的幂表达"></a>小红的幂表达</h1><p>题目描述<br>小红拿到了一个正整数,请你帮小红将其表示为幂(a^b)的形式.<br>输入描述:</p><p>一个正整数x (2≤x≤10^5)<br>输出描述:<br>第一行输出x.<br>接下来每一行输出一个幂的表达式。<br>请按指数从小到大的顺序输出。</p><p>评价: 2星,高一数学对数函数换底公式.当时没有这么想,直接优化暴力就过了.</p><hr><pre><code>//实战AC:重点在func1暴力找对数和指数#include &lt;bits/stdc++.h&gt;using namespace std;void func1(int x)&#123; for (int i = sqrt(x); i &gt; 1; i--)&#123;    int j = 1;    int m = i;    while (m &lt; x)    &#123;        m = m * i;        j++;    &#125;    if (m == x)    &#123;        printf(&quot;=%d^%d\n&quot;, i, j);    &#125;&#125;&#125;void func()&#123;int x;cin &gt;&gt; x;cout &lt;&lt; x&lt;&lt;endl;cout &lt;&lt;&quot;=&quot;&lt;&lt; x &lt;&lt; &quot;^&quot; &lt;&lt; &quot;1&quot; &lt;&lt; endl;func1(x);&#125;int main()&#123;func();return 0;&#125;正规解法(也是暴力遍历,复杂度跟我差不多):void func1(int x)&#123; for (int i = sqrt(x); i &gt; 0; i--)&#123;    int m = log2(x) / log2(i);    if (x == pow(i , m))//pow明显增加时间复杂度.    &#123;        printf(&quot;=%d^%d\n&quot;, i, m);    &#125;&#125;&#125;</code></pre><hr><h1 id="小红的前缀询问"><a href="#小红的前缀询问" class="headerlink" title="小红的前缀询问"></a>小红的前缀询问</h1><p>链接:<a href="https://ac.nowcoder.com/acm/contest/92662/C">https://ac.nowcoder.com/acm/contest/92662/C</a></p><p>题目大意:</p><p>小红拿到了一个数组,她有若干次询问,每次询问一个前缀内有多少对相同的数.你能帮帮她吗?</p><p>评价: 4星,从此题起开始上难度,当时map不了解,以后单独开一个系列总结.本题考查map(红黑树),字符串,前缀和.<br>思路:<br>只需要记录在每个前缀前相同的数字出现次数,出现多少次ans就需要加多少ans需在上一个前缀的基础上累加数据大小比较大,开数组记录不可行,需要用到map.</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;using ll=long long;int n;void solve()&#123; cin&gt;&gt;n; map&lt;int,int&gt;mp;// 声明一个键和值都是整数的map有点像动态哈希.  ll ans=0;  for(int i=1;i&lt;=n;i++) &#123; int x; cin&gt;&gt;x; ans+=mp[x];//记录各个值上的相同对数. cout&lt;&lt;mp[x]&lt;&lt;&quot; &quot;; mp[x]++; cout&lt;&lt;ans&lt;&lt;&quot; &quot;;//依次输出 &#125;  &#125;int main()&#123;solve();return 0;&#125;</code></pre><hr><h1 id="小红和小紫的博弈游戏"><a href="#小红和小紫的博弈游戏" class="headerlink" title="小红和小紫的博弈游戏"></a>小红和小紫的博弈游戏</h1><p>链接:<a href="https://ac.nowcoder.com/acm/contest/92662/D">https://ac.nowcoder.com/acm/contest/92662/D</a></p><p>题目大意: 2*2矩阵,两人轮流操作,每次操作时选择两个相邻的正整数,使它们同时减1.谁先无法操作谁就输了.<br>          两人都使用最优策略的情况下,谁将获得最终胜利?</p><p>评价: 3星,重点考查算法的构建,数学,博弈论,对语法的要求并不高.</p><p>思路: 由于是2*2矩阵,根据题意(相邻)反过来找不相邻,假设二维矩阵a[2][2],不相邻为a[0][0],a[1][1]与a[1][0],a[0][1].<br>      将其作为一组,设为(a1,a4),(a2,a3),每一次对一组内的一个数操作,另一组全部减1,所以可分别对二组求和,取其min.<br>      然后min在判断奇偶性.为奇数前者胜,偶数后者.</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long doubleusing namespace std;void func()&#123;int t;cin &gt;&gt; t;int a[2][2] = &#123; 0 &#125;;for (int i = 0; i &lt; t; i++)&#123;    for (int j = 0; j &lt; 2; j++)    &#123;        for (int k = 0; k &lt; 2; k++)        &#123;            cin &gt;&gt; a[j][k];        &#125;    &#125;    int sum1 = a[0][0] + a[1][1];    int sum2 = a[1][0] + a[0][1];    int summin = min(sum1, sum2);    if (summin % 2 == 0)    &#123;        printf(&quot;yukari\n&quot;);    &#125;    else    &#123;        printf(&quot;kou\n&quot;);    &#125;&#125;&#125;int main()&#123; func();return 0;&#125;</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 朝花夕拾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客周赛round64</title>
      <link href="/2024/10/06/%E8%A1%A5%E9%A2%98%E7%B3%BB%E5%88%97/"/>
      <url>/2024/10/06/%E8%A1%A5%E9%A2%98%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> ACM新手村 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[#footer {  background: transparent !important;}#page-header {  background: transparent !important;}#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>����</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<p>continue to update!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>continue to update!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<p>continue to update!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
