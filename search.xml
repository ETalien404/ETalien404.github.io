<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法技巧1(个人总结--持续更新中)</title>
      <link href="/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
      <url>/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>本篇文章总结了一些笔者对算法竞赛中一些常用的数学算法方法,可极大节省时间空间复杂度.<br>持续更新中……</p><hr><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>为了更好引入此概念,牛客上有一道经典的算法题,将它归类到位运算中(本质上就是这个).<br>题目如下:</p><p>链接:<a href="https://ac.nowcoder.com/acm/contest/996/A">https://ac.nowcoder.com/acm/contest/996/A</a><br>来源:牛客网</p><p>题目描述<br>求a的b次方对p取模的值,其中0≤a,b,p≤10^9,p&gt;0</p><p>输入描述:<br>三个用空格隔开的整数a,b和p.<br>输出描述:<br>一个整数表示a^b(mod)p的值.</p><p>看起来简单吧?只需要for循环再取mod就可收工了.但看看范围,很明显直接爆了或者超时.<br>你就算开long long 都没用!</p><p>分析:</p><p>本质上问题的解决还是在于a^b,这太大了,以至于分开求模再次方也无济于事.<br>这时候,有没有一种少一些循环且高效的算法呢?<br>不妨想想计算机是如何存储数据的.<br>不妨设想b为2的n次方.</p><p>就令b&#x3D;64.演示如下:</p><hr><pre><code>a^1*a^1=a^2a^2*a^2=a^4a^4*a^4=a^8a^8*a^8=a^16a^16*a^16=a^32a^32*a^32=a^64</code></pre><hr><p>本质是倍增原理,将a的数量翻倍.<br>那么不为2的情况呢?</p><p>来个b&#x3D;105.那么…</p><hr><pre><code>a^105=a*a^8*a^32*a^64(105)10=(1101001)2(1)10  =(0000001)2(8)10  =(0001000)2(32)10 =(0100000)2(64)10 =(1000000)2//综合起来,看下伪代码:function binexp(a,b)    r=1    while b!=0 //从低到高不断遍历每一位       if n mod 2==1 //如果遍历是1 优化:n&amp;1          r = r*a //乘上各循环所对应的a的倍增数       a =a*a //倍增a       b=[b/2]//优化:b&gt;&gt;1    return r 时间复杂度;O(logn)</code></pre><hr><p>呼,接下来不就简单了吗?</p><hr><pre><code>#define _CRT_SECURE_NO_WARNINGS#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123;long long a, b, p,ans;cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;ans = 1 % p;while (b)&#123;    if ((b &amp; 1) != 0)    &#123;        ans=ans*a%p;    &#125;    a = a * a % p;    b = b &gt;&gt; 1;    &#125;cout &lt;&lt; ans;return 0;&#125;</code></pre><hr><h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><p>嘻嘻,同样类型,思路上是一样的但是细节上还是略有差别.<br>还是举例牛客,看题!</p><p>链接:<a href="https://ac.nowcoder.com/acm/contest/996/C">https://ac.nowcoder.com/acm/contest/996/C</a><br>来源:牛客网</p><p>题目描述<br>求a乘b对p取模的值,其中1≤a,b,p≤10^18<br>输入描述:<br>第一行a,第二行b,第三行p.<br>输出描述:<br>一个整数,表示a×b(mod)p的值.</p><p>有了上一题的基础,理解起来想必容易很多.<br>但算法的细节还是不一样的.<br>这是将后面一个乘数转化为二进制形式计算.</p><p>举个例子吧!</p><hr><pre><code>12*11%512*11=12*(1011)2=12*2^3+12*2^1+12*2^0=96+24+12=132用&amp;与(&gt;&gt;,&lt;&lt;)得出计算转换为:((12%5)+(24%5)+(96%5))%5=(2+4+1)%5=2</code></pre><hr><p>现在就好理解了.</p><hr><pre><code>int ksc(long long a,long long b,long long p)&#123;      long long result=0;      while(b)//与上一题一样,从低到高不断遍历每一位      &#123;            if((b&amp;1)!=0)            &#123;            result=(result+a)%p;//这样理解了为啥是加而不是乘            &#125;      a = (a + a) % p;      b=b&gt;&gt;1;      &#125;   return result;&#125;</code></pre><hr><p>那么,解决问题!</p><hr><pre><code>#define _CRT_SECURE_NO_WARNINGS#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123;long long a, b, p,ans;cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;ans = 0;while (b)&#123;    if ((b &amp; 1) != 0)    &#123;        ans=(ans+a)%p;    &#125;    a = (a + a) % p;    b = b &gt;&gt; 1;    &#125;cout &lt;&lt; ans;return 0;&#125;</code></pre><hr><h2 id="统计问题"><a href="#统计问题" class="headerlink" title="统计问题"></a>统计问题</h2><p>可以说应该算固定题了.但依旧应用到了分治递归的思想.下面通过牛客上的几道题逐步理解这种思想.</p><p>[NOIP2010]数字统计<br>链接:<a href="https://ac.nowcoder.com/acm/contest/19859/A">https://ac.nowcoder.com/acm/contest/19859/A</a><br>来源:牛客网</p><p>题目描述<br>请统计某个给定范围[L,R]的所有整数中,数字2出现的次数.</p><p>比如给定范围[2,22],数字2在数2中出现了1次,在数12中出现1次,在数20中出现1次,在数21中出现1次,在数22中出现2次,所以数字2在该范围内一共出现了6次.</p><p>输入描述:<br>输入共1行,为两个正整数L和R,之间用一个空格隔开.<br>输出描述:<br>输出共1行，表示数字2出现的次数.<br>备注:<br>1≤L≤R≤10000</p><p>分析:<br>初次见到时,相信很可能会这么想:从L–R全部遍历过去,于是就想用一个for循环将搜寻给定数出现的次数.<br>所以可以写出以下代码:</p><hr><pre><code>  #define _CRT_SECURE_NO_WARNINGS  #include &lt;cmath&gt;  #include &lt;map&gt;  #include &lt;iostream&gt;  #include&lt;cstring&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include&lt;ctype.h&gt;  #include&lt;algorithm&gt;  using namespace std;  int ans = 0;//声明全局变量 void solve(int a)//我在这里写了函数,用于判断特定数字出现的个数.&#123;while (a&gt;0)//个人觉得这个循环可以作为模板了.&#123;    if (a % 10 == 2)//如果有得到目标元素就ans++    &#123;        ans++;    &#125;    a = a / 10; 相当于二进制中的&gt;&gt;将十进制的位数向左移动一位    &#125; &#125;int main()&#123;   int L;   int R;cin &gt;&gt; L &gt;&gt; R;for (int i = L; i &lt;= R; i++)//这就是遍历了.&#123;    int k = i;    solve(k);&#125;cout &lt;&lt; ans;return 0;&#125;</code></pre><hr><p>评价:难想到的就是如何将高位数也统计到.本质上还是位运算.</p><h2 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h2><p>计算机挑战赛遇到了,大整数相加,相乘.实际上都属于高精度算法一类的.在之后的比赛中对于范围的控制尤为重要.<br>下面更新大整数的高精度算法.</p><p>1.大整数相加<br>基本逻辑:对于过长的数据,我们采用数组的形式来处理.因此我们建立两个存放加数的数组和一个存放和的数组.对两个加数数组的每一位相加并进位后,便可获得最终得数,输出即可.</p><p>(1)我们引入两组数字:</p><hr><pre><code>char m[500],n[500];scanf(&quot;%s&quot;,&amp;m);scanf(&quot;%s&quot;,&amp;n);</code></pre><hr><p>用char的原因:(1)我们在后面要使用strlen函数去获取字符串长度.<br>             (2)方便输入.<br>(2)将每一位”char”型数字逆序存放进整型数组</p><hr><pre><code>int a[500]=&#123;0&#125;,b[500]=&#123;0&#125;,c[501]=&#123;0&#125;;//a,b数组存放加数,c用于存放和int lena，lenb；lena=strlen(m);//strlen函数是获取数组长度的,如abc的长度为3lenb=strlen(n);for(i=0;i&lt;lena;i++)&#123;    a[lena-1-i]=m[i]-&#39;0&#39;;/*这一步是为了将&#39;char&#39;类型的数组逆序转存为便于计算的‘int’类型逆序转存:更便于我们后面的进位,比如c[k]大于10我们向c[k+1]进位,逻辑上比正序通顺.*/&#125;for(i=0;i&lt;lenb;i++)&#123;    b[lenb-i-1]=n[i]-&#39;0&#39;;&#125;</code></pre><hr><p>(3)计算并处理进位</p><hr><pre><code>int i,j;int la,lb,lmax;//la和lb表示数组长度，lmax是a和b中长度较大的那个数字的长度if(la&gt;lb)&#123;    lmax=la;&#125;else&#123;    lmax=lb;&#125;for(i=0;i&lt;lmax;i++)//i从1循环到lmax&#123;    c[i]+=a[i]+b[i];//先将a的第i位和b的第i位相加，即加数相加    if(c[i]&gt;=10)//当c的某一位大于10，进位    &#123;        c[i+1]+=c[i]/10;//c[i+1]进c[i]的十位        c[i]=c[i]%10;//保留c[i]的个位    &#125;&#125;if(c[lmax]&gt;0)//这一步来判断两个加数相加后最大位数是否发生改变             //比如1和10相加最大位数还是2，但1和99相加最大位数就变为了3&#123;    lmax++;//如果比最大加数位数还大一位的数字不为零，那么最大位数加一&#125;</code></pre><hr><p>(4) 逆序输出和</p><hr><pre><code>for(i=lmax-1;i&gt;=0;i--)&#123;    printf(&quot;%d&quot;,c[i]);&#125;</code></pre><hr><p>完整代码:</p><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;//用的strlen源自于这个头文件main()&#123;char m[500],n[500];int a[500]=&#123;0&#125;,b[500]=&#123;0&#125;,c[501]=&#123;0&#125;;int i,j;int la,lb,lmax;scanf(&quot;%s&quot;,&amp;m);scanf(&quot;%s&quot;,&amp;n);la=strlen(m);lb=strlen(n);if(la&gt;lb)&#123;    lmax=la;&#125;else&#123;    lmax=lb;&#125;for(i=0;i&lt;la;i++)&#123;    a[la-1-i]=m[i]-&#39;0&#39;;&#125;for(i=0;i&lt;lb;i++)&#123;    b[lb-i-1]=n[i]-&#39;0&#39;;&#125;for(i=0;i&lt;lmax;i++)&#123;    c[i]+=a[i]+b[i];    if(c[i]&gt;=10)    &#123;        c[i+1]+=c[i]/10;        c[i]=c[i]%10;    &#125;&#125;if(c[lmax]&gt;0)&#123;    lmax++;&#125;for(i=lmax-1;i&gt;=0;i--)&#123;    printf(&quot;%d&quot;,c[i]);&#125;&#125;</code></pre><hr><p>2.大整数相减</p><p>加法和减法其实并没有什么区别,但相对于加法,减法所涉及到的范围内更大.以下是易踩坑的地方:<br>1.为什么不能直接用int数组接收数据，而是要用字符串输入(对前面补充的细节)</p><p>错误地认为通过int数组输入时,会如同string类型一样,每个位置只有0~9.事实上,当我输入13时,接收到的并不是1,3.而是13.<br>因此必须先由字符串输入,再通过int数组接收.</p><p>2.被减数大于减数的情况和减数大于被减数的情况有什么不同</p><p>当被减数小于减数时应该倒过来:先换位被减数和减数,再正常计算后,前面加上”-“<br>因此必须比较被减数和减数的大小:<br>运用字符串比较大小:(精髓)由于字符串比较时,只会逐位比较,因此 9 &gt; 80???所以必须加上长度限制.</p><p>3.倒置后的消零处理</p><p>比如100000000-100000000时,未消去0则会输出000000000.<br>因此必须消去.</p><p>直接上题目吧!</p><p>题目描述<br>高精度减法。</p><p>输入格式<br>两个整数 a,b（第二个可能比第一个大）。</p><p>输出格式<br>结果（是负数要输出负号）。</p><p>输入输出样例<br>输入 </p><p>2<br>1<br>输出 </p><p>1<br>说明&#x2F;提示<br>20% 数据 a,b 在 long long 范围内;<br>100% 数据 0&lt;a,b≤10^10086.</p><p>代码如下:</p><hr><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//高精度减法string A, B;int a[1000000], b[1000000], c[10000000];void swap(char *a, char *b) &#123;int temp = 0;temp = *a;*a = *b;*b = temp;&#125;int main() &#123;int i = 0, j = 0;cin &gt;&gt; A &gt;&gt; B;//首先要得到a，b的字符串长度int len_a = 0, len_b = 0, len_max, temp = 0;for (i = 0; A[i] != &#39;\0&#39;; i++)    len_a++;for (j = 0; B[j] != &#39;\0&#39;; j++)    len_b++;//赋值int数组/*然后将a，b的字符串分别进行倒序，方便向后一位借1：例如：输入时是550和350，高位在前，倒序后为055和053，高位在后*/for (i = 0; i &lt; len_a; i++)    a[len_a - i - 1] = A[i] - &#39;0&#39;;for (j = 0; j &lt; len_b; j++)    b[len_b - j - 1] = B[j] - &#39;0&#39;;//进行高精度减法：1.先得到长的数字长度len_max = len_a &gt; len_b ? len_a : len_b;//调试/*for (i = 0; i &lt; len_max; i++)    cout &lt;&lt; &quot;a=&quot; &lt;&lt; *(a + i) &lt;&lt; endl;for (j = 0; j &lt; len_max; j++)    cout &lt;&lt; &quot;b=&quot; &lt;&lt; *(b + j) &lt;&lt; endl;*///计算:先判断被减数和减数哪个大,减数大则要换位if (A &lt; B &amp;&amp; len_a == len_b || len_a &lt; len_b) &#123; //通过字符串比较大小，可以得知两个数字的大小    for (i = 0; i &lt; len_max; i++) &#123;        c[i] = b[i] - a[i] + temp;//temp为借位操作，当上一位小于0时        if (c[i] &lt; 0) &#123;            temp = -1;            c[i] += 10;        &#125; else &#123;            temp = 0;        &#125;    &#125;    //temp一定等于-1    cout &lt;&lt; &quot;-&quot;;    //还需要进行消零操作：有时需要的是1，而不是000001    for (i = len_max - 1; i &gt;= 0 ; i--) &#123;        if (c[i] == 0 &amp;&amp; i &gt; 0)/*当最后一位为零时不可删除，其余前面的零删除，        但是比如200-300=-100，其中后面的零不可以删除，所以选择缩短数列长度，        如此只可能删除有效数字前面的零*/            len_max--;        else            break;    &#125;    for (i = len_max - 1; i &gt;= 0; i--)        cout &lt;&lt; c[i];&#125; else &#123;    for (i = 0; i &lt; len_max; i++) &#123;        c[i] = a[i] - b[i] + temp;//temp为借位操作，当上一位小于0时        if (c[i] &lt; 0) &#123;            temp = -1;            c[i] += 10;        &#125; else &#123;            temp = 0;        &#125;    &#125;    //temp一定等于0    for (i = len_max - 1; i &gt;= 0 ; i--) &#123;        if (c[i] == 0 &amp;&amp; i &gt; 0)//同样进行消零操作            len_max--;        else            break;    &#125;    for (i = len_max - 1; i &gt;= 0 ; i--) &#123;        cout &lt;&lt; c[i];    &#125;    return 0;&#125;&#125;  </code></pre><hr><p>3.大整数乘法</p><hr><pre><code>(1)我们引入两组数字:char m[2000],n[2000];scanf(&quot;%s&quot;,&amp;m);scanf(&quot;%s&quot;,&amp;n);</code></pre><hr><hr><pre><code>(2)将每一位&quot;char&quot;型数字逆序存放进整型数组int a[2000]=&#123;0&#125;,b[2000]=&#123;0&#125;;int lm,ln;//lm、ln分别表示m和n的位数lm=strlen(m);//strlen函数是获取数组长度的,如abc的长度为3ln=strlen(n);for(i=0;i&lt;lm;i++)&#123;a[lm-i-1]=m[i]-&#39;0&#39;;/*这一步是为了将&#39;char&#39;类型的数组逆序转存为便于计算的&#39;int&#39;类型逆序转存：更便于我们后面的进位,比如c[k]大于10我们向c[k+1]进位,逻辑上比正序通顺.*/&#125;for(i=0;i&lt;ln;i++)&#123;b[ln-i-1]=n[i]-&#39;0&#39;;&#125;</code></pre><hr><hr><pre><code>(3)计算并处理进位乘法结果位数的三种情况:位数等于两乘数位数之和(如9*9=81).位数等于两位数的和减1(如1*9=9.结果为0(100*0=0).int i,j,k;for(i=0;i&lt;lm;i++)&#123;    for(j=0;j&lt;ln;j++)    &#123;        k=i+j;        c[k]+=a[i]*b[j];        if(c[k]&gt;=10)//保证数组中的数字都&lt;10        &#123;            c[k+1]+=c[k]/10;//c[i+1]进c[i]的十位            c[k]%=10;//保留c[i]的个位        &#125;    &#125;&#125;</code></pre><hr><p>(5)逆序输出积</p><hr><pre><code>for(i=lc-1;i&gt;=0;i--)&#123;    printf(&quot;%d&quot;,c[i]);&#125;</code></pre><hr><p>(6)完整代码:</p><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;main()&#123;char m[2000],n[2000];int a[2000]=&#123;0&#125;,b[2000]=&#123;0&#125;,c[4000]=&#123;0&#125;;int i,j,k;int lm,ln,lc;scanf(&quot;%s&quot;,&amp;m);scanf(&quot;%s&quot;,&amp;n);lm=strlen(m);ln=strlen(n);for(i=0;i&lt;lm;i++)&#123;    a[lm-i-1]=m[i]-&#39;0&#39;;&#125;for(i=0;i&lt;ln;i++)&#123;    b[ln-i-1]=n[i]-&#39;0&#39;;&#125;for(i=0;i&lt;lm;i++)&#123;    for(j=0;j&lt;ln;j++)    &#123;        k=i+j;        c[k]+=a[i]*b[j];        if(c[k]&gt;=10)        &#123;            c[k+1]+=c[k]/10;            c[k]%=10;        &#125;    &#125;&#125;if(c[lm+ln-1]!=0)&#123;    lc=lm+ln;&#125;else&#123;    lc=lm+ln-1;&#125;while(c[lc-1]==0&amp;&amp;lc&gt;1)&#123;    lc--;&#125;for(i=lc-1;i&gt;=0;i--)&#123;    printf(&quot;%d&quot;,c[i]);&#125;&#125;</code></pre><hr><p>4.大整数相除</p><p>核心逻辑——逐位试商法：</p><p>总结:从第一位开始试商,除不下就乘10,除得下相处后余数乘10在加上后一位,逐位顺过去,直到最后一位.</p><p>(1)我们引入两组数字:</p><hr><pre><code>char m[5000];long long n,rem=0;scanf(&quot;%s&quot;,m);//除数scanf(&quot;%lld&quot;,&amp;n);//低精度的被除数V</code></pre><hr><p>(2)将字符数组m转为整形(这里不用逆序,原因是除法不用处理进位)</p><hr><pre><code>int lm;//数组m的长度lm=strlen(m);for(i=0;i&lt;lm;i++)&#123;a[i]=m[i]-&#39;0&#39;;&#125;</code></pre><hr><p>(3)逐位试商</p><hr><pre><code>for(i=0;i&lt;lm;i++)//lm是被除数长度，从第一位试到最后一位&#123;    c[i]=(rem*10+a[i])/n;//rem为余数    rem=(rem*10+a[i])%n;//不理解的看上面核心思想部分&#125;</code></pre><hr><p>(4)删除前导0</p><p>和之前的都不一样了,因为之前是逆序的,删除最后一位即可.这个是顺序,代码如下:</p><hr><pre><code>while(c[0]==0)//当第一位为0时&#123;for(i=0;i&lt;lm;i++)//将每一位数字前移，第一位数字数据丢失&#123;    c[i]=c[i+1];&#125;lm--;//第一位删掉了，因此长度也-1if(lm&lt;=0)//如果总长度小于等于0，直接输出0&#123;    printf(&quot;0&quot;);    break;&#125;&#125;</code></pre><hr><p>(5)顺序输出</p><hr><pre><code>for(int i=0;i&lt;lm;i++)&#123;    printf(&quot;%d&quot;,c[i]);&#125;</code></pre><hr><p>(6)完整代码:</p><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;main()&#123;char m[5000];long long n,rem=0;int a[5000],c[5000];int lm,i;scanf(&quot;%s&quot;,m);scanf(&quot;%lld&quot;,&amp;n);lm=strlen(m);for(i=0;i&lt;lm;i++)&#123;    a[i]=m[i]-&#39;0&#39;;&#125;for(i=0;i&lt;lm;i++)&#123;    c[i]=(rem*10+a[i])/n;    rem=(rem*10+a[i])%n;&#125;while(c[0]==0)&#123;    for(i=0;i&lt;lm;i++)    &#123;        c[i]=c[i+1];    &#125;    lm--;    if(lm&lt;=0)    &#123;        printf(&quot;0&quot;);        break;    &#125;&#125;for(int i=0;i&lt;lm;i++)&#123;    printf(&quot;%d&quot;,c[i]);&#125;&#125;</code></pre><hr><p>5.高精度阶乘</p><p>与乘法类似:</p><hr><pre><code>#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;#define h 250000char print[h] = &#123; &#39;1&#39; &#125;;int num1[h] = &#123; 0 &#125;, num2[h] = &#123; 0 &#125;;void fact(int n)&#123;int ans[h] = &#123; 0 &#125;;int len1 = 0, sumlen,k = 0;len1 = strlen(print);//反转写入数组for (int i = len1 - 1; i &gt;= 0; i--)num1[k++] = (print[i] - &#39;0&#39;);k = 0;//将因数拆分反向装入数组while (n)&#123;    num2[k++] = n % 10;    n /= 10;&#125;//模拟乘法竖式for (int i = 0; i &lt; len1; i++)&#123;    for (int j = 0; j &lt; k; j++)    &#123;        ans[j + i] += num1[i] * num2[j];    &#125;&#125;sumlen = len1 + k;k = 0;//进位for (int i = 0; i &lt; sumlen; i++)&#123;    if (ans[i] &gt;= 10)    &#123;        ans[i + 1] += ans[i] / 10;        ans[i] = ans[i] % 10;    &#125;&#125;//反转写入字符串while (!ans[sumlen])sumlen--;for (int i = sumlen; i &gt;= 0; i--)print[k++] = ans[i] + &#39;0&#39;; &#125; int main()&#123;int n;cin &gt;&gt; n;for (int i = 1; i &lt;= n; i++)&#123;    fact(i);&#125;cout &lt;&lt; print;&#125;</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 算法技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光合远见实验室比赛回顾</title>
      <link href="/2024/10/15/%E5%85%89%E5%90%88%E8%BF%9C%E8%A7%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%AF%94%E8%B5%9B%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/10/15/%E5%85%89%E5%90%88%E8%BF%9C%E8%A7%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%AF%94%E8%B5%9B%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>笔者侥幸通过了测试,趁着还未过去许久,回顾与反思程序设计的不足及改进措施.</p><hr><h2 id="B2114-配对碱基链"><a href="#B2114-配对碱基链" class="headerlink" title="B2114. 配对碱基链"></a>B2114. 配对碱基链</h2><p>题目描述<br>脱氧核糖核酸(DNA)由两条互补的碱基链以双螺旋的方式结合而成.<br>而构成 DNA 的碱基共有4种:</p><p>分别为<br>腺嘌呤(A)<br>鸟嘌呤(G)<br>胸腺嘧啶(T)<br>胞嘧啶(C)<br>我们知道,在两条互补碱基链的对应位置上,腺嘌呤总是和胸腺嘧啶配对,鸟嘌呤总是和胞嘧啶配对.<br>你的任务就是根据一条单链上的碱基序列,给出对应的互补链上的碱基序列.</p><p>输入格式<br>一个字符串,表示一条碱基链.</p><p>这个字符串只含有大写字母<br>A,T,G,C分别表示腺嘌呤,胸腺嘧啶,鸟嘌呤和胞嘧啶.</p><p>字符串长度不超过255.</p><p>输出格式<br>一个只含有大写字母 A,T,G,C 的字符串，为与输入的碱基链互补的碱基链。</p><p>输入数据 1<br>ATATGGATGGTGTTTGGCTCTG</p><p>输出数据 1<br>TATACCTACCACAAACCGAGAC</p><hr><p>个人评价:要点(字符串,数组,循环,条件判断)<br>在考场中本人就犯以下问题:<br>(1)字符数组写好,但一直读入导致输入数据读完还接着读.(for循环一直读入的原因)<br>(2)”&#x3D;&#x3D;”与”&#x3D;”的错误应用.(“&#x3D;&#x3D;”才是等于,”&#x3D;”是赋值（右赋值左）)<br>(3)重复输出.</p><p>正确代码如下:</p><pre><code> #define _CRT_SECURE_NO_WARNINGS #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; using namespace std; int main()&#123;char line[255];scanf(&quot;%s&quot;, line);for (int i = 0; i &lt; 255; i++)&#123;    if (line[i] == &#39;A&#39;)    &#123;        cout &lt;&lt; &#39;T&#39;;    &#125;    else if (line[i] == &#39;T&#39;)    &#123;        cout &lt;&lt; &#39;A&#39;;    &#125;    else if (line[i] == &#39;G&#39;)    &#123;        cout &lt;&lt; &#39;C&#39;;    &#125;    else if (line[i] == &#39;C&#39;)    &#123;        cout &lt;&lt; &#39;G&#39;;    &#125;&#125;return 0;&#125;</code></pre><hr><h2 id="B-矩阵乘法"><a href="#B-矩阵乘法" class="headerlink" title="B. 矩阵乘法"></a>B. 矩阵乘法</h2><p>题目描述:</p><p>n×m 阶的矩阵A乘以m*k 阶的矩阵B得到的矩阵C是n×k阶的,且<br>C[i][j]&#x3D;A[i][0]×B[0][j]+A[i][1]×B[1][j]+……+A[i][m−1]×B[m−1][j]<br>(C[i][j] 表示C矩阵中第i行第j列元素).</p><p>输入格式:<br>第一行为 n,m,k,表示A矩阵是n行m列,B矩阵是m行k列,n,m,k均小于100.</p><p>然后先后输入A和B两个矩阵,A矩阵n行m列,B矩阵 m行k列,矩阵中每个元素的绝对值不会大于1000.</p><p>输出格式</p><p>输出矩阵C,一共 n 行,每行 k 个整数,整数之间以一个空格分开.</p><p>输入数据 1<br>3 2 3<br>1 1<br>1 1<br>1 1<br>1 1 1<br>1 1 1<br>输出数据 1<br>2 2 2<br>2 2 2<br>2 2 2</p><hr><p>个人评价:<br>这是线代!这一定是线代吧!!!不过抛开background不谈,还是要注意范围,线代学到矩阵会特别好懂此题.<br>本质是数学.二维数组+三重for循环表达+格式化输出即可.</p><p>正确代码如下:</p><pre><code>   #define _CRT_SECURE_NO_WARNINGS   #include &lt;cmath&gt;   #include &lt;map&gt;   #include &lt;iostream&gt;   #include&lt;cstring&gt;   #include &lt;stdio.h&gt;   #include &lt;stdlib.h&gt;   using namespace std;    int main ()&#123;int n;int m;int k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;int A[110][110];int B[110][110];int C[110][110];for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; m; ++j)    &#123;        cin &gt;&gt; A[i][j];    &#125;&#125;for (int i = 0; i &lt; m; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        cin &gt;&gt; B[i][j];    &#125;&#125;for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        C[i][j] = 0;        for (int a = 0; a &lt; m; ++a)        &#123;            C[i][j] += A[i][a] * B[a][j]//悲啊!&quot;+&quot;忘了写&quot;+=&quot;表示累加,单纯的&quot;=&quot;会覆盖前一次计算!!!;        &#125;    &#125;&#125;for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        cout &lt;&lt; C[i][j]&lt;&lt;&quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;return 0;&#125;</code></pre><hr><h2 id="D-斐波那契数列"><a href="#D-斐波那契数列" class="headerlink" title="D. 斐波那契数列"></a>D. 斐波那契数列</h2><p>题目描述</p><p>斐波那契数列是指这样的数列:数列的第一个和第二个数都为1,接下来每个数都等于前面2 个数之和.<br>给出一个正整数a,要求斐波那契数列中第 a 个数是多少。</p><p>输入格式</p><p>第 1 行是测试数据的组数n,后面跟着 n 行输入。每组测试数据占 1 行，包括一个正整数a（1≤a≤30).</p><p>输出格式</p><p>输出有 n 行，每行输出对应一个输入.输出应是一个正整数,为斐波那契数列中第 a 个数的大小。</p><p>输入数据<br>1<br>4<br>5<br>2<br>19<br>1<br>输出数据<br>1<br>5<br>1<br>4181<br>1</p><hr><p>个人评价:<br>(函数+递归(只能说出题者没有故意刁难我们出一个超过int类型的数,不然还要%))</p><p>代码如下:</p><pre><code>    #define _CRT_SECURE_NO_WARNINGS    #include &lt;cmath&gt;    #include &lt;map&gt;    #include &lt;iostream&gt;    #include&lt;cstring&gt;    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    using namespace std;    int pell(int n)&#123; if (n == 1)&#123;    return 1;&#125;else if (n == 2)&#123;    return 1;&#125;else&#123;    int a1 = 1, a2 = 1, a3;    for (int i = 0; i &lt; n - 2; i++)    &#123;        a3 = a1+a2;        a1 = a2;        a2 = a3;    &#125;    return a2;&#125;&#125;int main()&#123;int n;int b;cin &gt;&gt; n;for (int i = 0; i &lt; n; i++)&#123;    cin &gt;&gt; b;    cout &lt;&lt; pell(b) &lt;&lt; endl;&#125;return 0;  &#125;</code></pre><hr><h2 id="C-车厢重组"><a href="#C-车厢重组" class="headerlink" title="C.车厢重组"></a>C.车厢重组</h2><p>题目描述:<br>在一个旧式的火车站旁边有一座桥,其桥面可以绕河中心的桥墩水平旋转.<br>一个车站的职工发现桥的长度最多能容纳两节车厢,如果将桥旋转 180 度,则可以把相邻两节车厢的位置交换,用这种方法可以重新排列车厢的顺序.<br>于是他就负责用这座桥将进站的车厢按车厢号从小到大排列.他退休后,火车站决定将这一工作自动化,其中一项重要的工作是编一个程序,输入初始<br>的车厢顺序,计算最少用多少步就能将车厢排序.</p><p>输入格式<br>共两行.</p><p>第一行是车厢总数N(≤10000).</p><p>第二行是N个不同的数表示初始的车厢顺序.<br>(注:实际上数据中并不都在同一行,有可能分行输入)</p><p>输出格式<br>一个整数,最少的旋转次数.</p><p>输入数据 1<br>4<br>4 3 2 1<br>输出数据 1<br>6</p><p>个人反思:开始区分,冒泡排序用的不熟练,会用的写的很快.重新做一遍仍有问题.(具体在代码区)</p><hr><p>代码如下:</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include &lt;stdio.h&gt;           #include &lt;stdlib.h&gt;      #include&lt;stdbool.h&gt;using namespace std;       int b = 0;void BubbleSort(int a[], int size)&#123;for (int i = size - 1; i &gt; 0; --i)&#123;    for (int j = 0; j &lt; i; ++ j)    &#123;        if (a[j] &gt; a[j + 1])        &#123;            int tmp = a[j];            a[j] = a[j + 1];            a[j + 1] = tmp;            b++;  //就是这里统计次数,放在if里面在每次交换时统计次数.        &#125;    &#125;  &#125;&#125; int main()&#123;int N;cin &gt;&gt; N;int a[10001];for (int i = 0; i &lt; N; i++)&#123;    cin &gt;&gt; a[i];&#125;BubbleSort(a, N);cout &lt;&lt; b;return 0;  &#125;</code></pre><hr><h2 id="E-枚举排列"><a href="#E-枚举排列" class="headerlink" title="E. 枚举排列"></a>E. 枚举排列</h2><hr><p>题目描述<br>今有n名学生,要从中选出 k 人排成一列拍照.<br>请按字典序输出所有可能的排列方式.</p><p>输入格式<br>仅一行,两个正整数 n,k.</p><p>输出格式<br>若干行,每行 k 个正整数,表示一种可能的队伍顺序.</p><p>输入数据 1<br>3 2<br>输出数据 1<br>1 2<br>1 3<br>2 1<br>2 3<br>3 1<br>3 2<br>提示<br>对于100% 的数据,1≤k≤n≤10.</p><p>个人反思:深搜…还结合字典序…萌新杀手…<br>具体可看:<a href="https://blog.csdn.net/qq_37050329/article/details/86637183?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223D39BCCB-0B0C-4447-8EFD-CE4040FF37C4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=3D39BCCB-0B0C-4447-8EFD-CE4040FF37C4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86637183-null-">https://blog.csdn.net/qq_37050329/article/details/86637183?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223D39BCCB-0B0C-4447-8EFD-CE4040FF37C4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=3D39BCCB-0B0C-4447-8EFD-CE4040FF37C4&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86637183-null-</a><br>         null.142^v100^pc_search_result_base3&amp;utm_term&#x3D;%E5%AD%97%E5%85%B8%E5%BA%8F&amp;spm&#x3D;1018.2226.3001.4187<br>代码如下:</p><pre><code>  #define _CRT_SECURE_NO_WARNINGS  #include &lt;cmath&gt;  #include &lt;map&gt;  #include&lt;string.h&gt;  #include &lt;iostream&gt;  #include&lt;cstring&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include&lt;stdbool.h&gt;using namespace std;#define MAX_N 10bool used [MAX_N + 1];int path [MAX_N + 1];int n, k;void backtrack(int depth)&#123;if (depth == k)&#123;    for (int i = 0; i &lt; k; i++)    &#123;        printf(&quot;%d &quot;, path[i]);    &#125;printf(&quot;\n&quot;);return;&#125;for (int i = 1; i &lt;= n; i++)&#123;    if (!used[i])    &#123;        used[i] = true;        path[depth] = i;        backtrack(depth + 1);        used[i] = false;    &#125;   &#125; &#125;int main()&#123;scanf(&quot;%d %d&quot;, &amp;n ,&amp;k);memset(used, false, sizeof(used));backtrack(0);return 0;&#125;</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 朝花夕拾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇虚拟机文章</title>
      <link href="/2024/10/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>笔者虚拟机搭建比较简单，是从360管家下的VMware，所以不过多阐述。<br>建议去清华镜像站下载比较方便.</p>]]></content>
      
      
      <categories>
          
          <category> 新手村 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇BLOG搭建文章</title>
      <link href="/2024/10/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG%E6%90%AD%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG%E6%90%AD%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>笔者在这里使用的是hexo+github的个人博客搭建,如有错误请各位大佬指正。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>1.到 <a href="https://nodejs.cn/">https://nodejs.cn/</a> 下载Node.js下载常用版就行。为hexo运行搭建环境。<br>2.（1）github注册。如果English水平不高建议配上网易有道翻译。按web流程进行github注册。<br>  （2）创建代码库，勾选Public，在Repository name中按”用户名.github.io”(一定是这格式！)创建。<br>   (3) 可以自己在code&lt;&gt;选项上进行测试.<br>3. git for windows安装<br>   (1)输入<a href="https://gitforwindows.org/%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E3%80%82">https://gitforwindows.org/进入官网点击下载。</a><br>   (2)git安装默认C盘，可以根据需要自行更改。<br>   (3)勾选 don’t create a start menu folder<br>   (4)注意！！！！！github把master改名main了,配置congif要更改!!也就是branch:master改成branch:main!!<br>   (5)后面默认就行。<br>4.githubShh配置<br>   (1)以管理员身份打开git.bash.exe.<br>   (2)输入命令 ssh-keygen -t rsa -C “github邮箱注册地址”(如果找不到到C盘搜.shh前提是环境安装好)然后回车。<br>   (3)打开github-settings-deploy keys title写用户名，key找到”id rua.pub”复制粘贴。</p><h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>   (1)打开<a href="https://hexo.io/zh-cn/dots/">https://hexo.io/zh-cn/dots/</a><br>   (2)新建文件夹（命名自取）<br>   (3)在此文件夹下用管理员身份打开git.bash.exe.输入npm install hexo-cli -g<br>   (4)安装完用hexo -v验证。（确保路径正确）<br>   (5)在对应路径下输入hexo init初始化.<br>   (6)可以hexo s启动blog.<br>   当然这还未完成，还要挂到github上。<br>   (7)Ctrl+c先关掉。<br>   (8)好了，现在我们还需要装一个git部署插件,输入 snpm install –save hexo-deployer-git回车。<br>   (9)找到_config.yml用记事本打开，划到最底部，找到Depolyment,按如下格式配置。</p><pre><code> type: git repository: 自己的地址 branch:main(注意缩进与空格）</code></pre><p>   (10) hexo d部署(弹出方框输入账号）<br>   (11)成功！！！</p><h2 id="问题反思与感想"><a href="#问题反思与感想" class="headerlink" title="问题反思与感想"></a>问题反思与感想</h2><p>(1)短短几十行，但真正实践起来却要数十倍的时间，实践中，初步了解了0-1的艰难，各种问题层出不穷。<br>eg:路径不对—cd C:\  等去切换。<br>   获取管理员权限。<br>   上面的yml文件未配置好（细节在上）<br>   等。。<br>(2)总之，笔者在此受益颇多,感谢互联网的知识，优秀的作者，让我们前方的路清晰明朗。谢谢！！！</p>]]></content>
      
      
      <categories>
          
          <category> 新手村 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇BLOG搭建文章</title>
      <link href="/2024/10/06/%E8%A1%A5%E9%A2%98%E7%B3%BB%E5%88%97/"/>
      <url>/2024/10/06/%E8%A1%A5%E9%A2%98%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>笔者在这里使用的是hexo+github的个人博客搭建,如有错误请各位大佬指正。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>1.到 <a href="https://nodejs.cn/">https://nodejs.cn/</a> 下载Node.js下载常用版就行。为hexo运行搭建环境。<br>2.（1）github注册。如果English水平不高建议配上网易有道翻译。按web流程进行github注册。<br>  （2）创建代码库，勾选Public，在Repository name中按”用户名.github.io”(一定是这格式！)创建。<br>   (3) 可以自己在code&lt;&gt;选项上进行测试.<br>3. git for windows安装<br>   (1)输入<a href="https://gitforwindows.org/%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E3%80%82">https://gitforwindows.org/进入官网点击下载。</a><br>   (2)git安装默认C盘，可以根据需要自行更改。<br>   (3)勾选 don’t create a start menu folder<br>   (4)注意！！！！！github把master改名main了,配置congif要更改!!也就是branch:master改成branch:main!!<br>   (5)后面默认就行。<br>4.githubShh配置<br>   (1)以管理员身份打开git.bash.exe.<br>   (2)输入命令 ssh-keygen -t rsa -C “github邮箱注册地址”(如果找不到到C盘搜.shh前提是环境安装好)然后回车。<br>   (3)打开github-settings-deploy keys title写用户名，key找到”id rua.pub”复制粘贴。</p><h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>   (1)打开<a href="https://hexo.io/zh-cn/dots/">https://hexo.io/zh-cn/dots/</a><br>   (2)新建文件夹（命名自取）<br>   (3)在此文件夹下用管理员身份打开git.bash.exe.输入npm install hexo-cli -g<br>   (4)安装完用hexo -v验证。（确保路径正确）<br>   (5)在对应路径下输入hexo init初始化.<br>   (6)可以hexo s启动blog.<br>   当然这还未完成，还要挂到github上。<br>   (7)Ctrl+c先关掉。<br>   (8)好了，现在我们还需要装一个git部署插件,输入 snpm install –save hexo-deployer-git回车。<br>   (9)找到_config.yml用记事本打开，划到最底部，找到Depolyment,按如下格式配置。</p><pre><code> type: git repository: 自己的地址 branch:main(注意缩进与空格）</code></pre><p>   (10) hexo d部署(弹出方框输入账号）<br>   (11)成功！！！</p><h2 id="问题反思与感想"><a href="#问题反思与感想" class="headerlink" title="问题反思与感想"></a>问题反思与感想</h2><p>(1)短短几十行，但真正实践起来却要数十倍的时间，实践中，初步了解了0-1的艰难，各种问题层出不穷。<br>eg:路径不对—cd C:\  等去切换。<br>   获取管理员权限。<br>   上面的yml文件未配置好（细节在上）<br>   等。。<br>(2)总之，笔者在此受益颇多,感谢互联网的知识，优秀的作者，让我们前方的路清晰明朗。谢谢！！！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[#footer {  background: transparent !important;}#page-header {  background: transparent !important;}#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>continue to update!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<p>continue to update!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<p>continue to update!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>����</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
