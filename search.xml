<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法技巧1(个人总结--持续更新中)</title>
      <link href="/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
      <url>/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>本篇文章总结了一些笔者对算法竞赛中一些常用的数学算法方法,可极大节省时间空间复杂度.<br>持续更新中……</p><hr><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>为了更好引入此概念,牛客上有一道经典的算法题,将它归类到位运算中(本质上就是这个).<br>题目如下:</p><p>链接:<a href="https://ac.nowcoder.com/acm/contest/996/A">https://ac.nowcoder.com/acm/contest/996/A</a><br>来源:牛客网</p><p>题目描述<br>求a的b次方对p取模的值,其中0≤a,b,p≤10^9,p&gt;0</p><p>输入描述:<br>三个用空格隔开的整数a,b和p.<br>输出描述:<br>一个整数表示a^b(mod)p的值.</p><p>看起来简单吧?只需要for循环再取mod就可收工了.但看看范围,很明显直接爆了或者超时.<br>你就算开long long 都没用!</p><p>分析:</p><p>本质上问题的解决还是在于a^b,这太大了,以至于分开求模再次方也无济于事.<br>这时候,有没有一种少一些循环且高效的算法呢?<br>不妨想想计算机是如何存储数据的.<br>不妨设想b为2的n次方.</p><p>就令b&#x3D;64.演示如下:</p><hr><pre><code>a^1*a^1=a^2a^2*a^2=a^4a^4*a^4=a^8a^8*a^8=a^16a^16*a^16=a^32a^32*a^32=a^64</code></pre><hr><p>本质是倍增原理,将a的数量翻倍.<br>那么不为2的情况呢?</p><p>来个b&#x3D;105.那么…</p><hr><pre><code>a^105=a*a^8*a^32*a^64(105)10=(1101001)2(1)10  =(0000001)2(8)10  =(0001000)2(32)10 =(0100000)2(64)10 =(1000000)2//综合起来,看下伪代码:function binexp(a,b)    r=1    while b!=0 //从低到高不断遍历每一位       if n mod 2==1 //如果遍历是1 优化:n&amp;1          r = r*a //乘上各循环所对应的a的倍增数       a =a*a //倍增a       b=[b/2]//优化:b&gt;&gt;1    return r 时间复杂度;O(logn)</code></pre><hr><p>呼,接下来不就简单了吗?</p><hr><pre><code>#define _CRT_SECURE_NO_WARNINGS#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123;long long a, b, p,ans;cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;ans = 1 % p;while (b)&#123;    if ((b &amp; 1) != 0)    &#123;        ans=ans*a%p;    &#125;    a = a * a % p;    b = b &gt;&gt; 1;    &#125;cout &lt;&lt; ans;return 0;&#125;</code></pre><hr><h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><p>嘻嘻,同样类型,思路上是一样的但是细节上还是略有差别.<br>还是举例牛客,看题!</p><p>链接:<a href="https://ac.nowcoder.com/acm/contest/996/C">https://ac.nowcoder.com/acm/contest/996/C</a><br>来源:牛客网</p><p>题目描述<br>求a乘b对p取模的值,其中1≤a,b,p≤10^18<br>输入描述:<br>第一行a,第二行b,第三行p.<br>输出描述:<br>一个整数,表示a×b(mod)p的值.</p><p>有了上一题的基础,理解起来想必容易很多.<br>但算法的细节还是不一样的.<br>这是将后面一个乘数转化为二进制形式计算.</p><p>举个例子吧!</p><hr><pre><code>12*11%512*11=12*(1011)2=12*2^3+12*2^1+12*2^0=96+24+12=132用&amp;与(&gt;&gt;,&lt;&lt;)得出计算转换为:((12%5)+(24%5)+(96%5))%5=(2+4+1)%5=2</code></pre><hr><p>现在就好理解了.</p><hr><pre><code>int ksc(long long a,long long b,long long p)&#123;      long long result=0;      while(b)//与上一题一样,从低到高不断遍历每一位      &#123;            if((b&amp;1)!=0)            &#123;            result=(result+a)%p;//这样理解了为啥是加而不是乘            &#125;      b=b&gt;&gt;1;      &#125;   return result;&#125;</code></pre><hr><p>那么,解决问题!</p><hr><pre><code>#define _CRT_SECURE_NO_WARNINGS#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;ctype.h&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123;long long a, b, p,ans;cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;ans = 1 % p;while (b)&#123;    if ((b &amp; 1) != 0)    &#123;        ans=ans*a%p;    &#125;    a = a * a % p;    b = b &gt;&gt; 1;    &#125;cout &lt;&lt; ans;return 0;&#125;</code></pre><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>光合远见实验室比赛回顾</title>
      <link href="/2024/10/15/%E5%85%89%E5%90%88%E8%BF%9C%E8%A7%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%AF%94%E8%B5%9B%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/10/15/%E5%85%89%E5%90%88%E8%BF%9C%E8%A7%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%AF%94%E8%B5%9B%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>笔者侥幸通过了测试,趁着还未过去许久,回顾与反思程序设计的不足及改进措施.</p><hr><h2 id="B2114-配对碱基链"><a href="#B2114-配对碱基链" class="headerlink" title="B2114. 配对碱基链"></a>B2114. 配对碱基链</h2><p>题目描述<br>脱氧核糖核酸(DNA)由两条互补的碱基链以双螺旋的方式结合而成.<br>而构成 DNA 的碱基共有4种:</p><p>分别为<br>腺嘌呤(A)<br>鸟嘌呤(G)<br>胸腺嘧啶(T)<br>胞嘧啶(C)<br>我们知道,在两条互补碱基链的对应位置上,腺嘌呤总是和胸腺嘧啶配对,鸟嘌呤总是和胞嘧啶配对.<br>你的任务就是根据一条单链上的碱基序列,给出对应的互补链上的碱基序列.</p><p>输入格式<br>一个字符串,表示一条碱基链.</p><p>这个字符串只含有大写字母<br>A,T,G,C分别表示腺嘌呤,胸腺嘧啶,鸟嘌呤和胞嘧啶.</p><p>字符串长度不超过255.</p><p>输出格式<br>一个只含有大写字母 A,T,G,C 的字符串，为与输入的碱基链互补的碱基链。</p><p>输入数据 1<br>ATATGGATGGTGTTTGGCTCTG</p><p>输出数据 1<br>TATACCTACCACAAACCGAGAC</p><hr><p>个人评价:要点(字符串,数组,循环,条件判断)<br>在考场中本人就犯以下问题:<br>(1)字符数组写好,但一直读入导致输入数据读完还接着读.(for循环一直读入的原因)<br>(2)”&#x3D;&#x3D;”与”&#x3D;”的错误应用.(“&#x3D;&#x3D;”才是等于,”&#x3D;”是赋值（右赋值左）)<br>(3)重复输出.</p><p>正确代码如下:</p><pre><code> #define _CRT_SECURE_NO_WARNINGS #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; using namespace std; int main()&#123;char line[255];scanf(&quot;%s&quot;, line);for (int i = 0; i &lt; 255; i++)&#123;    if (line[i] == &#39;A&#39;)    &#123;        cout &lt;&lt; &#39;T&#39;;    &#125;    else if (line[i] == &#39;T&#39;)    &#123;        cout &lt;&lt; &#39;A&#39;;    &#125;    else if (line[i] == &#39;G&#39;)    &#123;        cout &lt;&lt; &#39;C&#39;;    &#125;    else if (line[i] == &#39;C&#39;)    &#123;        cout &lt;&lt; &#39;G&#39;;    &#125;&#125;return 0;&#125;</code></pre><hr><h2 id="B-矩阵乘法"><a href="#B-矩阵乘法" class="headerlink" title="B. 矩阵乘法"></a>B. 矩阵乘法</h2><p>题目描述:</p><p>n×m 阶的矩阵A乘以m*k 阶的矩阵B得到的矩阵C是n×k阶的,且<br>C[i][j]&#x3D;A[i][0]×B[0][j]+A[i][1]×B[1][j]+……+A[i][m−1]×B[m−1][j]<br>(C[i][j] 表示C矩阵中第i行第j列元素).</p><p>输入格式:<br>第一行为 n,m,k,表示A矩阵是n行m列,B矩阵是m行k列,n,m,k均小于100.</p><p>然后先后输入A和B两个矩阵,A矩阵n行m列,B矩阵 m行k列,矩阵中每个元素的绝对值不会大于1000.</p><p>输出格式</p><p>输出矩阵C,一共 n 行,每行 k 个整数,整数之间以一个空格分开.</p><p>输入数据 1<br>3 2 3<br>1 1<br>1 1<br>1 1<br>1 1 1<br>1 1 1<br>输出数据 1<br>2 2 2<br>2 2 2<br>2 2 2</p><hr><p>个人评价:<br>这是线代!这一定是线代吧!!!不过抛开background不谈,还是要注意范围,线代学到矩阵会特别好懂此题.<br>本质是数学.二维数组+三重for循环表达+格式化输出即可.</p><p>正确代码如下:</p><pre><code>   #define _CRT_SECURE_NO_WARNINGS   #include &lt;cmath&gt;   #include &lt;map&gt;   #include &lt;iostream&gt;   #include&lt;cstring&gt;   #include &lt;stdio.h&gt;   #include &lt;stdlib.h&gt;   using namespace std;    int main ()&#123;int n;int m;int k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;int A[110][110];int B[110][110];int C[110][110];for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; m; ++j)    &#123;        cin &gt;&gt; A[i][j];    &#125;&#125;for (int i = 0; i &lt; m; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        cin &gt;&gt; B[i][j];    &#125;&#125;for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        C[i][j] = 0;        for (int a = 0; a &lt; m; ++a)        &#123;            C[i][j] += A[i][a] * B[a][j]//悲啊!&quot;+&quot;忘了写&quot;+=&quot;表示累加,单纯的&quot;=&quot;会覆盖前一次计算!!!;        &#125;    &#125;&#125;for (int i = 0; i &lt; n; ++i)&#123;    for (int j = 0; j &lt; k; ++j)    &#123;        cout &lt;&lt; C[i][j]&lt;&lt;&quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;return 0;&#125;</code></pre><hr><h2 id="D-斐波那契数列"><a href="#D-斐波那契数列" class="headerlink" title="D. 斐波那契数列"></a>D. 斐波那契数列</h2><p>题目描述</p><p>斐波那契数列是指这样的数列:数列的第一个和第二个数都为1,接下来每个数都等于前面2 个数之和.<br>给出一个正整数a,要求斐波那契数列中第 a 个数是多少。</p><p>输入格式</p><p>第 1 行是测试数据的组数n,后面跟着 n 行输入。每组测试数据占 1 行，包括一个正整数a（1≤a≤30).</p><p>输出格式</p><p>输出有 n 行，每行输出对应一个输入.输出应是一个正整数,为斐波那契数列中第 a 个数的大小。</p><p>输入数据<br>1<br>4<br>5<br>2<br>19<br>1<br>输出数据<br>1<br>5<br>1<br>4181<br>1</p><hr><p>个人评价:<br>(函数+递归(只能说出题者没有故意刁难我们出一个超过int类型的数,不然还要%))</p><p>代码如下:</p><pre><code>    #define _CRT_SECURE_NO_WARNINGS    #include &lt;cmath&gt;    #include &lt;map&gt;    #include &lt;iostream&gt;    #include&lt;cstring&gt;    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    using namespace std;    int pell(int n)&#123; if (n == 1)&#123;    return 1;&#125;else if (n == 2)&#123;    return 1;&#125;else&#123;    int a1 = 1, a2 = 1, a3;    for (int i = 0; i &lt; n - 2; i++)    &#123;        a3 = a1+a2;        a1 = a2;        a2 = a3;    &#125;    return a2;&#125;&#125;int main()&#123;int n;int b;cin &gt;&gt; n;for (int i = 0; i &lt; n; i++)&#123;    cin &gt;&gt; b;    cout &lt;&lt; pell(b) &lt;&lt; endl;&#125;return 0;  &#125;</code></pre><hr><h2 id="C-车厢重组"><a href="#C-车厢重组" class="headerlink" title="C.车厢重组"></a>C.车厢重组</h2><p>题目描述:<br>在一个旧式的火车站旁边有一座桥,其桥面可以绕河中心的桥墩水平旋转.<br>一个车站的职工发现桥的长度最多能容纳两节车厢,如果将桥旋转 180 度,则可以把相邻两节车厢的位置交换,用这种方法可以重新排列车厢的顺序.<br>于是他就负责用这座桥将进站的车厢按车厢号从小到大排列.他退休后,火车站决定将这一工作自动化,其中一项重要的工作是编一个程序,输入初始<br>的车厢顺序,计算最少用多少步就能将车厢排序.</p><p>输入格式<br>共两行.</p><p>第一行是车厢总数N(≤10000).</p><p>第二行是N个不同的数表示初始的车厢顺序.<br>(注:实际上数据中并不都在同一行,有可能分行输入)</p><p>输出格式<br>一个整数,最少的旋转次数.</p><p>输入数据 1<br>4<br>4 3 2 1<br>输出数据 1<br>6</p><p>个人反思:开始区分,冒泡排序用的不熟练,会用的写的很快.重新做一遍仍有问题.(具体在代码区)</p><hr><p>代码如下:</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include &lt;stdio.h&gt;           #include &lt;stdlib.h&gt;      #include&lt;stdbool.h&gt;using namespace std;       int b = 0;void BubbleSort(int a[], int size)&#123;for (int i = size - 1; i &gt; 0; --i)&#123;    for (int j = 0; j &lt; i; ++ j)    &#123;        if (a[j] &gt; a[j + 1])        &#123;            int tmp = a[j];            a[j] = a[j + 1];            a[j + 1] = tmp;            b++;  //就是这里统计次数,放在if里面在每次交换时统计次数.        &#125;    &#125;  &#125;&#125; int main()&#123;int N;cin &gt;&gt; N;int a[10001];for (int i = 0; i &lt; N; i++)&#123;    cin &gt;&gt; a[i];&#125;BubbleSort(a, N);cout &lt;&lt; b;return 0;  &#125;</code></pre><hr><h2 id="E-枚举排列"><a href="#E-枚举排列" class="headerlink" title="E. 枚举排列"></a>E. 枚举排列</h2><hr><p>题目描述<br>今有n名学生,要从中选出 k 人排成一列拍照.<br>请按字典序输出所有可能的排列方式.</p><p>输入格式<br>仅一行,两个正整数 n,k.</p><p>输出格式<br>若干行,每行 k 个正整数,表示一种可能的队伍顺序.</p><p>输入数据 1<br>3 2<br>输出数据 1<br>1 2<br>1 3<br>2 1<br>2 3<br>3 1<br>3 2<br>提示<br>对于100% 的数据,1≤k≤n≤10.</p><p>个人反思:深搜…还结合字典序…萌新杀手…<br>具体可看:<a href="https://blog.csdn.net/qq_37050329/article/details/86637183?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223D39BCCB-0B0C-4447-8EFD-CE4040FF37C4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=3D39BCCB-0B0C-4447-8EFD-CE4040FF37C4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86637183-null-">https://blog.csdn.net/qq_37050329/article/details/86637183?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223D39BCCB-0B0C-4447-8EFD-CE4040FF37C4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=3D39BCCB-0B0C-4447-8EFD-CE4040FF37C4&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86637183-null-</a><br>         null.142^v100^pc_search_result_base3&amp;utm_term&#x3D;%E5%AD%97%E5%85%B8%E5%BA%8F&amp;spm&#x3D;1018.2226.3001.4187<br>代码如下:</p><pre><code>  #define _CRT_SECURE_NO_WARNINGS  #include &lt;cmath&gt;  #include &lt;map&gt;  #include&lt;string.h&gt;  #include &lt;iostream&gt;  #include&lt;cstring&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include&lt;stdbool.h&gt;using namespace std;#define MAX_N 10bool used [MAX_N + 1];int path [MAX_N + 1];int n, k;void backtrack(int depth)&#123;if (depth == k)&#123;    for (int i = 0; i &lt; k; i++)    &#123;        printf(&quot;%d &quot;, path[i]);    &#125;printf(&quot;\n&quot;);return;&#125;for (int i = 1; i &lt;= n; i++)&#123;    if (!used[i])    &#123;        used[i] = true;        path[depth] = i;        backtrack(depth + 1);        used[i] = false;    &#125;   &#125; &#125;int main()&#123;scanf(&quot;%d %d&quot;, &amp;n ,&amp;k);memset(used, false, sizeof(used));backtrack(0);return 0;&#125;</code></pre><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇虚拟机文章</title>
      <link href="/2024/10/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>笔者虚拟机搭建比较简单，是从360管家下的VMware，所以不过多阐述。<br>建议去清华镜像站下载比较方便.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇BLOG搭建文章</title>
      <link href="/2024/10/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG%E6%90%AD%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG%E6%90%AD%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>笔者在这里使用的是hexo+github的个人博客搭建,如有错误请各位大佬指正。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>1.到 <a href="https://nodejs.cn/">https://nodejs.cn/</a> 下载Node.js下载常用版就行。为hexo运行搭建环境。<br>2.（1）github注册。如果English水平不高建议配上网易有道翻译。按web流程进行github注册。<br>  （2）创建代码库，勾选Public，在Repository name中按”用户名.github.io”(一定是这格式！)创建。<br>   (3) 可以自己在code&lt;&gt;选项上进行测试.<br>3. git for windows安装<br>   (1)输入<a href="https://gitforwindows.org/%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E3%80%82">https://gitforwindows.org/进入官网点击下载。</a><br>   (2)git安装默认C盘，可以根据需要自行更改。<br>   (3)勾选 don’t create a start menu folder<br>   (4)注意！！！！！github把master改名main了,配置congif要更改!!也就是branch:master改成branch:main!!<br>   (5)后面默认就行。<br>4.githubShh配置<br>   (1)以管理员身份打开git.bash.exe.<br>   (2)输入命令 ssh-keygen -t rsa -C “github邮箱注册地址”(如果找不到到C盘搜.shh前提是环境安装好)然后回车。<br>   (3)打开github-settings-deploy keys title写用户名，key找到”id rua.pub”复制粘贴。</p><h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>   (1)打开<a href="https://hexo.io/zh-cn/dots/">https://hexo.io/zh-cn/dots/</a><br>   (2)新建文件夹（命名自取）<br>   (3)在此文件夹下用管理员身份打开git.bash.exe.输入npm install hexo-cli -g<br>   (4)安装完用hexo -v验证。（确保路径正确）<br>   (5)在对应路径下输入hexo init初始化.<br>   (6)可以hexo s启动blog.<br>   当然这还未完成，还要挂到github上。<br>   (7)Ctrl+c先关掉。<br>   (8)好了，现在我们还需要装一个git部署插件,输入 snpm install –save hexo-deployer-git回车。<br>   (9)找到_config.yml用记事本打开，划到最底部，找到Depolyment,按如下格式配置。</p><pre><code> type: git repository: 自己的地址 branch:main(注意缩进与空格）</code></pre><p>   (10) hexo d部署(弹出方框输入账号）<br>   (11)成功！！！</p><h2 id="问题反思与感想"><a href="#问题反思与感想" class="headerlink" title="问题反思与感想"></a>问题反思与感想</h2><p>(1)短短几十行，但真正实践起来却要数十倍的时间，实践中，初步了解了0-1的艰难，各种问题层出不穷。<br>eg:路径不对—cd C:\  等去切换。<br>   获取管理员权限。<br>   上面的yml文件未配置好（细节在上）<br>   等。。<br>(2)总之，笔者在此受益颇多,感谢互联网的知识，优秀的作者，让我们前方的路清晰明朗。谢谢！！！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>����</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>����</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>��Ӱ</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>����</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
