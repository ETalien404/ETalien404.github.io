<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法技巧1(个人总结--持续更新中) | 一位元宇宙爱好者的随笔</title><meta name="author" content="ETalien"><meta name="copyright" content="ETalien"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="导言本篇文章总结了一些笔者对算法竞赛中一些常用的算法方法,可极大节省时间空间复杂度.持续更新中……  ACM竞赛注意点输入数据和输出数据一般有多种,并且格式多种,那么如何处理题目的输入和输出?下面分别介绍: 输入第一类输入不说明有多少个Input Block以EOF为结束标志 举个例子: 1234567891011121314151617a+b问题:sample input:1  510 20sa">
<meta property="og:type" content="article">
<meta property="og:title" content="算法技巧1(个人总结--持续更新中)">
<meta property="og:url" content="http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/index.html">
<meta property="og:site_name" content="一位元宇宙爱好者的随笔">
<meta property="og:description" content="导言本篇文章总结了一些笔者对算法竞赛中一些常用的算法方法,可极大节省时间空间复杂度.持续更新中……  ACM竞赛注意点输入数据和输出数据一般有多种,并且格式多种,那么如何处理题目的输入和输出?下面分别介绍: 输入第一类输入不说明有多少个Input Block以EOF为结束标志 举个例子: 1234567891011121314151617a+b问题:sample input:1  510 20sa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/yuanshen209.jpg">
<meta property="article:published_time" content="2024-11-09T12:40:58.000Z">
<meta property="article:modified_time" content="2025-03-12T12:42:46.080Z">
<meta property="article:author" content="ETalien">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/yuanshen209.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法技巧1(个人总结--持续更新中)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-12 20:42:46'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/image/yuanshen101.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/yuanshen103.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/yuanshen209.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">一位元宇宙爱好者的随笔</span></a><a class="nav-page-title" href="/"><span class="site-name">算法技巧1(个人总结--持续更新中)</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法技巧1(个人总结--持续更新中)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-09T12:40:58.000Z" title="发表于 2024-11-09 20:40:58">2024-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-12T12:42:46.080Z" title="更新于 2025-03-12 20:42:46">2025-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/">算法技巧</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">29k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>117分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>本篇文章总结了一些笔者对算法竞赛中一些常用的算法方法,可极大节省时间空间复杂度.<br>持续更新中……</p>
<hr>
<h2 id="ACM竞赛注意点"><a href="#ACM竞赛注意点" class="headerlink" title="ACM竞赛注意点"></a>ACM竞赛注意点</h2><p>输入数据和输出数据一般有多种,并且格式多种,那么如何处理题目的输入和输出?下面分别介绍:</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><h4 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h4><p>输入不说明有多少个Input Block以EOF为结束标志</p>
<p>举个例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a+b问题:</span><br><span class="line">sample input:</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line">sample output</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="comment">//没有告诉你多少组,以文件结束(EOF)为标志,我们处理如下:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)!=EOF)<span class="comment">//或者while(scanf(&quot;%d %d&quot;,&amp;a,&amp;b)==2)更好</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用while循环来循环读入2个数,只要scanf的返回值不等于EOF,就输出它们的和,就说明是成功的.</span></span><br></pre></td></tr></table></figure>

<p>那么读数据scanf函数返回值有什么含义呢?</p>
<p>含义是成功读取数据的个数.比如你试图读取2个,读取成功了就返回2,2!&#x3D;EOF(-1)是成立的,所以这时候就输出a+b的和.</p>
<p>当读取到文件的最后时,把所有的数据都读取完的时候scanf函数就返回-1,-1!&#x3D;-1很简单是不成立的,while停止循环,程序结束.我们可以解决多组数据一直读取到文件尾的问题.</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C语法:</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">C++语法:</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>scanf函数返回值是成功读取的数据个数,如果只有一个整数读入,返回值是1,如果有2个整数读入,返回值是2,如果一个都没有,则返回值是-1.</p>
<p>EOF是一个预处理的常量,等于-1.</p>
<h4 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h4><p>输入一开始就会说有N个Input Block,下面接着是N个Input Block</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sample input:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line">sample output</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="comment">//easy不讲</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h4><p>输入不说明有多少个Input Block,但以某个特殊输入为结束标志.</p>
<p>比如有的题目说读到两个0结束,有的题目说读到两个-1结束等等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sample input:</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line">sample output</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">	&#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="第四类"><a href="#第四类" class="headerlink" title="第四类"></a>第四类</h4><p>输入是一整行的字符串的.</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++语法:</span><br><span class="line">如果用string buf;来保存:</span><br><span class="line"><span class="built_in">getline</span>(cin,buf);<span class="comment">//普通函数</span></span><br><span class="line">如果用<span class="type">char</span> buf[<span class="number">255</span>];来保存:</span><br><span class="line">cin.<span class="built_in">getline</span>(buf,<span class="number">255</span>);<span class="comment">//cin的成员函数</span></span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="第一类-1"><a href="#第一类-1" class="headerlink" title="第一类"></a>第一类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sample input:</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line">sample output</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>一个Input Block对应一个Output Block,Output Block之间没有空行.</p>
<p>这是日常写的情况,easy不讲,就是一组数据输入后加一个回车就行.</p>
<h4 id="第二类-1"><a href="#第二类-1" class="headerlink" title="第二类"></a>第二类</h4><p>一个Input Block对应一个Output Block,Output Block之后都有空行.</p>
<p>每个数据结束后加上printf(“\n”);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sample input:</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line">sample output</span><br><span class="line"><span class="number">6</span></span><br><span class="line">    </span><br><span class="line"><span class="number">30</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="第三类-1"><a href="#第三类-1" class="headerlink" title="第三类"></a>第三类</h4><p>一个Input Block对应一个Output Block,Output Block之间都有空行.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sample input:</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line">sample output</span><br><span class="line"><span class="number">6</span></span><br><span class="line">    </span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>例如首项为1公差为1的前100000项和如果直接用求和公式会爆int,所以开long long.</p>
<h3 id="OJ判题的逻辑"><a href="#OJ判题的逻辑" class="headerlink" title="OJ判题的逻辑"></a>OJ判题的逻辑</h3><h4 id="关键区别分析"><a href="#关键区别分析" class="headerlink" title="关键区别分析"></a>关键区别分析</h4><table>
<thead>
<tr>
<th align="center">输入方式</th>
<th align="center">代码示例</th>
<th align="center">适用场景</th>
<th align="center">OJ 结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">循环读取</td>
<td align="center">while(cin&gt;&gt;n&gt;&gt;k)</td>
<td align="center">多组测试用例</td>
<td align="center">正确</td>
</tr>
<tr>
<td align="center">单次读取</td>
<td align="center">cin&gt;&gt;n&gt;&gt;k</td>
<td align="center">仅单组测试用例</td>
<td align="center">错误</td>
</tr>
</tbody></table>
<h4 id="判题系统的工作原理"><a href="#判题系统的工作原理" class="headerlink" title="判题系统的工作原理"></a>判题系统的工作原理</h4><h5 id="输入文件结构"><a href="#输入文件结构" class="headerlink" title="输入文件结构"></a>输入文件结构</h5><p>OJ 的输入文件通常包含多组测试数据,格式如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T          <span class="comment">// 测试用例数</span></span><br><span class="line">n1 k1      <span class="comment">// 第1组数据</span></span><br><span class="line">a1 a2 ... an1</span><br><span class="line">n2 k2      <span class="comment">// 第2组数据</span></span><br><span class="line">a1 a2 ... an2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>或直接连续排列多组数据(无显式 T)</p>
<h5 id="程序生命周期"><a href="#程序生命周期" class="headerlink" title="程序生命周期"></a>程序生命周期</h5><p>判题系统会一次性将整个输入文件传递给程序,程序需要<strong>完整处理所有测试用例</strong>后才能退出.</p>
<h4 id="两种输入方式的对比"><a href="#两种输入方式的对比" class="headerlink" title="两种输入方式的对比"></a>两种输入方式的对比</h4><h5 id="循环读取方式"><a href="#循环读取方式" class="headerlink" title="循环读取方式"></a>循环读取方式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">    <span class="comment">// 处理每组数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>:持续读取输入直到文件结束(EOF).</li>
<li><strong>优点</strong>:自动适应多组测试用例,无论是否显式给出 T.</li>
<li><strong>适用性</strong>:通用性强,符合 OJ 的输入规范.</li>
</ul>
<h5 id="单次读取方式"><a href="#单次读取方式" class="headerlink" title="单次读取方式"></a>单次读取方式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="comment">// 处理一组数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>行为</strong>:只读取第一组数据后退出.</li>
<li><strong>缺点</strong>:后续测试用例未被处理,导致答案缺失.</li>
<li><strong>结果</strong>:OJ 判定为 <strong>答案错误</strong>(WA),因为输出数量不足.</li>
</ul>
<h2 id="ACM中的小结论"><a href="#ACM中的小结论" class="headerlink" title="ACM中的小结论"></a>ACM中的小结论</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>LCM(最小公倍数)</p>
<p>数学上,LCM(A,B)&#x3D;A*B&#x2F;GCD(A,B)</p>
<p>上面的公式注意A*B不要溢出或者改一下  A&#x2F;GCD(A,B *B</p>
<p>问题转化为:求最小公倍数GCD</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> da,<span class="type">int</span> xiao)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(xiao!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=da%xiao;</span><br><span class="line">        da=xiao;</span><br><span class="line">        xiao=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环节-抽屉原理"><a href="#循环节-抽屉原理" class="headerlink" title="循环节(抽屉原理)"></a>循环节(抽屉原理)</h3><p>举一道例题:</p>
<p>有一种fibonacci数列,定义如下:</p>
<p>F(0)&#x3D;7;</p>
<p>F(1)&#x3D;11;</p>
<p>F(n)&#x3D;F(n-1)+F(n-2) (n&gt;&#x3D;2)</p>
<p>给定一个n(n&lt;100000000),请判断F(n)能否被3整除,分别输出yes和no.</p>
<p>如果用暴力肯定tle,不行,我们得想办法找到规律.所以根据题意有:</p>
<p>F(n)%3&#x3D;F(n-1)%3+F(n-2)%3 (n&gt;&#x3D;2)</p>
<p>然后可以枚举前几十项找规律</p>
<p>1 2 0 2 2 1 0 1 1 2发现重复就可以按规律来了</p>
<p>但是这规律怎么来的呢?</p>
<p>首先明确一点:x%3的结果就3个 0 1 2</p>
<p>我们要算的是所有可能的排列sum<br>$$<br>sum&#x3D;A_{3}^{3}+3&#x3D;3!+3&#x3D;9<br>$$<br>最多存在12种可能的情况,我们只需要枚举到11(10组)看是否重复就行了</p>
<p>推广到x%n:<br>$$<br>sum&#x3D;A_{n}^{n}+n&#x3D;n!+n<br>$$</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>为了更好引入此概念,牛客上有一道经典的算法题,将它归类到位运算中(本质上就是这个).<br>题目如下:</p>
<p>链接:<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/996/A">https://ac.nowcoder.com/acm/contest/996/A</a><br>来源:牛客网</p>
<p>题目描述<br>求a的b次方对p取模的值,其中0≤a,b,p≤10^9,p&gt;0</p>
<p>输入描述:<br>三个用空格隔开的整数a,b和p.<br>输出描述:<br>一个整数表示a^b(mod)p的值.</p>
<p>看起来简单吧?只需要for循环再取mod就可收工了.但看看范围,很明显直接爆了或者超时.<br>你就算开long long 都没用!</p>
<p>分析:</p>
<p>本质上问题的解决还是在于a^b,这太大了,以至于分开求模再次方也无济于事.<br>这时候,有没有一种少一些循环且高效的算法呢?<br>不妨想想计算机是如何存储数据的.<br>不妨设想b为2的n次方.</p>
<p>就令b&#x3D;64.演示如下:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a^<span class="number">1</span>*a^<span class="number">1</span>=a^<span class="number">2</span></span><br><span class="line">a^<span class="number">2</span>*a^<span class="number">2</span>=a^<span class="number">4</span></span><br><span class="line">a^<span class="number">4</span>*a^<span class="number">4</span>=a^<span class="number">8</span></span><br><span class="line">a^<span class="number">8</span>*a^<span class="number">8</span>=a^<span class="number">16</span></span><br><span class="line">a^<span class="number">16</span>*a^<span class="number">16</span>=a^<span class="number">32</span></span><br><span class="line">a^<span class="number">32</span>*a^<span class="number">32</span>=a^<span class="number">64</span></span><br></pre></td></tr></table></figure>
<hr>
<p>本质是倍增原理,将a的数量翻倍.<br>那么不为2的情况呢?</p>
<p>来个b&#x3D;105.那么…</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a^<span class="number">105</span>=a*a^<span class="number">8</span>*a^<span class="number">32</span>*a^<span class="number">64</span></span><br><span class="line"></span><br><span class="line">(<span class="number">105</span>)<span class="number">10</span>=(<span class="number">1101001</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">1</span>)<span class="number">10</span>  =(<span class="number">0000001</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">8</span>)<span class="number">10</span>  =(<span class="number">0001000</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">32</span>)<span class="number">10</span> =(<span class="number">0100000</span>)<span class="number">2</span></span><br><span class="line">(<span class="number">64</span>)<span class="number">10</span> =(<span class="number">1000000</span>)<span class="number">2</span></span><br><span class="line"><span class="comment">//综合起来,看下伪代码:</span></span><br><span class="line"></span><br><span class="line">function <span class="built_in">binexp</span>(a,b)</span><br><span class="line">    r=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b!=<span class="number">0</span> <span class="comment">//从低到高不断遍历每一位</span></span><br><span class="line">       <span class="keyword">if</span> n mod <span class="number">2</span>==<span class="number">1</span> <span class="comment">//如果遍历是1 优化:n&amp;1</span></span><br><span class="line">          r = r*a <span class="comment">//乘上各循环所对应的a的倍增数</span></span><br><span class="line">       a =a*a <span class="comment">//倍增a</span></span><br><span class="line">       b=[b/<span class="number">2</span>]<span class="comment">//优化:b&gt;&gt;1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"> 时间复杂度;<span class="built_in">O</span>(logn)</span><br></pre></td></tr></table></figure>

<hr>
<p>补充一下递归和非递归实现的快速幂</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">1</span>;<span class="comment">//结束条件</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="built_in">power</span>(a*a,n/<span class="number">2</span>);<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) ans*=a;<span class="comment">//n为奇数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) ans=ans*a;<span class="comment">//奇数情况</span></span><br><span class="line">        a=a*a;<span class="comment">//底数平方</span></span><br><span class="line">        n/=<span class="number">2</span>;<span class="comment">//指数减半</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>呼,接下来不就简单了吗?</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b, p,ans;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">ans = <span class="number">1</span> % p;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=ans*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a * a % p;</span><br><span class="line">    b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别提醒:</p>
<p>1.务必注意爆int的风险</p>
<p>2.快速幂几乎都伴随模运算</p>
<hr>
<h3 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h3><p>嘻嘻,同样类型,思路上是一样的但是细节上还是略有差别.<br>还是举例牛客,看题!</p>
<p>链接:<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/996/C">https://ac.nowcoder.com/acm/contest/996/C</a><br>来源:牛客网</p>
<p>题目描述<br>求a乘b对p取模的值,其中1≤a,b,p≤10^18<br>输入描述:<br>第一行a,第二行b,第三行p.<br>输出描述:<br>一个整数,表示a×b(mod)p的值.</p>
<p>有了上一题的基础,理解起来想必容易很多.<br>但算法的细节还是不一样的.<br>这是将后面一个乘数转化为二进制形式计算.</p>
<p>举个例子吧!</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>*<span class="number">11</span>%<span class="number">5</span></span><br><span class="line"><span class="number">12</span>*<span class="number">11</span>=<span class="number">12</span>*(<span class="number">1011</span>)<span class="number">2</span>=<span class="number">12</span>*<span class="number">2</span>^<span class="number">3</span><span class="number">+12</span>*<span class="number">2</span>^<span class="number">1</span><span class="number">+12</span>*<span class="number">2</span>^<span class="number">0</span>=<span class="number">96</span><span class="number">+24</span><span class="number">+12</span>=<span class="number">132</span></span><br><span class="line">用&amp;与(&gt;&gt;,&lt;&lt;)得出</span><br><span class="line">计算转换为:</span><br><span class="line">((<span class="number">12</span>%<span class="number">5</span>)+(<span class="number">24</span>%<span class="number">5</span>)+(<span class="number">96</span>%<span class="number">5</span>))%<span class="number">5</span>=(<span class="number">2</span><span class="number">+4</span><span class="number">+1</span>)%<span class="number">5</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<hr>
<p>现在就好理解了.</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksc</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(b)<span class="comment">//与上一题一样,从低到高不断遍历每一位</span></span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">if</span>((b&amp;<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            result=(result+a)%p;<span class="comment">//这样理解了为啥是加而不是乘</span></span><br><span class="line">            &#125;</span><br><span class="line">      a = (a + a) % p;</span><br><span class="line">      b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>那么,解决问题!</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b, p,ans;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=(ans+a)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    a = (a + a) % p;</span><br><span class="line">    b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="统计问题"><a href="#统计问题" class="headerlink" title="统计问题"></a>统计问题</h3><p>可以说应该算固定题了.但依旧应用到了分治递归的思想.下面通过牛客上的几道题逐步理解这种思想.</p>
<p>[NOIP2010]数字统计<br>链接:<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/19859/A">https://ac.nowcoder.com/acm/contest/19859/A</a><br>来源:牛客网</p>
<p>题目描述<br>请统计某个给定范围[L,R]的所有整数中,数字2出现的次数.</p>
<p>比如给定范围[2,22],数字2在数2中出现了1次,在数12中出现1次,在数20中出现1次,在数21中出现1次,在数22中出现2次,所以数字2在该范围内一共出现了6次.</p>
<p>输入描述:<br>输入共1行,为两个正整数L和R,之间用一个空格隔开.<br>输出描述:<br>输出共1行，表示数字2出现的次数.<br>备注:<br>1≤L≤R≤10000</p>
<p>分析:<br>初次见到时,相信很可能会这么想:从L–R全部遍历过去,于是就想用一个for循环将搜寻给定数出现的次数.<br>所以可以写出以下代码:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//声明全局变量</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//我在这里写了函数,用于判断特定数字出现的个数.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (a&gt;<span class="number">0</span>)<span class="comment">//个人觉得这个循环可以作为模板了.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">2</span>)<span class="comment">//如果有得到目标元素就ans++</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a / <span class="number">10</span>; 相当于二进制中的&gt;&gt;将十进制的位数向左移动一位</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> L;</span><br><span class="line">   <span class="type">int</span> R;</span><br><span class="line"> </span><br><span class="line">cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; i++)<span class="comment">//这就是遍历了.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = i;</span><br><span class="line">    <span class="built_in">solve</span>(k);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>评价:难想到的就是如何将高位数也统计到.本质上还是位运算.</p>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>预处理的一种,节省固定区间的区间和的重复计算.能大大降低查询的时间复杂度.</p>
<h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>前缀和的实现很大程度上与对应数组的下标有很大关系,我们通常认为数组的下标是从0开始的.</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>这是正常的一个数组.如果我给一个区间[l,r],求这个区间子数组的和.</p>
<p>正常来说容易想到是一个for循环直接搞定,但是如果数组很大的话这是一个O(n)的复杂度.但用前缀和可以缩短为O(1).</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">3</th>
<th align="center">6</th>
<th align="center">10</th>
<th align="center">15</th>
<th align="center">21</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>可以看到前缀和要比原来数组多一个位置.(按这种格式)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">ll sum[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//前缀和的第一项设0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">+1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i<span class="number">-1</span>];<span class="comment">//核心代码,好几种变形,不要混了.</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    ll result=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//这里容易出事,比如l=2,r=4.</span></span><br><span class="line">    <span class="comment">//result=sum[4]-sum[1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="入门基础"><a href="#入门基础" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="初识贪心"><a href="#初识贪心" class="headerlink" title="初识贪心"></a>初识贪心</h3><p>对问题的求解时,总是作出在当前看来最好的选择.</p>
<p>不从整体上考虑,所作出的仅仅只是在某种意义上的局部最优解(如果是全局最优需要证明).</p>
<h4 id="前提操作"><a href="#前提操作" class="headerlink" title="前提操作"></a>前提操作</h4><h5 id="排序—sort"><a href="#排序—sort" class="headerlink" title="排序—sort"></a>排序—sort</h5><h6 id="sort简单理解"><a href="#sort简单理解" class="headerlink" title="sort简单理解"></a>sort简单理解</h6><p>头文件:#include<algorithm></p>
<p>sort(首地址,尾地址+1,[cmp函数])</p>
<p>这个函数可以传2-3个参数</p>
<p>第一个参数是要排序区间的首地址</p>
<p>第二个参数是区间的尾地址的下一地址</p>
<p>第三个参数不写,则缺省为递增排序</p>
<p>递减排序规则我举个例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明:定义小于运算的类型都类似,甚至包括字符串类string.(字符数组不支持小于运算符,需要strcmp函数)</p>
<h6 id="sort对结构体数组排序"><a href="#sort对结构体数组排序" class="headerlink" title="sort对结构体数组排序"></a>sort对结构体数组排序</h6><p>举个例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">node arr[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span><span class="comment">//先按a值升序排列,如果a值相同,再按b值降序排列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.a!=y.a) <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">    <span class="keyword">return</span> x.b&gt;y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(arr,arr<span class="number">+10</span>,cmp);</span><br></pre></td></tr></table></figure>

<p>综合点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">11</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">&#125;stu[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(student x,<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x.score-y.score)&gt;<span class="number">0.000001</span>)<span class="comment">//判断浮点数是否相等就是要看它们绝对值的差.是否小于一个很小的数</span></span><br><span class="line">        <span class="keyword">return</span> x.score&gt;y.score;</span><br><span class="line">    <span class="keyword">if</span>(x.age!=y.age) <span class="keyword">return</span> x.age&lt;y.age;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(x.name,y.name)&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h6><p>sort可以对数组的某一段进行排序</p>
<p>数组中的元素如果是从下标1的位置开始存储,由此带来的常见错误是—-忘记修改sort的参数</p>
<p>比如从下标1开始此时就要改成sort(a+1,a+n+1,cmp);</p>
<p>千万留意这一点!!</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1650">P1650 田忌赛马 - 洛谷</a></p>
<p>很经典的一道贪心问题,考虑用双指针,先用2个vector存起来,再用双指针,分3种情况讨论:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9+7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">a1</span>(n);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">a2</span>(n);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(a<span class="number">1.</span><span class="built_in">begin</span>(),a<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">sort</span>(a<span class="number">2.</span><span class="built_in">begin</span>(),a<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> left1 = <span class="number">0</span>, right1 = n - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> left2 = <span class="number">0</span>, right2 = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (left1 &lt;= right1) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a1[right1] &gt; a2[right2]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 如果 a1 的最大数大于 a2 的最大数，a1 赢</span></span><br><span class="line">			ans += <span class="number">200</span>;</span><br><span class="line">			right1--;</span><br><span class="line">			right2--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a1[left1] &gt; a2[left2]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 如果 a1 的最小数大于 a2 的最小数，a1 赢</span></span><br><span class="line">			ans += <span class="number">200</span>;</span><br><span class="line">			left1++;</span><br><span class="line">			left2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则，用 a1 的最小数和 a2 的最大数比较，a1 输</span></span><br><span class="line">			<span class="keyword">if</span> (a1[left1] &lt; a2[right2]) &#123;</span><br><span class="line">				ans -= <span class="number">200</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			left1++;</span><br><span class="line">			right2--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h5><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2037">Problem - 2037</a></p>
<p>寒假训练营1的H井然有序之窗的原版,为了解决这个问题,我们需要找到一种方法来尽可能多地观看完整的电视节目.这是一个经典的活动选择问题,可以通过贪心算法来解决.贪心算法的核心思想是每次选择结束时间最早的节目,以便为后续的节目留出更多的时间.</p>
<h6 id="方法思路"><a href="#方法思路" class="headerlink" title="方法思路"></a>方法思路</h6><ol>
<li>输入处理:读取输入的节目数量,然后读取每个节目的开始和结束时间.</li>
<li>排序:将所有节目按照结束时间从小到大排序.这样可以确保每次选择的节目都是能够最早结束的,从而为后续节目留出更多时间.</li>
<li>贪心选择:遍历排序后的节目列表,选择每一个不与已选节目时间冲突的节目(即当前节目的开始时间不早于上一个选中节目的结束时间),并更新最后一个选中节目的结束时间.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Program</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> Program &amp;a, <span class="type">const</span> Program &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;Program&gt; <span class="title">programs</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; programs[i].start &gt;&gt; programs[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(programs.<span class="built_in">begin</span>(), programs.<span class="built_in">end</span>(), compare);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lastEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;prog : programs) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (prog.start &gt;= lastEnd) </span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                lastEnd = prog.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h5><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1050">Problem - 1050</a></p>
<p>搬桌子,典型的贪心.找重叠数最高的,搬桌子需要几趟与最高重叠数是有关系的.只需要标记从左到右哪个重叠数最高就行了. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, i, j, N, P[<span class="number">200</span>];</span><br><span class="line">    <span class="type">int</span>  s, d, temp, k, MAX;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++)</span><br><span class="line">            P[j] = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//必须要再次全置为0,否则出现上一次的数据无法删除.</span></span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; s &gt;&gt; d;</span><br><span class="line">            s = (s - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//每两个为一组</span></span><br><span class="line">            d = (d - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = s;</span><br><span class="line">                s = d;</span><br><span class="line">                d = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (k = s; k &lt;= d; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                P[k]++;<span class="comment">//统计重叠次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            MAX = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (P[j] &gt; MAX)</span><br><span class="line">                &#123;</span><br><span class="line">                    MAX = P[j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; MAX * <span class="number">10</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1106">P1106 删数问题 - 洛谷</a></p>
<h6 id="方法—逆序对"><a href="#方法—逆序对" class="headerlink" title="方法—逆序对"></a>方法—逆序对</h6><p>其实很简单,我举个例子就行: 1 2 3 4这是正序吧? 那么1 3 2 4看 3 2就是逆序对.只需要用指针遍历一次就行了.</p>
<p>大佬解法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string n;</span><br><span class="line">    <span class="type">int</span> s,i;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;n[i]&lt;=n[i<span class="number">+1</span>];)</span><br><span class="line">        &#123;<span class="comment">//找高峰期</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        n.<span class="built_in">erase</span>(i,<span class="number">1</span>);<span class="comment">//删除函数,就是从第i个位置连续删1个。如果不清楚删除函数，可以百度。</span></span><br><span class="line">        s--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;n.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//处理前导零，注意如果长度是1就不能再删了。</span></span><br><span class="line">    	n.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    cout&lt;&lt;n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h5><p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=1659">1659 – Frogs’ Neighborhood</a></p>
<h6 id="方法—可图性判定–离散数学"><a href="#方法—可图性判定–离散数学" class="headerlink" title="方法—可图性判定–离散数学"></a>方法—可图性判定–离散数学</h6><p>两个概念:</p>
<p>1.度序列:若把图G的所有顶点的度数排成一个序列S,则称S为图G的度序列.</p>
<p>2.序列是可图的:一个非负整数组成的有限序列如果是某个无向图的度序列,则称该序列是可图的.</p>
<h6 id="Havel-Hakimi算法"><a href="#Havel-Hakimi算法" class="headerlink" title="Havel-Hakimi算法"></a>Havel-Hakimi算法</h6><p>给定一个非负整数序列{d1,d2,…dn},若存在一个无向图使得图中各点的度与此序列一一对应,则称此序列可图化.进一步,若图为简单图,则称此序列可简单图化.</p>
<p>定理描述:由非负整数组成的有限非递增序列,S&#x3D;{d1,d2,d3…dn},当且仅当S1&#x3D;{d2-1,d3-1…d(d1+1),d(d1+2)……dn}也是可图的,也就是说,序列S1也是由非负整数组成的有限非递增序列,S1是由S的删除第一个元素d1之后的前d1个元素分别减一后得到的序列.(充要条件)</p>
<p>(注:Havel-Hakimi定理 讨论的是在非递增序列下判别是否可图的定理)</p>
<p>练习:</p>
<p>度序列:7,7,4,3,3,3,2,1</p>
<p>首先把所有的度递减排序,排序完把第一个去掉,后面每个减1.6,3,2,2,2,1,0继续对剩余的数列进行排序,做完排序一次,实际中不能保证每个都不需要排序,后面照前,2,1,1,1,0,-1.只要出现负数就说明是不可能的,这样的图是画不出来的,就是NO.如果全部变0就是YES.</p>
<h1 id="并查集-DISJOINT-SET"><a href="#并查集-DISJOINT-SET" class="headerlink" title="并查集(DISJOINT SET)"></a>并查集(DISJOINT SET)</h1><h2 id="入门基础-1"><a href="#入门基础-1" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h3><p>不相交的集合.</p>
<p>问题描述:将编号分别为1…N的N个对象划分为不相交集合,在每个集合中,选择其中某个元素代表所在的集合.</p>
<p>常见的两种操作:</p>
<p>合并两个集合</p>
<p>查找某个元素属于哪个集合.</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>用编号最小的元素标记所在的集合,用集合里面编号最小的元素作为集合的代表.</p>
<p>定义一个数组Set[1…n],其中Set[i]表示元素i所在的集合:</p>
<table>
<thead>
<tr>
<th align="center">set[i]</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">2</th>
<th align="center">6</th>
<th align="center">1</th>
<th align="center">6</th>
<th align="center">2</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">10</td>
</tr>
</tbody></table>
<p>不相交集合:{1,3,7},{4},{2,5,9,10},{6,8}</p>
<p>这样就用一个点代表更大的东西.</p>
<p>那么保存在同一个数组里,怎么保证谁在同一个集合中?</p>
<p>通过编号看具体的数据是否相等来看元素在哪个集合中.</p>
<h5 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找,效率O(1)</span></span><br><span class="line"><span class="built_in">find1</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Set[x];<span class="comment">//老大的编号,这里用老大的编号代表集合,一个集合只有一个老大.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并操作,效率O(n) </span></span><br><span class="line"><span class="built_in">Merge1</span>(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    i=<span class="built_in">min</span>(a,b);<span class="comment">//合并中小的一方</span></span><br><span class="line">    j=<span class="built_in">max</span>(a,b);<span class="comment">//大的一方</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)<span class="comment">//遍历,我不知道a,b所属的集合在哪个位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Set[k]==j)</span><br><span class="line">        &#123;</span><br><span class="line">            Set[k]==i;<span class="comment">//将大的集合合并到小的.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>每一个集合用一棵有根树表示</p>
<p>定义一个数组Set[1…n]:</p>
<p>1.Set[i]&#x3D;i,则i表示本集合,并且是对应树的根</p>
<p>2.Set[i]&#x3D;j,若j不等于i，则j是i的父节点.</p>
<table>
<thead>
<tr>
<th align="center">set[i]</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">10</td>
</tr>
</tbody></table>
<h5 id="效率分析-1"><a href="#效率分析-1" class="headerlink" title="效率分析"></a>效率分析</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找,如果树退化成链表,效率最坏O(n),一般...?</span></span><br><span class="line"><span class="built_in">find2</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">    r=x;</span><br><span class="line">    <span class="keyword">while</span>(Set[r]!=r)<span class="comment">//1.不是上级领导 3.再看领导的领导保存的是不是自己,如果不是继续往上走.循环结束一定是Set[r]==r</span></span><br><span class="line">    &#123;</span><br><span class="line">        r=Set[r];<span class="comment">//2.现在的r变成领导</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> r;<span class="comment">//找到最终的领导</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并操作,效率O(1)</span></span><br><span class="line"><span class="built_in">merge2</span>(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    Set[a]=b;<span class="comment">//等于说是最终领导之间的直接合并.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h4><h5 id="基本思路-理论"><a href="#基本思路-理论" class="headerlink" title="基本思路(理论)"></a>基本思路(理论)</h5><p>方法:将深度小的树合并到深度大的树</p>
<p>实现:假设两棵树的深度分别是h1和h2,则合并后的树的高度h是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(h1,h2), <span class="keyword">if</span>(h1&gt;h2)或者<span class="keyword">if</span>(h1&lt;h2)</span><br><span class="line"></span><br><span class="line">h1<span class="number">+1</span> <span class="keyword">if</span>(h1==h2)</span><br></pre></td></tr></table></figure>

<p>效果:任意顺序操作以后,包含k个节点的树的最大高度不超过[lgk]</p>
<h5 id="优化—路径压缩"><a href="#优化—路径压缩" class="headerlink" title="优化—路径压缩"></a>优化—路径压缩</h5><p>可能问题:如果树的高度很大,查找的路径就会较长,当查找量很大的时候,很容易TLE.</p>
<p>解决思想:每次查找的时候,如果路径较长,则修改信息,以便下次查找的时候速度更快.</p>
<p>具体方案:</p>
<p>1.找到根节点</p>
<p>2.修改查找路径上的所有节点,将它们指向根节点.通俗的,一个路径本来很长的,把路径上经过的所有的人都介绍给最高领导认识,后面查找就可以直接访问了.</p>
<h5 id="效率分析-2"><a href="#效率分析-2" class="headerlink" title="效率分析"></a>效率分析</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">带路径压缩的查找操作(递归)</span><br><span class="line"><span class="built_in">find3</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Set[x]!=x)<span class="comment">//如果x不是最终老大调用find3,参数是Set[x],Set[x]保存的值就不是原来的,而是直接保存最终老大.相当于路径上的各级领导直接和最终领导建立联系.</span></span><br><span class="line">        Set[x]=<span class="built_in">find3</span>(Set[x]);</span><br><span class="line">    <span class="keyword">return</span> Set[x];<span class="comment">//返回老大.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经典应用—最小生成树"><a href="#经典应用—最小生成树" class="headerlink" title="经典应用—最小生成树"></a>经典应用—最小生成树</h3><h5 id="基本含义–什么是生成树"><a href="#基本含义–什么是生成树" class="headerlink" title="基本含义–什么是生成树?"></a>基本含义–什么是生成树?</h5><p>下图,左边是带权图,连线表示边6个点,10条边组成的一个权图,权值有不同的含义,比如距离,路费等.右边是生成树,生成树是相对图来说的,如果一个图拥有另外一个图的所有顶点并且包含其中的n-1条边,还要符合树的定义,这时候我们就说右边这个图是左边这个图的生成树.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\个人博客\main\blog\blog\source\image\最小生成树-并查集演示.png"></p>
<p>如果权值和是所有树中最小的,则称为最小生成树.</p>
<h5 id="如何求最小生成树"><a href="#如何求最小生成树" class="headerlink" title="如何求最小生成树"></a>如何求最小生成树</h5><h6 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h6><p>根据至少存在一棵最小生成树包含权值最少的这一条边.</p>
<p>反证法:假设所有最小生成树没有包含权值最少的这一条边,把最短的这一条边加上我所谓的最小生成树,现在构造一棵新的生成树比之前还要小,说明 假设是错的.至少存在一棵最小生成树包含权值最少的这一条边.</p>
<p>既然一定包含权值最少的这一条边,先选上,再做类似的操作,只要这条边对应的顶点还没有联通就加进来.</p>
<p>怎么每次选一个最短的边,先排序.</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1233">Problem - 1233</a></p>
<p>经典,并查集个数-1—老大个数-1</p>
<h1 id="递推求解"><a href="#递推求解" class="headerlink" title="递推求解"></a>递推求解</h1><h2 id="入门基础-2"><a href="#入门基础-2" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="递推常见算法"><a href="#递推常见算法" class="headerlink" title="递推常见算法"></a>递推常见算法</h3><h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><h5 id="引入"><a href="#引入" class="headerlink" title="引入:"></a>引入:</h5><p>其前几项为(从第0项开始):1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …<br>$$<br>通项公式:h(n)&#x3D;\frac{C_{2n}^{n}}{(n+1)}&#x3D;C_{2n}^{n}-C_{2n}^{n-1}<br>$$</p>
<p>$$<br>递推公式:h(n)&#x3D;h(0)\times h(n-1)+h(1)\times h(n-2)+…h(n-1)\times h(0)(n\geqslant2)<br>$$</p>
<p>$$<br>递推公式:C(n)&#x3D;\frac{4n-2}{(n+1)}\times C(n-1)<br>$$</p>
<h5 id="如何求解"><a href="#如何求解" class="headerlink" title="如何求解"></a>如何求解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">catalan</span><span class="params">()</span> <span class="comment">//求卡特兰数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, len, carry, temp;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">0</span>] = b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++) <span class="comment">//乘法</span></span><br><span class="line">        a[i][j] = a[i<span class="number">-1</span>][j]*(<span class="number">4</span>*(i<span class="number">-1</span>)<span class="number">+2</span>);</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++) <span class="comment">//处理相乘结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i][j] + carry;</span><br><span class="line">            a[i][j] = temp % <span class="number">10</span>;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(carry) <span class="comment">//进位处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[i][len++] = carry % <span class="number">10</span>;</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = len<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//除法</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = carry*<span class="number">10</span> + a[i][j];</span><br><span class="line">            a[i][j] = temp/(i<span class="number">+1</span>);</span><br><span class="line">            carry = temp%(i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a[i][len<span class="number">-1</span>]) <span class="comment">//高位零处理</span></span><br><span class="line">        len --;</span><br><span class="line">        b[i] = len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="例题–高精度"><a href="#例题–高精度" class="headerlink" title="例题–高精度"></a>例题–高精度</h5><p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2084">2084 – Game of Connections</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">multiply</span><span class="params">(string num, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = num.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(num[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> product = arr[i] * m + carry;</span><br><span class="line">        res.<span class="built_in">push_back</span>(product % <span class="number">10</span>);</span><br><span class="line">        carry = product / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        s += (res[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> pos = s.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != string::npos) &#123;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string num, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : num) &#123;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> current = remainder * <span class="number">10</span> + arr[i];</span><br><span class="line">        res.<span class="built_in">push_back</span>(current / d);</span><br><span class="line">        remainder = current % d;</span><br><span class="line">    &#125;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">bool</span> foundNonZero = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res[i] != <span class="number">0</span> || foundNonZero) &#123;</span><br><span class="line">            s += (res[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            foundNonZero = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">catalan</span><span class="params">(<span class="number">101</span>)</span></span>;</span><br><span class="line">    catalan[<span class="number">0</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">4</span> * i - <span class="number">2</span>;</span><br><span class="line">        string temp = <span class="built_in">multiply</span>(catalan[i<span class="number">-1</span>], m);</span><br><span class="line">        <span class="type">int</span> d = i + <span class="number">1</span>;</span><br><span class="line">        catalan[i] = <span class="built_in">divide</span>(temp, d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            cout &lt;&lt; catalan[n] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h5 id="应用—要用高精度算法"><a href="#应用—要用高精度算法" class="headerlink" title="应用—要用高精度算法"></a>应用—要用高精度算法</h5><h6 id="多边形三角形的数目"><a href="#多边形三角形的数目" class="headerlink" title="多边形三角形的数目"></a>多边形三角形的数目</h6><p>比如一个多边形把TA划分成若干个三角形或者说N-2个三角形,并且里面连线的时候不能有交叉,问一共有多少种划分法.</p>
<p>比如四边形横竖两种分法,五边形五种,六边形14种,七边形42种,与上面的例题有什么联系?无论是例题还是多边形,多边形连线就把整个多边形分成不相干的两块,就可以分别去递归.</p>
<h6 id="加括号的方式"><a href="#加括号的方式" class="headerlink" title="加括号的方式"></a>加括号的方式</h6><p>3 numbers</p>
<p>(1 (2 3)) ((1 2) 3 )</p>
<p>4 numbers</p>
<p>(1 (2 (3 4))) (1((2 3)4))</p>
<p>((1 2)(3 4)) (((1 2)3)4)</p>
<p>如上就是一个括号里面假设只允许有两个元素.</p>
<p>可以是数字,也可以是括号.每个括号超过两个元素可以继续分.</p>
<p>一共多少种表示方法就是卡特兰数.</p>
<h6 id="走路不同路线的数量"><a href="#走路不同路线的数量" class="headerlink" title="走路不同路线的数量"></a>走路不同路线的数量</h6><p>假设是N*N的网格从左上角走到右下角,要求只在下三角或是上三角.</p>
<p>也是卡特兰数.</p>
<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><p>N个节点的二叉树有多少种不同的形态</p>
<p>3个节点有5种不同的形态,</p>
<p>4个节点就有14种…</p>
<p>本质上二叉树有根分左右,一旦分好两边是不影响的</p>
<h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p>&lt;1&gt;假设两个候选人参加选举N个人参加投票,如果在唱票的过程中,A从来未落后B,则不同的唱票方式也满足卡特兰数.(假设A,B票数最终相等)</p>
<p>&lt;2&gt;2n个人围坐在一个圆桌旁,每个人找一个人握手,要求胳膊不能有交叉,则不同的握手方案满足卡特兰数.</p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1"></a>例题1</h4><p>当n条直线在平面上与一个圆相交，且没有任何三条直线共点时，这些直线会将圆分成多少个区域?</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>每次放进1条直线会在原来F(N-1)条直线上发生什么变化?</p>
<p>求解其增量F(N)&#x3D;F(N-1)+增量,一条直线最多与原先的直线相交也就是n-1个交点,把第N条直线分成n段,每一段把TA所在的区域一分为二,一共分成n段所以在原来的基础上增加n段.</p>
<p>初始状态:F(1)&#x3D;2;</p>
<p>状态转移方程:F(N)&#x3D;F(N-1)+N;</p>
<p>F(N)&#x3D;n(n+1)&#x2F;2+1;</p>
<h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2050">Problem - 2050</a></p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>按上面的来,列出F(N)&#x3D;F(N-1)+?的状态转移方程,不过需要注意的是,不要两条线段和起来看,一条一条看,会发现这样的规律:</p>
<p>一组不是有两条线段吗?注意到第一条线段把区域分成(2*n-1)段(n&gt;1)第二条也是但由于闭合一个区域所以区域数减1.</p>
<p>那么方程为F(N)&#x3D;F(N-1)+(2*N-1) *2-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(n - <span class="number">1</span>) + <span class="number">2</span> * (<span class="number">2</span>*n<span class="number">-1</span>)- <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="type">int</span> sum=<span class="built_in">func</span>(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题3-1"><a href="#例题3-1" class="headerlink" title="例题3"></a>例题3</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2046">Problem - 2046</a></p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>状态转移方程是?斐波那契数列,为什么?</p>
<p>不管有多少种方案,我总是可以按照右上角的这个格子铺设的方案来分类,对于右上角的这个格子来说要么被横着铺要么被竖着铺.</p>
<p>如果是竖着铺,就铺好了.前面相当于F(N-1)种铺法,如果是横着铺,右上角的两个格子相当是被占用了.就限定最后两列的铺设情况.前面N-2列的铺设情况就是F(N-2)加在一起就是F(N)&#x3D;F(N-1)+F(N-2)注意递归会超时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用递推过了.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="function">ll <span class="title">func</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll a1 = <span class="number">1</span>, a2 = <span class="number">2</span>, a3;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a3 = a1 + a2;</span><br><span class="line">            a1 = a2;</span><br><span class="line">            a2 = a3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        ll sum = <span class="built_in">func</span>(t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题4-1"><a href="#例题4-1" class="headerlink" title="例题4"></a>例题4</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1297">Problem - 1297</a></p>
<p>还是,我们有目的去分析,无论题目怎么变,我们仍然需要找到F(N)&#x3D;?的关系.我们仍然从最后开始.分按性别分为两种</p>
<p>1.如果最后一个是男生又可以分为两类,这时候就要看前N-1个合不合法.如果合法递归F(N-1)去做,不合法可能中间或者最后两个为男女+?但最后是男,怎么样都不行.为0.</p>
<p>2.如果最后一个是女生,那么倒数第二个必定是女生,前面N-2个继续按照先判断是否合法,如果合法.那么加两个女生必然合法.这时侯就递归到F(N-2)去,不合法如果是中间就不用考虑,但如果是….男女这样的末尾的非法,前面N-4个合法加上男女非法再加两个女合法所以F(N-4),</p>
<p>补充:抗不住,dp优化都抗不住n到1000开long double都不行只能一位一位存.</p>
<p>PS:大整数相加.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, j = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) sum += a[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) sum += b[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(sum % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">dp</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">precompute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="string">&quot;4&quot;</span>;</span><br><span class="line">    dp[<span class="number">4</span>] = <span class="string">&quot;7&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">add</span>(<span class="built_in">add</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]), dp[i - <span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">precompute</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">1000</span>) cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题5—嵌入式小车识路算法"><a href="#例题5—嵌入式小车识路算法" class="headerlink" title="例题5—嵌入式小车识路算法"></a>例题5—嵌入式小车识路算法</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2045">Problem - 2045</a></p>
<p>继续啊,遇到这样的问题,先看颜色,如果加难,n行m列k种颜色.回到此题:</p>
<p>相邻首尾不同色,那就分两种情况讨论:</p>
<p>1.倒数第二的颜色与首位的颜色不相同时且合法,此时只有一种选择递归F(N-1)</p>
<p>2.倒数第二的颜色与首位的颜色相同时,此时首位不合法其他不考虑,有两种选择,而且倒数第二种与第一个在一起时非法,剔除掉那么剩下(N-2)的就是合法的,所以有2*F(N-2).</p>
<p>F(N)&#x3D;F(N-1)+2*F(N-2);</p>
<p>注意!合法的数量例如这里的N-2才是我们接着递归的数!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="function">ll <span class="title">func</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">2</span> * dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        ll sum = <span class="built_in">func</span>(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>首先确认:能否容易得到初始状态的解?</p>
<p>然后假设:规模不大于N-1的初始状态已经得到解决.</p>
<p>然后,重点分析当规模扩大到N时,如何枚举出所有的情况,比较方便的判断是合法性和非法性,然后用子问题状态(F(1),F(2),,,F(N-1))表示出最终的状态(状态转移)</p>
<h1 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划(DP)"></a>动态规划(DP)</h1><h2 id="入门基础-3"><a href="#入门基础-3" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="思想和特点"><a href="#思想和特点" class="headerlink" title="思想和特点"></a>思想和特点</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>如果各个子问题不是独立的(即:重复的),不同的子问题的个数只是多项式量级(即:有限的),如果我们能够保存已经解决的子问题的答案(一般用数组),而在需要的时候再找出已经求得的答案,这样可以避免大量重复的计算.</p>
<h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><p>1.最优子结构(大问题的最优解一定包含子问题的最优解)</p>
<p>2.重叠子问题</p>
<p>3.无后效性(难点)</p>
<p>我先做2层数塔再做3层数塔再做4层数塔,当我做完大数塔以后不会反过来影响小数塔.</p>
<h3 id="DP初探"><a href="#DP初探" class="headerlink" title="DP初探"></a>DP初探</h3><h4 id="经典问题—数塔问题"><a href="#经典问题—数塔问题" class="headerlink" title="经典问题—数塔问题"></a>经典问题—数塔问题</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\个人博客\main\blog\blog\source\image\树塔问题-DP演示.png"></p>
<p>如上图所示的数塔,从顶部出发,在每一个节点可以选择向左或者是向右走,一直走到底层,要求找出一条路径,使得路径上的数值和最大.</p>
<p>那么路径的条数随着层数的变化呈指数级(2^n)增长.</p>
<p>那么肯定是不能用暴力去做的,问题出在哪里呢?比如9,12,10,2和9,12,10,18只有最后两个数是不一样的,其他是一样的,做了大量重复计算.</p>
<p>回到递推求解把大问题分解成子问题的思想,9要么往12要么往15走.把9右边那一列去掉,剩下的就是以12为顶的3层小数塔,同样的道理,如果把左边去掉得到的也是以15为底的3层小数塔.假设把两个小数塔的最优解解决,那么9只需要往最优解的方向走就行了.如果假设成立,那么问题就变得很简单了,就是一个二选一的问题本来求4层数塔的问题现在变成求两个三层数塔的问题,只要把三层数塔解决,四层数塔就可以得到解决了.怎么搞定3层数塔呢?按照之前的方法递归求两层数塔,这时就比较简单了比如最左边2层数塔{2,10,18}显然就是28.只要比较左右孩子哪个大哪个加上10(子节点)就行了.因为这里左边的小数塔和右边的小数塔都退化成一个节点,单个节点是可以直接比较的,所以两层数塔是很容易搞定的.观察就会发现几层数塔跟N是成正比的.</p>
<p>现在看看复杂度(1+2+3+4…N),O(N^2)</p>
<p>结论:</p>
<p>自顶向下的分析(规模大向规模小的分析),自底向上的计算(从小规模的问题先搞定,然后解决大规模的问题,大规模用到直接拿来用,逐步越算越大最后算到最初的问题).</p>
<p>为什么效率差了这么大呢?比如最左边2层数塔{2,10,18}.只要搞定最优解28,那么在求左边三层数塔时肯定会用到TA,另外的数塔也可以在更上一层的数塔中被重复利用.这个问题是一个重叠的子问题,可以被多个更大的子问题用到,只要算好得到结果,把TA保存起来以后,后面用到的就可以直接拿这个结果用,就可以确保这个数塔只计算一次,那么就减少了很多重复的运算.运算量大大降低</p>
<p>示例: [P1216 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1216">IOI 1994] 数字三角形 Number Triangles - 洛谷</a></p>
<p>代码示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一遍过!</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>][<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp1</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i - <span class="number">1</span>][j] = a[i<span class="number">-1</span>][j] + <span class="built_in">max</span>(a[i][j], a[i][j + <span class="number">1</span>]);<span class="comment">//dp核心,从后向前加上一层的值和下一层比较左右孩子哪个大哪个加上就行了.-_-</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp1</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="经典问题—最长有序子序列"><a href="#经典问题—最长有序子序列" class="headerlink" title="经典问题—最长有序子序列"></a>经典问题—最长有序子序列</h4><table>
<thead>
<tr>
<th align="center">I</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Num[I]</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">3</td>
<td align="center">6</td>
<td align="center">9</td>
</tr>
</tbody></table>
<h5 id="前置知识—序列"><a href="#前置知识—序列" class="headerlink" title="前置知识—序列"></a>前置知识—序列</h5><p>序列强调序值,保持原来顺序不变的一个数列,比如1,2,3是一个数列但是还是一个序列,但是1,2,3,4不是它的序列因为1,2,3,4改变了它原来的相对顺序,原来的相对顺序是1,4,2,3.比如1,2,3是一个递增的子序列,7,5,3是一个递减的子序列.不管递增还是递减都是有序的子序列.假设如题干.在这里是1,4,7,8,9是最长的子序列(不唯一).</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>把一个大问题分解成若干子问题这种思想,怎么分解?</p>
<p>如果分解的过程中子问题的数量是有限的,并且每个子问题都可以很容易地求出来,大问题也就解决了.</p>
<p>最长子序列的长度不管是多少,那么它最多可以分成N种子情况.因为子序列总会有结束的时候.</p>
<table>
<thead>
<tr>
<th align="center">F[I]</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
</table>
<p>假设是以1结束.因为子序列以它结束一定是用不到后面的,所以子序列的长度就是1,如果以4结束的话,4可以接在1的后面,可以得到14这个递增的子序列可以得到2,以7结束,7可以接在2的后面,也可以接在1的后面结果取最大3,只要每一个数字结束的情况都可以枚举出来.比如后面的2只能接在1的后面以此类推,依次保存需要的时候拿出来用就行.就可以把每个数作为结束的情况,它的子序列长度都可以求出来.最终这里面找一个最大的数发现5是最大就知道最长有序直线的线段长度就是5.</p>
<p>把一个规模是N的问题分成N个子问题按照规则(最长有序子序列的长度)比哪个字符结束.</p>
<p>好处:只要从前往后求,因为子序列的序列性求一个后面结束的元素,它用到的只可能是前面的.所以只要把前面的算出来,再算后面的时候用到前面这种小问题就可以直接拿过来用.这样就可以算出一每个字符结束的情况,那么TA的子序列长度再找MAX</p>
<p>复杂度O(N^2)</p>
<p>DP最基本的特征:利用现成的已有的结果成果,减少运算量.</p>
<p>示例:<a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1160">Problem - 1160</a></p>
<p>换了一下,变成最长下降子序列.体重从小到大排序,速度从大到小排序,再求最大递减子序列.</p>
<p>思路是知道了,但是代码实现不来啊o(╥﹏╥)o只能找deepseek帮忙修改了.就是这两个没写好..o(╥﹏╥)o</p>
<ol>
<li>动态规划:遍历每个老鼠,对于每个老鼠,检查前面所有满足条件的老鼠(体重更小且速度更大),更新最长子序列长度和前驱节点.</li>
<li>路径回溯:从最长子序列的末尾开始回溯,找到所有节点并逆序输出,得到正确的结果.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pos</span> &#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> pos&amp; a, <span class="type">const</span> pos&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.w == b.w) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.s &gt; b.s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pos&gt; data;</span><br><span class="line">    <span class="type">int</span> w, s;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;w, &amp;s) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(&#123; w,s,index &#125;);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n, <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">prev</span>(n, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j].w&lt;data[i].w &amp;&amp; data[j].s&gt;data[i].s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    prev[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; max_len)</span><br><span class="line">        &#123;</span><br><span class="line">            max_len = dp[i];</span><br><span class="line">            end_idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;<span class="comment">//路径回溯</span></span><br><span class="line">    <span class="keyword">while</span> (end_idx != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(data[end_idx].index);</span><br><span class="line">        end_idx = prev[end_idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max_len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : path)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="经典问题–最少拦截系统"><a href="#经典问题–最少拦截系统" class="headerlink" title="经典问题–最少拦截系统"></a>经典问题–最少拦截系统</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1257">Problem - 1257</a></p>
<p>可以改成:求一套拦截系统最多可以拦截几个来袭的导弹?跟上面一样,最长上升子序列的问题.</p>
<h5 id="前置知识—Dilworth定理"><a href="#前置知识—Dilworth定理" class="headerlink" title="前置知识—Dilworth定理"></a>前置知识—Dilworth定理</h5><p>对于一个偏序集,最少链的划分等于最长反链的长度.</p>
<p>结论:求最长上升子序列的长度.</p>
<p>参考资料:</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/zkcos23t">Dilworth 学习笔记 - 洛谷专栏</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/flipped/p/5009943.html">【codevs1044】导弹拦截问题与Dilworth定理 - 水郁 - 博客园</a></p>
<h5 id="问题本质"><a href="#问题本质" class="headerlink" title="问题本质"></a>问题本质</h5><p>求的是最少分几个”最长不上升子序列”,即:几条不上升”链条”如何求?就是最长下降子序列一共有几个?本质上就是求最长上升子序列的长度.所以就可以求一套最长上升子序列的长度就行了.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">h</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; h[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (h[j] &lt; h[i] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; max_len)</span><br><span class="line">            &#123;</span><br><span class="line">                max_len = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; max_len &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><h5 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1"></a>例题1</h5><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1176">Problem - 1176</a></p>
<p>很经典的一道三叉树DP,这道题DP层数的划分,三叉树的层数是时间,三叉表示三个状态(静止,往左走,往右走).然后还要注意下边界的情况就是到0或者10时只有两种选择.按上面的思路.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100500</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,a,b,x,t;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">		b=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123; </span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;t);<span class="comment">//坐标 时间 </span></span><br><span class="line">			dp[t][x]++;<span class="comment">//记录同一个时间点馅饼掉了多少个 </span></span><br><span class="line">			b=<span class="built_in">max</span>(b,t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//printf(&quot;%d\n&quot;,b);</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=b<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//时间限制</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10</span>;j++)<span class="comment">//步数限制 </span></span><br><span class="line">				dp[i][j]=<span class="built_in">max</span>(<span class="built_in">max</span>(dp[i<span class="number">+1</span>][j<span class="number">+1</span>],dp[i<span class="number">+1</span>][j<span class="number">-1</span>]),dp[i<span class="number">+1</span>][j])+dp[i][j];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">0</span>][<span class="number">5</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题2-2"><a href="#例题2-2" class="headerlink" title="例题2"></a>例题2</h5><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1421">Problem - 1421</a></p>
<h6 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h6><p>第一感觉:根据题目,每次提到的两个物品重量差越小越好,是否每次提的物品一定是重量相同的物品呢?</p>
<p>证明:假设四个从小到大的数:a,b,c,d,只需要证明以下表达式即可:<br>(a-b)^2+(c-d)^2&lt;(a-c)^2+(b-d)^2</p>
<p>(a-b)^2+(c-d)^2&lt;(a-d)^2+(b-c)^2</p>
<p>搬的时候一定要原始相邻.</p>
<p>从最简单的情况考虑:</p>
<p>2个物品选一对,结论显然</p>
<p>4个呢?抓住搬的时候一定要原始相邻这个特征.也就是min((x4-x3)^2,f(3,1)),相邻的,去掉第四个,前三个的最小值做一个min.</p>
<p>推广到n,min((Xn-X(n-1)^2),f(n-1,1))开一个二维数组存起来.</p>
<p>继续推广,n个物品选2对?先看4个物品搬2趟,显然已经证明了没有选择.1,2搬一趟,3,4搬一趟.前5个首先分要么包含第5个物品,要么不包含,不包含就是f(4,2),包含其中一项就是(x5-x4)的平方,另外一趟只能是前三个物品中选2个f(3,1),所以总的就是f(4,2)+min(((X5-X4)^2),f(3,1))</p>
<p>到k趟也是分两种情况看,包含和不包含来分类讨论.</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">2005</span>][<span class="number">1005</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = (y - x) * (y - x);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _dp(<span class="type">int</span> n, <span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * j &gt; i) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">// 不选当前对(第i-1和i-2号物品)前i-1个物品已经选出j对,第i个物品不参与配对</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; j &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">2</span>][j - <span class="number">1</span>] + <span class="built_in">func</span>(h[i - <span class="number">1</span>], h[i - <span class="number">2</span>]));<span class="comment">//强制选第i-1和i-2号物品作为最后一对</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][k]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">        h.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; h[i];</span><br><span class="line">        <span class="built_in">sort</span>(h.<span class="built_in">begin</span>(), h.<span class="built_in">end</span>());</span><br><span class="line">        _dp(n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这里又被输入坑了一把.在之前又恶补下.</p>
<p>我的输入遇到下面就不行了.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>       <span class="comment">// 2组测试数据</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span>     <span class="comment">// 第1组</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span>     <span class="comment">// 第2组</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">10</span></span><br><span class="line">循环读取 <span class="number">4</span></span><br><span class="line">继续读取 <span class="number">20</span> 正确 </span><br><span class="line">单次读取 <span class="number">4</span>	错误 (缺少第<span class="number">2</span>组输出)</span><br><span class="line">直接WA!</span><br></pre></td></tr></table></figure>



<h2 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h2><h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><p>给你一个容量为V的背包和若干种物品,在一定条件的限制下(每种物品都占用一定容量),问最多能放进多少价值的物品?</p>
<p>这是最经典的DP问题,背包的每个容量就是状态.</p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>比如:有N件物品和一个容量为V的背包,第i件物品的费用是c[i],价值是w[i].求解将哪些物品装入背包中可使价值总和最大.</p>
<p>每种物品仅有一件,可以选择放1或者是不放0.</p>
<p><strong>思考</strong>:每个物品都有可能被选中的情况下,如何构造”子问题”?</p>
<p>然后又回到上面基础的DP方式:通过子问题推出我们想要的大问题.</p>
<p><strong>无序变成有序的方法</strong>:依次考虑前1,前2,前3…前i个物品.让无序的物品变成有序.</p>
<p><strong>状态定义</strong>(二维): f[i] [v]表示前i件物品选出若干件放入一个容量为v的背包可以获得的最大价值.注意这里的前i件物品并不是要求全部放进去的,只是说考虑了前i件物品,选出若干件(0,1,2一直到i件放入一个容量为V的背包看一下求得的最大价值多少)</p>
<p>为什么要定义这个状态,刚才说用背包容量作为作为背包问题的状态,为什么用V作为状态的一维呢?当选择一个物品放入一个容量为V的背包里面那么得到它的价值剩余的空间是一个子问题,所以最终问题的最优解f [i] [v]不仅和当前物品的价值有关系还合剩余物品能够装多少价值有关系.</p>
<h5 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h5><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2602">Problem - 2602</a></p>
<table>
<thead>
<tr>
<th align="center">(V,C)</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">(1,5)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">(2,4)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">(3,3)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">(4,2)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">9</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">(5,1)</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">14</td>
</tr>
</tbody></table>
<h6 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h6><p>先看初始化.当不考虑任何物品也就是考虑前0个物品时,不管背包体积多少,最优解只能是0.现在考虑第一个物品,TA的价值是以(体积,事物)</p>
<p>这样排的.求解的时候一定要从小往大求.</p>
<p>为什么一定要从小往大求,为什么先考虑前一个,前两个,前三个物品,为什么体积是0,1,2,3从小往大求,为什么不管是数据的规模还是体积都是从小往大求?DP基础思路.</p>
<p>不管是多少,其实考虑两种情况就行了.最优解要么包含当前这个物品,要么不包含.如果包含当前这个物品是可以放得下的.包含当前这个物品得到它的价值,如果还有剩余的空间只能从以前的物品里选.操作完后考虑前2个物品(举例),如果不考虑当前物品,上一趟结果已经算好了,可以直接拿过来用,如果考虑当前物品判断是否会不会放的下.</p>
<p>有一点像回溯.比如我拿9举个例子.</p>
<p>当V&#x3D;9时0就不用考虑了把(1,5)放进来,剩余V&#x3D;4,就相当于dp[0] [9]&#x3D;1(这里是(1,5))+dp[0] [4]因为dp[0] [4]之前求个,直接用小结果推出大结果.接下来回溯到dp[0] [9]继续操作,dp[0] [9]&#x3D;2+dp[0] [5],dp[0] [9]&#x3D;3+dp[0] [6],dp[0] [9]&#x3D;4+dp[0] [7],dp[0] [9]&#x3D;5+dp[0] [8].对上面求最大值就行.</p>
<p>还是没有理清楚本质</p>
<h6 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h6><p>当前最优解,要么包含第i种物品,要么不包含第i种物品.</p>
<p>DP[i] [j]表示前i个物品,背包容量为j的最优值.</p>
<p><strong>状态转移方程</strong>:DP[i] [j]&#x3D;max(DP[i] [j],DP[i-1] [j-v[i]]+w[i])&#x2F;&#x2F;子问题分解</p>
<p>时间复杂度:N*V</p>
<p>空间复杂度:N*V—优化只用一维数组DP[j]来实现.</p>
<table>
<thead>
<tr>
<th align="center">[V,C]</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>比如还是这5个物品.(1,5)(2,4)(3,3)(4,2)(5,1),开始选(1,5)但到后面10的时候会发现C&#x3D;2,也就是说(1,5)被选了2次,怎样解决.</p>
<p>解法:从后面遍历.只用一维数组去做,并且不希望重复被选.一开始全部初始化成0,当去处理后面的这个时候,要么包含当前这个物品,要么不包含,如果不包含就是以前的解,就不用做了.如果包含,得到当前物品的价值,剩余的空间.因为是从后往前做的,剩余的空间一定比本身小,还没更新就是上一堂的结果.所以循坏的顺序优化可以降低到一维.</p>
<h6 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n <span class="comment">//所有物品</span></span><br><span class="line">    <span class="keyword">for</span> j=V to v[i] <span class="comment">//为何没必要循环到0?比v[i]小的话,当前这个物品肯定装不下,肯定选不了当前物品,根本就不需要做</span></span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">空间成功优化到一维V</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="代码-二维dp"><a href="#代码-二维dp" class="headerlink" title="代码(二维dp)"></a>代码(二维dp)</h6><h6 id="代码-一维dp"><a href="#代码-一维dp" class="headerlink" title="代码(一维dp)"></a>代码(一维dp)</h6><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>一个背包可以取无数个.</p>
<p>可否转化为01背包问题?从前向后遍历</p>
<h4 id="深度思考"><a href="#深度思考" class="headerlink" title="深度思考"></a>深度思考</h4><p>这类能不能达到的问题应该怎么实现?也就是假设要求不仅背包要求最优解而且还希望有个前提,背包必须要装满(不能有空间剩余).求的是空间不能剩余的前提下,背包最多能得到多少价值.</p>
<p>现在要求必须装满,不满不算的前提下,当背包体积是一到十并且没有任何东西的时候,最优解是不存在的,假设用-1代表无解,所以这个时候就要全部初始化为-1,但背包体积是0的时候(相当于没装东西是满的).后面考虑第一个物品(1,5)当背包体积是0的时候,这个物品放不进去,得到的还是0.当背包体积是1的时候,如果不放这个物品是无解的,如果要放的这个物品放不下,所以最终解还是无解.以此类推,当体积是6的时候,是-1.如果不考虑当前物品本身就是-1,如果考虑当前物品得到TA的价值1但是剩余的一个空间在上一趟是-1,剩余的空间没办法用了.还是装不满.继续按刚才去做,如果剩余的空间是-1就是无解的.这个时候只要初始化改变,做个判断是不是无解就行了.</p>
<table>
<thead>
<tr>
<th align="center">(V,C)</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">(1,5)</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">1</td>
<td align="center">-1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">(2,4)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">(3,3)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">(4,2)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">9</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">(5,1)</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">14</td>
</tr>
</tbody></table>
<h4 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h4><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>介于01背包和完全背包的一种情况.一种物品有C个(既不是固定的1个也不是无数个)</p>
<p>朴素想法:暴力转化为01背包,但是如果有物品体积特别小,背包体积特别大,那一个物品就占用太多行,需要优化.</p>
<h4 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h4><p>类似于快速幂,运用二进制,进行物品拆分,转化为01背包</p>
<p>比如:13个相同的物品可以分成4组(1,2,4,6)</p>
<p>用这4组可以组成任意一个1~13之间的数!</p>
<p>原理:一个数总可以用2^k来表示而且总和是13,所以不会超过13的数.</p>
<p>所以可将一种有C个的物品拆分成:</p>
<p>1,2,4…,2^(k-1),C-(2^k-1)</p>
<p>然后进行01背包.</p>
<h5 id="优化部分参考代码"><a href="#优化部分参考代码" class="headerlink" title="优化部分参考代码"></a>优化部分参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x&gt;=t)<span class="comment">//x是原来题目给的物品的数量,t是我们通过类似快速幂将物品一个循环一个循环捆绑更多的数量.</span></span><br><span class="line">&#123;</span><br><span class="line">    v[cnt]=a*t;<span class="comment">//a相当于一件物品的价值</span></span><br><span class="line">    c[cnt++]=b*t;<span class="comment">//b相当于一件物品的体积,cnt++表明下一个物品(跌价,捆绑)就存放在第二个位置</span></span><br><span class="line">    x-=t;<span class="comment">//一个或是多个物品捆绑成的&quot;一个&quot;的数量减去.</span></span><br><span class="line">    t&lt;&lt;=<span class="number">1</span>;<span class="comment">//左移一位相当于乘2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x)<span class="comment">//如果给的物品数量还有剩余,就将剩余的物品捆绑在一起</span></span><br><span class="line">&#123;</span><br><span class="line">    v[cnt]=a*x;<span class="comment">//预处理,把物品处理好</span></span><br><span class="line">    c[cnt++]=b*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h4><h3 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>对于每件物品,具有两种不同的费用;选择这件物品必须同时付出这两种代价;对于每种代价都有一个可付出的MAX(比如,背包容量,最大承重),求怎样选择物品可以得到最大价值.</p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>设第i件物品所需的两种代价分别是a[i]和b[i],两种代价可付出的最大值(比如体积和重量)分别为V和U,物品的价值为w[i].</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>费用加了<strong>一维</strong>,只需状态也加<strong>一维</strong>即可!(n维也是)</p>
<p>设f[i] [v] [u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值,状态转移方程为:</p>
<p>f[i] [v] [u]&#x3D;max(f[i-1] [v] [u],f[i-1] [v-a[i]] [u-b[i]+w[i]] )</p>
<h4 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h4><h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h1><p>计算机挑战赛遇到了,大整数相加,相乘.实际上都属于高精度算法一类的.在之后的比赛中对于范围的控制尤为重要.<br>下面更新大整数的高精度算法.</p>
<h2 id="1-大整数相加"><a href="#1-大整数相加" class="headerlink" title="1.大整数相加"></a>1.大整数相加</h2><p>基本逻辑:对于过长的数据,我们采用数组的形式来处理.因此我们建立两个存放加数的数组和一个存放和的数组.对两个加数数组的每一位相加并进位后,便可获得最终得数,输出即可.</p>
<p>(1)我们引入两组数字:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> m[<span class="number">500</span>],n[<span class="number">500</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br></pre></td></tr></table></figure>
<hr>
<p>用char的原因:(1)我们在后面要使用strlen函数去获取字符串长度.<br>                     (2)方便输入.<br>(2)将每一位”char”型数字逆序存放进整型数组</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">501</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//a,b数组存放加数,c用于存放和</span></span><br><span class="line"><span class="type">int</span> lena，lenb；</span><br><span class="line">lena=<span class="built_in">strlen</span>(m);<span class="comment">//strlen函数是获取数组长度的,如abc的长度为3</span></span><br><span class="line">lenb=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lena;i++)</span><br><span class="line">&#123;</span><br><span class="line">	a[lena<span class="number">-1</span>-i]=m[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">/*这一步是为了将&#x27;char&#x27;类型的数组逆序转存为便于计算的‘int’类型</span></span><br><span class="line"><span class="comment">逆序转存:更便于我们后面的进位,比如c[k]大于10我们向c[k+1]进位,逻辑上比正序通顺.*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lenb;i++)</span><br><span class="line">&#123;</span><br><span class="line">	b[lenb-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>(3)计算并处理进位</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> la,lb,lmax;<span class="comment">//la和lb表示数组长度，lmax是a和b中长度较大的那个数字的长度</span></span><br><span class="line"><span class="keyword">if</span>(la&gt;lb)</span><br><span class="line">&#123;</span><br><span class="line">	lmax=la;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	lmax=lb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lmax;i++)<span class="comment">//i从1循环到lmax</span></span><br><span class="line">&#123;</span><br><span class="line">	c[i]+=a[i]+b[i];<span class="comment">//先将a的第i位和b的第i位相加，即加数相加</span></span><br><span class="line">	<span class="keyword">if</span>(c[i]&gt;=<span class="number">10</span>)<span class="comment">//当c的某一位大于10，进位</span></span><br><span class="line">	&#123;</span><br><span class="line">		c[i<span class="number">+1</span>]+=c[i]/<span class="number">10</span>;<span class="comment">//c[i+1]进c[i]的十位</span></span><br><span class="line">		c[i]=c[i]%<span class="number">10</span>;<span class="comment">//保留c[i]的个位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[lmax]&gt;<span class="number">0</span>)<span class="comment">//这一步来判断两个加数相加后最大位数是否发生改变</span></span><br><span class="line">             <span class="comment">//比如1和10相加最大位数还是2，但1和99相加最大位数就变为了3</span></span><br><span class="line">&#123;</span><br><span class="line">	lmax++;<span class="comment">//如果比最大加数位数还大一位的数字不为零，那么最大位数加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>(4) 逆序输出和</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=lmax<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>完整代码:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span><span class="comment">//用的strlen源自于这个头文件</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">500</span>],n[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">501</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> la,lb,lmax;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br><span class="line">la=<span class="built_in">strlen</span>(m);</span><br><span class="line">lb=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">if</span>(la&gt;lb)</span><br><span class="line">&#123;</span><br><span class="line">	lmax=la;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	lmax=lb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;la;i++)</span><br><span class="line">&#123;</span><br><span class="line">	a[la<span class="number">-1</span>-i]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lb;i++)</span><br><span class="line">&#123;</span><br><span class="line">	b[lb-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lmax;i++)</span><br><span class="line">&#123;</span><br><span class="line">	c[i]+=a[i]+b[i];</span><br><span class="line">	<span class="keyword">if</span>(c[i]&gt;=<span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i<span class="number">+1</span>]+=c[i]/<span class="number">10</span>;</span><br><span class="line">		c[i]=c[i]%<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[lmax]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	lmax++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=lmax<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="2-大整数相减"><a href="#2-大整数相减" class="headerlink" title="2.大整数相减"></a>2.大整数相减</h2><p>加法和减法其实并没有什么区别,但相对于加法,减法所涉及到的范围内更大.以下是易踩坑的地方:<br>1.为什么不能直接用int数组接收数据，而是要用字符串输入(对前面补充的细节)</p>
<p>错误地认为通过int数组输入时,会如同string类型一样,每个位置只有0~9.事实上,当我输入13时,接收到的并不是1,3.而是13.<br>因此必须先由字符串输入,再通过int数组接收.</p>
<p>2.被减数大于减数的情况和减数大于被减数的情况有什么不同</p>
<p>当被减数小于减数时应该倒过来:先换位被减数和减数,再正常计算后,前面加上”-“<br>因此必须比较被减数和减数的大小:<br>运用字符串比较大小:(精髓)由于字符串比较时,只会逐位比较,因此 9 &gt; 80???所以必须加上长度限制.</p>
<p>3.倒置后的消零处理</p>
<p>比如100000000-100000000时,未消去0则会输出000000000.<br>因此必须消去.</p>
<p>直接上题目吧!</p>
<p>题目描述<br>高精度减法。</p>
<p>输入格式<br>两个整数 a,b（第二个可能比第一个大）。</p>
<p>输出格式<br>结果（是负数要输出负号）。</p>
<p>输入输出样例<br>输入 </p>
<p>2<br>1<br>输出 </p>
<p>1<br>说明&#x2F;提示<br>20% 数据 a,b 在 long long 范围内;<br>100% 数据 0&lt;a,b≤10^10086.</p>
<p>代码如下:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line">string A, B;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000000</span>], b[<span class="number">1000000</span>], c[<span class="number">10000000</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line"><span class="comment">//首先要得到a，b的字符串长度</span></span><br><span class="line"><span class="type">int</span> len_a = <span class="number">0</span>, len_b = <span class="number">0</span>, len_max, temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; A[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">	len_a++;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; B[j] != <span class="string">&#x27;\0&#x27;</span>; j++)</span><br><span class="line">	len_b++;</span><br><span class="line"><span class="comment">//赋值int数组</span></span><br><span class="line"><span class="comment">/*然后将a，b的字符串分别进行倒序，方便向后一位借1：</span></span><br><span class="line"><span class="comment">例如：输入时是550和350，高位在前，倒序后为055和053，高位在后*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len_a; i++)</span><br><span class="line">	a[len_a - i - <span class="number">1</span>] = A[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len_b; j++)</span><br><span class="line">	b[len_b - j - <span class="number">1</span>] = B[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//进行高精度减法：1.先得到长的数字长度</span></span><br><span class="line">len_max = len_a &gt; len_b ? len_a : len_b;</span><br><span class="line"><span class="comment">//调试</span></span><br><span class="line"><span class="comment">/*for (i = 0; i &lt; len_max; i++)</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;a=&quot; &lt;&lt; *(a + i) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (j = 0; j &lt; len_max; j++)</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;b=&quot; &lt;&lt; *(b + j) &lt;&lt; endl;*/</span></span><br><span class="line"><span class="comment">//计算:先判断被减数和减数哪个大,减数大则要换位</span></span><br><span class="line"><span class="keyword">if</span> (A &lt; B &amp;&amp; len_a == len_b || len_a &lt; len_b) &#123; <span class="comment">//通过字符串比较大小，可以得知两个数字的大小</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len_max; i++) &#123;</span><br><span class="line">		c[i] = b[i] - a[i] + temp;<span class="comment">//temp为借位操作，当上一位小于0时</span></span><br><span class="line">		<span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			temp = <span class="number">-1</span>;</span><br><span class="line">			c[i] += <span class="number">10</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//temp一定等于-1</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">	<span class="comment">//还需要进行消零操作：有时需要的是1，而不是000001</span></span><br><span class="line">	<span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c[i] == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)<span class="comment">/*当最后一位为零时不可删除，其余前面的零删除，</span></span><br><span class="line"><span class="comment">		但是比如200-300=-100，其中后面的零不可以删除，所以选择缩短数列长度，</span></span><br><span class="line"><span class="comment">		如此只可能删除有效数字前面的零*/</span></span><br><span class="line">			len_max--;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		cout &lt;&lt; c[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len_max; i++) &#123;</span><br><span class="line">		c[i] = a[i] - b[i] + temp;<span class="comment">//temp为借位操作，当上一位小于0时</span></span><br><span class="line">		<span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			temp = <span class="number">-1</span>;</span><br><span class="line">			c[i] += <span class="number">10</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//temp一定等于0</span></span><br><span class="line">	<span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c[i] == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)<span class="comment">//同样进行消零操作</span></span><br><span class="line">			len_max--;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = len_max - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">		cout &lt;&lt; c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-大整数乘法"><a href="#3-大整数乘法" class="headerlink" title="3.大整数乘法"></a>3.大整数乘法</h2><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)我们引入两组数字:</span><br><span class="line">  </span><br><span class="line"><span class="type">char</span> m[<span class="number">2000</span>],n[<span class="number">2000</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>)将每一位<span class="string">&quot;char&quot;</span>型数字逆序存放进整型数组</span><br><span class="line"><span class="type">int</span> a[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> lm,ln;<span class="comment">//lm、ln分别表示m和n的位数</span></span><br><span class="line">lm=<span class="built_in">strlen</span>(m);<span class="comment">//strlen函数是获取数组长度的,如abc的长度为3</span></span><br><span class="line">ln=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[lm-i<span class="number">-1</span>]=m[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">/*这一步是为了将&#x27;char&#x27;类型的数组逆序转存为便于计算的&#x27;int&#x27;类型</span></span><br><span class="line"><span class="comment">逆序转存：更便于我们后面的进位,比如c[k]大于10我们向c[k+1]进位,逻辑上比正序通顺.*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ln;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[ln-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>)计算并处理进位</span><br><span class="line"></span><br><span class="line">乘法结果位数的三种情况:</span><br><span class="line"></span><br><span class="line">位数等于两乘数位数之和(如<span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span>).</span><br><span class="line">位数等于两位数的和减<span class="number">1</span>(如<span class="number">1</span>*<span class="number">9</span>=<span class="number">9.</span></span><br><span class="line">结果为<span class="number">0</span>(<span class="number">100</span>*<span class="number">0</span>=<span class="number">0</span>).</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;ln;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		k=i+j;</span><br><span class="line">		c[k]+=a[i]*b[j];</span><br><span class="line">		<span class="keyword">if</span>(c[k]&gt;=<span class="number">10</span>)<span class="comment">//保证数组中的数字都&lt;10</span></span><br><span class="line">		&#123;</span><br><span class="line">			c[k<span class="number">+1</span>]+=c[k]/<span class="number">10</span>;<span class="comment">//c[i+1]进c[i]的十位</span></span><br><span class="line">			c[k]%=<span class="number">10</span>;<span class="comment">//保留c[i]的个位</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>(5)逆序输出积</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=lc<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>(6)完整代码:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">2000</span>],n[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">4000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="type">int</span> lm,ln,lc;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;n);</span><br><span class="line">lm=<span class="built_in">strlen</span>(m);</span><br><span class="line">ln=<span class="built_in">strlen</span>(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">	a[lm-i<span class="number">-1</span>]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ln;i++)</span><br><span class="line">&#123;</span><br><span class="line">	b[ln-i<span class="number">-1</span>]=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;ln;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		k=i+j;</span><br><span class="line">		c[k]+=a[i]*b[j];</span><br><span class="line">		<span class="keyword">if</span>(c[k]&gt;=<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			c[k<span class="number">+1</span>]+=c[k]/<span class="number">10</span>;</span><br><span class="line">			c[k]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[lm+ln<span class="number">-1</span>]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	lc=lm+ln;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	lc=lm+ln<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c[lc<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;lc&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	lc--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=lc<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-大整数相除"><a href="#4-大整数相除" class="headerlink" title="4.大整数相除"></a>4.大整数相除</h2><p>核心逻辑——逐位试商法：</p>
<p>总结:从第一位开始试商,除不下就乘10,除得下相处后余数乘10在加上后一位,逐位顺过去,直到最后一位.</p>
<p>(1)我们引入两组数字:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> m[<span class="number">5000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,rem=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,m);<span class="comment">//除数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);<span class="comment">//低精度的被除数V</span></span><br></pre></td></tr></table></figure>
<hr>
<p>(2)将字符数组m转为整形(这里不用逆序,原因是除法不用处理进位)</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lm;<span class="comment">//数组m的长度</span></span><br><span class="line">lm=<span class="built_in">strlen</span>(m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>(3)逐位试商</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)<span class="comment">//lm是被除数长度，从第一位试到最后一位</span></span><br><span class="line">&#123;</span><br><span class="line">	c[i]=(rem*<span class="number">10</span>+a[i])/n;<span class="comment">//rem为余数</span></span><br><span class="line">	rem=(rem*<span class="number">10</span>+a[i])%n;<span class="comment">//不理解的看上面核心思想部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>(4)删除前导0</p>
<p>和之前的都不一样了,因为之前是逆序的,删除最后一位即可.这个是顺序,代码如下:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(c[<span class="number">0</span>]==<span class="number">0</span>)<span class="comment">//当第一位为0时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)<span class="comment">//将每一位数字前移，第一位数字数据丢失</span></span><br><span class="line">&#123;</span><br><span class="line">	c[i]=c[i<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line">lm--;<span class="comment">//第一位删掉了，因此长度也-1</span></span><br><span class="line"><span class="keyword">if</span>(lm&lt;=<span class="number">0</span>)<span class="comment">//如果总长度小于等于0，直接输出0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>(5)顺序输出</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>(6)完整代码:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> m[<span class="number">5000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,rem=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5000</span>],c[<span class="number">5000</span>];</span><br><span class="line"><span class="type">int</span> lm,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">lm=<span class="built_in">strlen</span>(m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">	a[i]=m[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">	c[i]=(rem*<span class="number">10</span>+a[i])/n;</span><br><span class="line">	rem=(rem*<span class="number">10</span>+a[i])%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i]=c[i<span class="number">+1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	lm--;</span><br><span class="line">	<span class="keyword">if</span>(lm&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lm;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-高精度阶乘"><a href="#5-高精度阶乘" class="headerlink" title="5.高精度阶乘"></a>5.高精度阶乘</h2><p>与乘法类似:</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h 250000</span></span><br><span class="line"><span class="type">char</span> print[h] = &#123; <span class="string">&#x27;1&#x27;</span> &#125;;</span><br><span class="line"><span class="type">int</span> num1[h] = &#123; <span class="number">0</span> &#125;, num2[h] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans[h] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> len1 = <span class="number">0</span>, sumlen,k = <span class="number">0</span>;</span><br><span class="line">len1 = <span class="built_in">strlen</span>(print);</span><br><span class="line"><span class="comment">//反转写入数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)num1[k++] = (print[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//将因数拆分反向装入数组</span></span><br><span class="line"><span class="keyword">while</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">	num2[k++] = n % <span class="number">10</span>;</span><br><span class="line">	n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟乘法竖式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[j + i] += num1[i] * num2[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">sumlen = len1 + k;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//进位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sumlen; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ans[i] &gt;= <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">		ans[i] = ans[i] % <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转写入字符串</span></span><br><span class="line"><span class="keyword">while</span> (!ans[sumlen])sumlen--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sumlen; i &gt;= <span class="number">0</span>; i--)print[k++] = ans[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fact</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; print;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="组合博弈-Simple-Game-Theory"><a href="#组合博弈-Simple-Game-Theory" class="headerlink" title="组合博弈(Simple Game Theory)"></a>组合博弈(Simple Game Theory)</h1><h2 id="入门基础-4"><a href="#入门基础-4" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="简单取子游戏-组合游戏的一种"><a href="#简单取子游戏-组合游戏的一种" class="headerlink" title="简单取子游戏(组合游戏的一种)"></a>简单取子游戏(组合游戏的一种)</h3><h4 id="简单含义-组合游戏的定义"><a href="#简单含义-组合游戏的定义" class="headerlink" title="简单含义(组合游戏的定义)"></a>简单含义(组合游戏的定义)</h4><p>1.有两个玩家</p>
<p>2.游戏的操作状态是一个有限的集合(比如:限定大小的棋盘)</p>
<p>3.游戏双方轮流操作</p>
<p>4.双方的每次操作必须符合游戏规定</p>
<p>5.当一方不能将游戏继续进行的时候,游戏结束,同时对方为获胜方.</p>
<p>6.无论如何操作,游戏总能在有限次操作后结束.</p>
<h4 id="必败点和必胜点-P点-N点"><a href="#必败点和必胜点-P点-N点" class="headerlink" title="必败点和必胜点(P点&amp;N点)"></a>必败点和必胜点(P点&amp;N点)</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>必败点(P点):前一个选手(Previous player)将取胜的位置称为必败点.</p>
<p>必胜点(N点):下一个选手(Next player)将取胜的位置称为必胜点.</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>(1)所有终结点是必败点(P点)</p>
<p>什么是终结点?也就是说如果在一个状态谁都进行不下去了,显然终结点是必败点并且终结点不止一个.</p>
<p>比如23张扑克牌每人只能取2~3张,这时候0或者是1是终结点.</p>
<p>(2)从任何必胜点(N点)操作,至少有一种方法可以进入必败点(P点)</p>
<p>(3)无论怎么操作,从必败点(P点)都只能进入必胜点(N点)</p>
<h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><p>1.将所有终结位置标记位必败点(P点)</p>
<p>2.将所有一步操作能进入必败点(P点)的位置标记为必胜点(N点)</p>
<p>3.如果从某个点开始的所有一步操作都只能进入必胜点(N点),则将该点标记为必败点(P点)</p>
<p>4.如果在3末未能找到新的必败点(P点),则算法终止,否则,返回到步骤2.</p>
<h3 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h3><h4 id="引入—Nim-Sum"><a href="#引入—Nim-Sum" class="headerlink" title="引入—Nim-Sum"></a>引入—Nim-Sum</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1850">Problem - 1850</a></p>
<p>定义:假设(Xm…X0)(2)和(Ym…Y0)(2)的nim-sum是(Zm…Z0)(2)则我们表示成:<br>(Xm…X0)(2)^(Ym…Y0)(2)&#x3D;(Zm…Z0)(2)</p>
<p>其中,Zk&#x3D;Xk+Yk(mod 2)(k&#x3D;0..m)</p>
<h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>对于nim游戏的某个位置(x1,x2,x3)当且仅当TA各部分的nim-sum等于0时(即x1^x2^x3&#x3D;0)则当前位于必败点</p>
<p>其他情况都是必胜点.</p>
<p>定理1也适用于更多堆的情况</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>(1)根据定理1,怎么判断某个游戏的先手是输还是赢?</p>
<p>只要把这几个数进行按位异或运算,只要把所有的数按位异或加在一起,最后看结果是0还是非0就可以直接判断出先手是输还是赢.</p>
<p>(2)对于必胜点,任何判断有几种可行的操作方案?</p>
<p>比如5,7,9</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">^(S)</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>结果取决于最前面的这个1对于的这一列,第一列只有1个1只有一种走法,只能把这个一变成0.</p>
<p>主要就是找这样的数,有一种方法A,B,C异或的结果假设放到S里面,把S和上面的A,B,C分别进行异或,前两个一定变大,后一个一定变小,统计变小的个数就行了.</p>
<h4 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1848">Problem - 1848</a></p>
<h3 id="组合博弈的状态转移图以及S级函数"><a href="#组合博弈的状态转移图以及S级函数" class="headerlink" title="组合博弈的状态转移图以及S级函数"></a>组合博弈的状态转移图以及S级函数</h3><h4 id="基本含义-1"><a href="#基本含义-1" class="headerlink" title="基本含义"></a>基本含义</h4><h5 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h5><p>sg(x)&#x3D;min{n&gt;&#x3D;0 :n&lt;&gt;sg(y) for y属于F(X)}&#x2F;&#x2F;递归的定义</p>
<p>也就是说,X节点的SG值是去除X的后继节点的SG值后的最小的非负整数.</p>
<p>简单来说,SG函数是一个最小的非负整数且不等于y的X极值,y是什么?y是X的后继.</p>
<p>下面举例:</p>
<p>什么是游戏的状态转移图?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\个人博客\main\blog\blog\source\image\状态转移图---SG函数演示.png"></p>
<p>根据定义,每个节点的SG值是和TA后继节点的SG值是有关联的,注意,这里说的后继都是直接后继(一步可以走到的位置)5可以一步走到3或者4,2.如果要求5的SG值必须知道2,3,4的SG值这三个不知道继续递归下去.求4必须知道3,2,1的,求3必须知道2,1,0的,求2必须知道1,0的,求1必须知道0的,求0的发现TA没有后继,因为0没有后继,所以限定条件不起作用了.所以0的SG值就是0,再来看1的SG值,后继节点0去除,最小SG值不等于0,所以1的SG值就是1.同样2的SG值去掉0和1就剩本身2.同理3的SG值是3.4的SG值去掉1,2,3后继后0并没有被去掉所以是0.5的SG值是1.</p>
<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><p>必败点:当节点x的 sg(x)&#x3D;0</p>
<p>必胜点:当节点x的 sg(x)&gt;0</p>
<p>证明:根据定义它是没有后继的,它的SG值一定是0和结论一致,再来看如果一个点能一步以内走到必败点,TA的后继就是有SG是0的点,那么TA本身就不可能是0了.如果从一个点出发TA的后继都是非0的,那么根据定义TA只能是0.</p>
<h4 id="组合游戏的并"><a href="#组合游戏的并" class="headerlink" title="组合游戏的并"></a>组合游戏的并</h4><p>一个大游戏是由多个小游戏组合而来的.</p>
<h5 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h5><p>如果图游戏由若干子图游戏Gi组成,即:</p>
<p>G&#x3D;G1+…+Gn,假设g1是G1(i&#x3D;1,…,n)的SG函数值,那么—-</p>
<p>图游戏G的SG值计算如下:</p>
<p>g(x1,…xn)&#x3D;g1(x1)^…^gn(xn)</p>
<p>证明跟上面一样.</p>
<h5 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h5><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1536">Problem - 1536</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记忆化DFS求SG值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="type">int</span> k, a[<span class="number">100</span>], f[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, t;</span><br><span class="line">    <span class="type">bool</span> g[<span class="number">101</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)<span class="comment">//对于每个规则分别枚举尝试</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = p - a[i];<span class="comment">//数量太少用不上直接跳出,</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//排序了没有排序continue</span></span><br><span class="line">        <span class="keyword">if</span> (f[t] == <span class="number">-1</span>)</span><br><span class="line">            f[t] = <span class="built_in">sg</span>(t);<span class="comment">//递归求每个状态</span></span><br><span class="line">        g[f[t]] = <span class="number">1</span>;<span class="comment">//把SG值作为下标对应的计数组里面的值设为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;; i++)<span class="comment">//从小找一个最小的非负整数并且找没有用过的如果后继用过标记为一了,这样找就可以找没有用过的,并且是从左往右找,所以找的是最小的后继没有用过的数.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!g[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, i, m, t, s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k), k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a, a + k);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));<span class="comment">//将SG值初始化为-1</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span> (n--)<span class="comment">//n组测试</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (m--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                <span class="keyword">if</span> (f[t] == <span class="number">-1</span>)</span><br><span class="line">                    f[t] = <span class="built_in">sg</span>(t);<span class="comment">//求出SG值</span></span><br><span class="line">                s = s ^ f[t];<span class="comment">//总游戏值相当于把所有子游戏的值异构起来</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;W&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h1><h2 id="入门基础-5"><a href="#入门基础-5" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="预备知识—二叉树的遍历"><a href="#预备知识—二叉树的遍历" class="headerlink" title="预备知识—二叉树的遍历"></a>预备知识—二叉树的遍历</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BA%8C%E5%8F%89%E6%A0%91-DFS%E6%BC%94%E7%A4%BA.png"></p>
<p>本次DFS主要介绍3种二叉树的遍历方式</p>
<h4 id="先序遍历-根左右"><a href="#先序遍历-根左右" class="headerlink" title="先序遍历(根左右)"></a>先序遍历(根左右)</h4><p>此遍历方式先访问根–&gt;2,然后访问左(子树),最后访问右(子树).注意不是左右的端点!看上面那幅图我左边怎么实现?</p>
<p>用递归的思想.</p>
<p>上图结果 2 7 1 6 5 3 8 9 4</p>
<h4 id="中序遍历-左根右"><a href="#中序遍历-左根右" class="headerlink" title="中序遍历(左根右)"></a>中序遍历(左根右)</h4><p>此遍历方式先访问左(子树),中间访问根,最后访问右(子树).注意不是左右的端点!看上面那幅图我左边怎么实现?</p>
<p>用递归的思想.</p>
<p>上图结果 1 7 5 6 3 2 8 4 9</p>
<p>这需要注意一下8 4 9 这个顺序.这么来的呢?(易错点)</p>
<p>访问完左子树,后先回溯到根节点2,j接着访问右子树,这时候的顺序是从以8为根节点去访问左子树,但图中并没有左子树,回溯到8这个根节点,接着继续以9为根节点,访问左子树并找到4,回溯访问根节点9,这时无右节点.综上 8 4 9.</p>
<h4 id="后序遍历-左右根"><a href="#后序遍历-左右根" class="headerlink" title="后序遍历(左右根)"></a>后序遍历(左右根)</h4><p>此遍历方式先访问左(子树),然后访问右(子树).最后访问根.注意不是左右的端点!看上面那幅图我左边怎么实现?</p>
<p>用递归的思想.</p>
<p>上图结果 1 5 3 6 7 4 9 8 2</p>
<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>1.给定先序和中序遍历的结果是否可以唯一确定这棵二叉树?</p>
<p>YES.</p>
<p>2&#x2F;(根节点) 7(左子树的根) 1 6 5 3 8(右子树的根) 9 4</p>
<p>1 7 5 6 3 &#x2F;2&#x2F; 8 4 9</p>
<p>先序遍历确定根节点,中序遍历确定左右子树.再递推.</p>
<p>2.给定中序和后序呢?</p>
<p>YES,同上.</p>
<p>3.给定先序和后序呢?</p>
<p>NO.不知道左右子树有几个.有歧义.</p>
<h3 id="DFS初探"><a href="#DFS初探" class="headerlink" title="DFS初探"></a>DFS初探</h3><p>本质上是递归,我们写递归的方式通常如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fibo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>||a==<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//先写出口(不需要递归的特殊情况)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//再写普通的情况(递归)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fibo</span>(a<span class="number">-1</span>)+<span class="built_in">fibo</span>(a<span class="number">-2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg1: <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1706">P1706 全排列问题 - 洛谷</a></p>
<p>问题的特征?</p>
<p>——-如果第1个数确定(比如1),剩余时间就是其余n-1个数的全排列;</p>
<p>枚举第一个数,第一个数的数量就是n.</p>
<p>——-如果前k个数已经排好,剩余的 问题就是其余n-k个数的全排列.</p>
<p>如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>], vis[<span class="number">10</span>];<span class="comment">//vis做标记,num保存一趟排列的结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span><span class="comment">//1.step含义?---遍历的深度,层数.接下来处理第step位.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step == n + <span class="number">1</span>)<span class="comment">//如果step==n+1说明前面n位都放好了.直接输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">0</span>)<span class="comment">//如果第i位的数没有用过,把i放到当前num数组里</span></span><br><span class="line">        &#123;</span><br><span class="line">            num[step] = i;</span><br><span class="line">            vis[i] = <span class="number">1</span>;<span class="comment">//用过了作标记</span></span><br><span class="line">            <span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//下面一行如果删除的结果是什么呢?</span></span><br><span class="line">            <span class="comment">//只输出一行</span></span><br><span class="line">            </span><br><span class="line">            vis[i] = <span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">            <span class="comment">//一次多层的枚举到结尾,进行vis的归零,方便下一次多层枚举的进行.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) == <span class="number">1</span>)<span class="comment">//读入n</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">//这里dfs最开始准备处理第一位</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基本模型-1"><a href="#基本模型-1" class="headerlink" title="基本模型"></a>基本模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    特殊情况处理(一般是结束递归的情况)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举当前每一种可能</span></span><br><span class="line">        在枚举的每一种可能中,递归<span class="built_in">dfs</span>(step<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="求一个图上最大联通子块-板子题-–示例代码"><a href="#求一个图上最大联通子块-板子题-–示例代码" class="headerlink" title="求一个图上最大联通子块(板子题)–示例代码"></a>求一个图上最大联通子块(板子题)–示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Map[<span class="number">52</span>][<span class="number">52</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> color[<span class="number">52</span>][<span class="number">52</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> maxoil = <span class="number">0</span>, oilnum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s_oil;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color[i][j] != <span class="number">0</span> || Map[i][j] != <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 已访问或非油田</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    color[i][j] = oilnum; <span class="comment">// 标记为当前油区编号</span></span><br><span class="line">    s_oil++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="type">int</span> ni = i + dir[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nj = j + dir[k][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 边界检查</span></span><br><span class="line">        <span class="keyword">if</span> (ni &lt; <span class="number">1</span> || ni &gt; N || nj &lt; <span class="number">1</span> || nj &gt; N) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ni, nj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        <span class="comment">// 重置状态变量</span></span><br><span class="line">        maxoil = <span class="number">0</span>;</span><br><span class="line">        oilnum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="built_in">sizeof</span>(color));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取地图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; Map[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[i][j] == <span class="number">0</span> &amp;&amp; Map[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    oilnum++; <span class="comment">// 新油区编号</span></span><br><span class="line">                    s_oil = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(i, j);</span><br><span class="line">                    maxoil = <span class="built_in">max</span>(maxoil, s_oil); <span class="comment">// 正确更新最大值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ans, maxoil);</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="基本剪枝"><a href="#基本剪枝" class="headerlink" title="基本剪枝"></a>基本剪枝</h3><h4 id="奇偶性剪枝"><a href="#奇偶性剪枝" class="headerlink" title="奇偶性剪枝"></a>奇偶性剪枝</h4><p>地图类DFS:</p>
<p>假设面积5*6,可以把MAP看成,那么一个地图每个点行号+列号如果是偶数用0来表示,如果是奇数用1来表示.</p>
<p>所以看下图,1的上下左右是0,0的上下左右是1.</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>有以下性质:<br>从为0的格子走一步,必然邹向为1的格子</p>
<p>从为1的格子走一步,必然邹向为0的格子</p>
<p>即:</p>
<p>0-&gt;1或1-&gt;0必然是奇数步</p>
<p>0-&gt;0或1-&gt;1必然是偶数步</p>
<p>结论:</p>
<p>当遇到从0走向0但是要求时间是奇数的或者从1走向0但是要求时间偶数的.</p>
<p>都可以直接判断不可达!</p>
<h2 id="二分匹配"><a href="#二分匹配" class="headerlink" title="二分匹配"></a>二分匹配</h2><h3 id="二分图及其应用-Bipartite-Graph"><a href="#二分图及其应用-Bipartite-Graph" class="headerlink" title="二分图及其应用(Bipartite Graph)"></a>二分图及其应用(Bipartite Graph)</h3><h4 id="基本含义-2"><a href="#基本含义-2" class="headerlink" title="基本含义"></a>基本含义</h4><p>如果一个图的顶点可以分成两个集合X和Y,图的所有边一定是有一个顶点属于集合X,另一个顶点属于Y,则称该图为”二分图”或者”二部图”.</p>
<h4 id="二分图的最大匹配—匈牙利算法"><a href="#二分图的最大匹配—匈牙利算法" class="headerlink" title="二分图的最大匹配—匈牙利算法"></a>二分图的最大匹配—匈牙利算法</h4><p>就是从如何一个集合,不管是X,Y.这是对称的,以X集合为例对每个元素做一趟DFS,这一趟DFS下来如果能成功,不成功也没有关系,继续下一个点.对每个点都这样去做尝试,那么最后的匹配数就是最大匹配数.</p>
<p>注:真正求二分图的最大匹配的题目很少,往往做一些简单的变化,比如—-</p>
<h5 id="参考源码-任务安排"><a href="#参考源码-任务安排" class="headerlink" title="参考源码(任务安排)"></a>参考源码(任务安排)</h5><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1150">Problem - 1150</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分匹配匈牙利算法DFS实现</span></span><br><span class="line"><span class="comment">//邻接矩阵形式</span></span><br><span class="line"><span class="comment">//uN是匹配左边的顶点数</span></span><br><span class="line"><span class="comment">//vN是匹配右边的顶点数</span></span><br><span class="line"><span class="comment">//优点:适用于稠密图,实现简洁易于理解</span></span><br><span class="line"><span class="comment">//时间复杂度O(VE)</span></span><br><span class="line"><span class="comment">//顶点编号是从0开始的</span></span><br><span class="line"><span class="comment">//调用:res=hungary();</span></span><br><span class="line"><span class="comment">//输出最大匹配数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> uN, vN;<span class="comment">//u,v的数目</span></span><br><span class="line"><span class="type">int</span> g[MAXN][MAXN];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> linker[MAXN];<span class="comment">//存右边点对象---存的值对应的是左边的对象</span></span><br><span class="line"><span class="type">bool</span> used[MAXN];<span class="comment">//右点访问否---就相当于vis</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; vN; v++)<span class="comment">//从u出发哪些点是有边的不知道必须全部遍历一遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[u][v] &amp;&amp; !used[v])<span class="comment">//如果u~v有一条边并且used[v]还没有处理过</span></span><br><span class="line">        &#123;</span><br><span class="line">            used[v] = <span class="literal">true</span>;<span class="comment">//做标记</span></span><br><span class="line">            <span class="keyword">if</span> (linker[v] == <span class="number">-1</span> || <span class="built_in">dfs</span>(linker[v]))<span class="comment">//如果当前还没有匹配且或者从左边的对象出发能够DFS成功的话也行.</span></span><br><span class="line">            &#123;</span><br><span class="line">                linker[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//这一句容易忘记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hungary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(linker, <span class="number">-1</span>, <span class="built_in">sizeof</span>(linker));<span class="comment">//0在原本题目中是存在的,我们需要的是不存在的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; uN; u++)<span class="comment">//做N趟的DFS且枚举是左边的点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="built_in">sizeof</span>(used));<span class="comment">//每一趟DFS之前都要去做初始化,下一趟DFS是一个重新的开始.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(u)) res++;<span class="comment">//DFS搜索的过程中成功了res++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;uN) == <span class="number">1</span> &amp;&amp; uN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;vN, &amp;k);</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="type">int</span> id, u,v;</span><br><span class="line">        <span class="keyword">while</span> (k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;id, &amp;u, &amp;v);</span><br><span class="line">            <span class="keyword">if</span> (u != <span class="number">0</span> &amp;&amp; v != <span class="number">0</span>)<span class="comment">//机器最开始从0开始,求重启次数,如果是0根本不需要重启.有一方是0就可以不重启.</span></span><br><span class="line">            &#123;</span><br><span class="line">                g[u][v] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">hungary</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="变化一—二分图的最小顶点覆盖"><a href="#变化一—二分图的最小顶点覆盖" class="headerlink" title="变化一—二分图的最小顶点覆盖"></a>变化一—二分图的最小顶点覆盖</h5><h6 id="基本含义-3"><a href="#基本含义-3" class="headerlink" title="基本含义"></a>基本含义</h6><p>在二分图中求最少的点,让每一条边都至少和其中的一个点关联.</p>
<p>一句话:最小顶点覆盖就是用最少的点覆盖所有的边.</p>
<p>顶点覆盖是什么?顶点覆盖是边.点怎么覆盖边.覆盖就是说这些边和这些点存在关联</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>二分图的最小顶点覆盖数&#x3D;&#x3D;二分图的最大匹配数</p>
<p>关键:求二分图的最大匹配数</p>
<h6 id="例题-10"><a href="#例题-10" class="headerlink" title="例题"></a>例题</h6><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA1194">UVA1194 Machine Schedule - 洛谷</a></p>
<p>思路</p>
<p>找出覆盖所有任务的一共有多少个模式.就是求最小顶点覆盖,最少几个点能覆盖所有的边.对于例题中的样例来说只需要机器A转到A1模式再转到A2模式,机器B再转到B3模式就可以用最少的点覆盖所有的边.</p>
<h5 id="变化二—DAG图-有向无环图-的最小路径覆盖"><a href="#变化二—DAG图-有向无环图-的最小路径覆盖" class="headerlink" title="变化二—DAG图(有向无环图)的最小路径覆盖"></a>变化二—DAG图(有向无环图)的最小路径覆盖</h5><h6 id="基本含义-4"><a href="#基本含义-4" class="headerlink" title="基本含义"></a>基本含义</h6><p>用尽量少的不相交的简单路径覆盖有向无环图(DAG)的所有顶点.</p>
<p>一句话:最小路径覆盖就是用最少的路覆盖所有的点.</p>
<h6 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h6><p>DAG图的最小路径覆盖数&#x3D;节点数(n)-最大匹配数(m)</p>
<h6 id="例题-11"><a href="#例题-11" class="headerlink" title="例题"></a>例题</h6><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1151">Problem - 1151</a></p>
<p>第一行告诉的信息(路径都是单行的,又不会形成回路)说明这个图是一个DAG图.</p>
<p>对于不是二分图的图这么转化?一个最简单的方法就是拆点.怎么拆?因为每个点都有可能是起点也有可能是终点,所以就把所有的点拆成两个点(比如1拆成1’,2拆成2’以此类推)如果有一条边比如1到3那就是1到3’也就是把左边的都是起点右边的都是终点.简单起见一开始是都没有路,比如现在有一条路3<del>4因为是3</del>4,最开始假设的四个路口时独立的,那至少需要4个伞兵,但是伞兵可以沿着路的方向走,匹配数可以减1,同样的道理如果还有一个1~3匹配数又可以减1,最终求的又是最大匹配,与最小路径覆盖有什么关系?一开始不相连,需要伞兵的数量就是N,每个点落一个,有一条路可以成功匹配,伞兵的数量就可以减1.</p>
<h5 id="变化三—二分图的最大独立集"><a href="#变化三—二分图的最大独立集" class="headerlink" title="变化三—二分图的最大独立集"></a>变化三—二分图的最大独立集</h5><h6 id="基本含义-5"><a href="#基本含义-5" class="headerlink" title="基本含义"></a>基本含义</h6><p>什么是独立集?一个集合如果TA的所有元素之间都没有边,这个集合就是独立的</p>
<h6 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h6><p>二分图的最大独立集数&#x3D;节点数(n)-最大匹配数(m)</p>
<p>关键:求二分图的最大匹配数</p>
<h6 id="例题-12"><a href="#例题-12" class="headerlink" title="例题"></a>例题</h6><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1068">Problem - 1068</a></p>
<h5 id="例题-13"><a href="#例题-13" class="headerlink" title="例题"></a>例题</h5><h6 id="例题1-4"><a href="#例题1-4" class="headerlink" title="例题1"></a>例题1</h6><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1522">Problem - 1522</a></p>
<p>简单来说,我们希望在满足条件的人当中,问最多可以匹配几对?</p>
<h2 id="记忆化DFS"><a href="#记忆化DFS" class="headerlink" title="记忆化DFS"></a>记忆化DFS</h2><p>在前面的DFS初探中我们学习了普通DFS的实现方法.</p>
<p>但有巨大缺点效率低空间爆,也容易TLE.</p>
<p>能不能保留优点克服缺点?</p>
<p>记忆化DFS实现方式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fib可以初始化原本计算中不存在的数.</span></span><br><span class="line">    <span class="comment">//全局变量定义fib数组保存斐波那契数列的值</span></span><br><span class="line">    <span class="keyword">if</span>(fib[n]) <span class="keyword">return</span> fib[n];<span class="comment">//如果数组里面已经有了已经算好了就不用再递归去求直接返回.</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>) fib[n]=<span class="number">1</span>;<span class="comment">//只要执行到这一行说明现在没有,可以直接确定结果</span></span><br><span class="line">    <span class="keyword">else</span> fib[n](<span class="built_in">dfs</span>(n<span class="number">-1</span>)+<span class="built_in">dfs</span>(n<span class="number">-2</span>))%<span class="number">1000000007</span>;<span class="comment">//如果直接return就没存啊.</span></span><br><span class="line">    <span class="keyword">return</span> fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟DP有什么区别?</p>
<p>DP是因为保证实现的方向,计算的方向从小往大的算,所以算到后面的小的一定有.记忆化DFS实现有可能从大往小的算.效率无限接近于普通的DP但由于刚开始算的时候还需要额外的栈空间,还是会慢一点.</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h3><h3 id="easy"><a href="#easy" class="headerlink" title="easy"></a>easy</h3><h4 id="kotori和素因子"><a href="#kotori和素因子" class="headerlink" title="kotori和素因子"></a>kotori和素因子</h4><p>(<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/71300/F">F-kotori和素因子（A组，B组）_2023年第六届传智杯程序设计挑战赛初赛</a>)</p>
<p>本题数据范围很小，因此直接dfs暴力搜索所有选择方案即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="type">int</span> prime[<span class="number">168</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>,<span class="number">283</span>,<span class="number">293</span>,<span class="number">307</span>,<span class="number">311</span>,<span class="number">313</span>,<span class="number">317</span>,<span class="number">331</span>,<span class="number">337</span>,<span class="number">347</span>,<span class="number">349</span>,<span class="number">353</span>,<span class="number">359</span>,<span class="number">367</span>,<span class="number">373</span>,<span class="number">379</span>,<span class="number">383</span>,<span class="number">389</span>,<span class="number">397</span>,<span class="number">401</span>,<span class="number">409</span>,<span class="number">419</span>,<span class="number">421</span>,<span class="number">431</span>,<span class="number">433</span>,<span class="number">439</span>,<span class="number">443</span>,<span class="number">449</span>,<span class="number">457</span>,<span class="number">461</span>,<span class="number">463</span>,<span class="number">467</span>,<span class="number">479</span>,<span class="number">487</span>,<span class="number">491</span>,<span class="number">499</span>,<span class="number">503</span>,<span class="number">509</span>,<span class="number">521</span>,<span class="number">523</span>,<span class="number">541</span>,<span class="number">547</span>,<span class="number">557</span>,<span class="number">563</span>,<span class="number">569</span>,<span class="number">571</span>,<span class="number">577</span>,<span class="number">587</span>,<span class="number">593</span>,<span class="number">599</span>,<span class="number">601</span>,<span class="number">607</span>,<span class="number">613</span>,<span class="number">617</span>,<span class="number">619</span>,<span class="number">631</span>,<span class="number">641</span>,<span class="number">643</span>,<span class="number">647</span>,<span class="number">653</span>,<span class="number">659</span>,<span class="number">661</span>,<span class="number">673</span>,<span class="number">677</span>,<span class="number">683</span>,<span class="number">691</span>,<span class="number">701</span>,<span class="number">709</span>,<span class="number">719</span>,<span class="number">727</span>,<span class="number">733</span>,<span class="number">739</span>,<span class="number">743</span>,<span class="number">751</span>,<span class="number">757</span>,<span class="number">761</span>,<span class="number">769</span>,<span class="number">773</span>,<span class="number">787</span>,<span class="number">797</span>,<span class="number">809</span>,<span class="number">811</span>,<span class="number">821</span>,<span class="number">823</span>,<span class="number">827</span>,<span class="number">829</span>,<span class="number">839</span>,<span class="number">853</span>,<span class="number">857</span>,<span class="number">859</span>,<span class="number">863</span>,<span class="number">877</span>,<span class="number">881</span>,<span class="number">883</span>,<span class="number">887</span>,<span class="number">907</span>,<span class="number">911</span>,<span class="number">919</span>,<span class="number">929</span>,<span class="number">937</span>,<span class="number">941</span>,<span class="number">947</span>,<span class="number">953</span>,<span class="number">967</span>,<span class="number">971</span>,<span class="number">977</span>,<span class="number">983</span>,<span class="number">991</span>,<span class="number">997</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">168</span>];        <span class="comment">//第几个素数被用过了</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][<span class="number">100</span>];        <span class="comment">//第i个数的质因子有第几个素数</span></span><br><span class="line"><span class="type">int</span> n,cnt[<span class="number">10</span>];        <span class="comment">//第i个数有几个质因子</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; ans)  ans = sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt[num]; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[f[num][i]])</span><br><span class="line">            &#123;</span><br><span class="line">                st[f[num][i]] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(num + <span class="number">1</span>, sum + prime[f[num][i]]);</span><br><span class="line">                st[f[num][i]] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; a != <span class="number">1</span>; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % prime[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][cnt[i]++] = j;        <span class="comment">//质因子有第几个素数</span></span><br><span class="line">                <span class="keyword">while</span>(a % prime[j] == <span class="number">0</span>)</span><br><span class="line">                    a /= prime[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f3f</span>)  ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h3><h3 id="difficult"><a href="#difficult" class="headerlink" title="difficult"></a>difficult</h3><h3 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h3><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h4 id="BFS（广度优先搜索）适用场景"><a href="#BFS（广度优先搜索）适用场景" class="headerlink" title="BFS（广度优先搜索）适用场景:"></a>BFS（广度优先搜索）适用场景:</h4><ol>
<li>无权图的最短路径:BFS逐层扩展,首次到达目标节点的路径即为最短路径(如迷宫最短路径,社交网络中的最少步数).就是求最少几步可以搞定或者找到某个节点,层次性更明显.</li>
<li>层次遍历或需要分层处理:如二叉树按层输出,图的层次分析.</li>
<li>空间允许且树&#x2F;图宽度不大:BFS需用队列存储每层节点,若树过宽(如完全二叉树),空间复杂度可能较高.</li>
<li>拓扑排序(Kahn算法):通过维护入度为0的队列,逐步输出拓扑序.</li>
<li>双向BFS优化:当起点和终点已知时,双向BFS可大幅减少搜索空间.</li>
</ol>
<h4 id="DFS（深度优先搜索）适用场景"><a href="#DFS（深度优先搜索）适用场景" class="headerlink" title="DFS（深度优先搜索）适用场景:"></a>DFS（深度优先搜索）适用场景:</h4><ol>
<li>回溯或枚举所有解:如排列组合,八皇后,数独等需尝试所有可能的问题,DFS可方便地回溯状态.</li>
<li>检测环路或连通性:DFS能通过递归栈追踪路径,适合判断图中环路或连通块数量.</li>
<li>树&#x2F;图深度较大但宽度较小:DFS的空间复杂度与深度相关(如链式结构为O(N)),适合纵深结构.</li>
<li>记录路径状态:如二叉树路径和问题,DFS递归时可携带路径信息,代码更简洁.</li>
<li>剪枝优化问题:结合启发式剪枝(如α-β剪枝),DFS常用于博弈树或状态空间搜索.</li>
</ol>
<p>其他考虑因素:</p>
<ul>
<li>时间复杂度:两者均为O(N+M)，但常数可能因实现方式不同。DFS递归有栈开销，BFS需维护队列。</li>
<li>空间复杂度:BFS空间与宽度相关(最坏O(N)),DFS与深度相关(最坏O(N)).对于极深结构,非递归DFS(显式栈)可避免栈溢出.</li>
<li>实现复杂度:DFS递归代码通常更简短,但需注意栈溢出;BFS需手动管理队列,适合层次相关操作.</li>
</ul>
<p>总结选择策略:</p>
<ul>
<li>最短路径&#x2F;最小步数 → BFS.</li>
<li>所有解&#x2F;回溯&#x2F;状态枚举 → DFS.</li>
<li>层次信息处理 → BFS.</li>
<li>深度大或需剪枝 → DFS.</li>
<li>根据数据规模权衡空间:宽结构慎用BFS,深结构慎用递归DFS.</li>
</ul>
<h1 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS(广度优先搜索)"></a>BFS(广度优先搜索)</h1><h2 id="入门基础-6"><a href="#入门基础-6" class="headerlink" title="入门基础"></a>入门基础</h2><h3 id="预备知识—队列"><a href="#预备知识—队列" class="headerlink" title="预备知识—队列"></a>预备知识—队列</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>1.先进先出(FIFO)</p>
<p>2.从队头删除元素</p>
<p>3.在队尾添加元素</p>
<h4 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h4><p>1.判断队列是否为空(队列不为空,从队列取一个元素)</p>
<p>2.查询队列大小</p>
<p>3.访问队首,队尾元素</p>
<p>4.加入,删除元素</p>
<h4 id="STL队列的基本用法"><a href="#STL队列的基本用法" class="headerlink" title="STL队列的基本用法"></a>STL队列的基本用法</h4><p>1.创建队列对象:queue&lt;元素类型&gt;队列名</p>
<p>2.队列添加元素:队列名.push(元素名)</p>
<p>3.去掉队首元素:队列名.pop( )</p>
<p>4.访问队首元素:队列名.front( )</p>
<p>5.访问队尾元素:队列名.back( )</p>
<p>6.判断是否为空:队列名.empty( ) &#x2F;&#x2F;注意:判断是否为空,如果是空的返回YES,不是则是NO</p>
<p>7.返回队列大小:队列名.size( )</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c,d;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">a=q.<span class="built_in">front</span>();</span><br><span class="line">b=q.<span class="built_in">back</span>();</span><br><span class="line">c=q.<span class="built_in">size</span>();</span><br><span class="line">d=q.<span class="built_in">empty</span>();<span class="comment">//真为1,假为0</span></span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//3 4 2 0</span></span><br></pre></td></tr></table></figure>



<h3 id="预备知识—二叉树的层次遍历"><a href="#预备知识—二叉树的层次遍历" class="headerlink" title="预备知识—二叉树的层次遍历"></a>预备知识—二叉树的层次遍历</h3><p>在前面学习了二叉树的3种遍历方式,现在来到最后一种.以之前DFS二叉树图为例.</p>
<p>所谓层次遍历就是从上到下,从左到右的顺序进行遍历.</p>
<p>所以顺序为2<del>&gt;7</del>&gt;8<del>&gt;1</del>&gt;6<del>&gt;9-&gt;5</del>&gt;3~&gt;4</p>
<h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>维护一个队列,用于存放节点的信息.当访问到一个节点的时候,先访问该节点,然后将该节点的左右儿子分别放入队列.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ccbl</span>(<span class="type">int</span> root)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;Q;<span class="comment">//创建一个队列</span></span><br><span class="line">    Q.<span class="built_in">push</span>(root);<span class="comment">//将根节点入队列</span></span><br><span class="line">    <span class="keyword">while</span>(队列不为空)</span><br><span class="line">    &#123;</span><br><span class="line">        获得队首元素</span><br><span class="line">        将队首元素出队</span><br><span class="line">        输出当前节点的值</span><br><span class="line">        如果该节点的左儿子不为空,将左儿子加入队列中</span><br><span class="line">        如果该节点的右儿子不为空,将右儿子加入队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="预备知识—关于网格地图的四方访问"><a href="#预备知识—关于网格地图的四方访问" class="headerlink" title="预备知识—关于网格地图的四方访问"></a>预备知识—关于网格地图的四方访问</h3><p>定义一个二维数组(全局变量):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//左,右,下,上.//如果是8个方向就是8行2列的二维数组.</span></span><br><span class="line"><span class="comment">//设当前的坐标(x,y),下步坐标为(xx,yy)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    xx=x+dir[i][<span class="number">0</span>];</span><br><span class="line">    yy=y+dir[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="BFS初探"><a href="#BFS初探" class="headerlink" title="BFS初探"></a>BFS初探</h3><h4 id="例题-14"><a href="#例题-14" class="headerlink" title="例题"></a>例题</h4><h5 id="例题1-5"><a href="#例题1-5" class="headerlink" title="例题1"></a>例题1</h5><p>eg1: <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1135">P1135 奇怪的电梯 - 洛谷</a></p>
<p>关键在于画出状态转移图.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9+7</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, Start, End;</span><br><span class="line"><span class="type">int</span> a[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">202</span>];<span class="comment">//标记</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pos</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> level;<span class="comment">//每个节点右level楼层</span></span><br><span class="line">	<span class="type">int</span> steps;<span class="comment">//走到当前楼层所需要的步数.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pos cur, nex;</span><br><span class="line">	cur.level = Start;<span class="comment">//搜索有当前状态,start当前状态就是起点,step就是0</span></span><br><span class="line">	cur.steps = <span class="number">0</span>;</span><br><span class="line">	queue&lt;pos&gt;qu;</span><br><span class="line">	qu.<span class="built_in">push</span>(cur);<span class="comment">//节点放到队列里</span></span><br><span class="line">	vis[Start] = <span class="number">1</span>;<span class="comment">//将访问过的节点做标记,目标是以后都不再访问了---做标记来实现剪枝</span></span><br><span class="line">	<span class="keyword">while</span> (!qu.<span class="built_in">empty</span>())<span class="comment">//板子</span></span><br><span class="line">	&#123;</span><br><span class="line">		cur = qu.<span class="built_in">front</span>();</span><br><span class="line">		qu.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (cur.level == End)<span class="comment">//判断取出的元素是不是我们要找的目标元素,如果End是直接输出</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cur.steps);</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//后面就不用执行了</span></span><br><span class="line">		&#125;</span><br><span class="line">		nex.level = cur.level + a[cur.level];<span class="comment">//nex.level来记录下一楼层是多少?</span></span><br><span class="line">		nex.steps = cur.steps + <span class="number">1</span>;<span class="comment">//下一步就在当前步数加一</span></span><br><span class="line">		<span class="keyword">if</span> (nex.level &lt;= N)<span class="comment">//判断是否超过最高楼层,如果没有超过最高楼层</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[nex.level] == <span class="number">0</span>)<span class="comment">//判断有没有来过,如果没有来过</span></span><br><span class="line">			&#123;</span><br><span class="line">				vis[nex.level] == <span class="number">1</span>;<span class="comment">//做标记</span></span><br><span class="line">				qu.<span class="built_in">push</span>(nex);<span class="comment">//进行扩展,放入队列里面</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//这里上面和下面是对称的,上面是向上走的,向下同理.</span></span><br><span class="line">		nex.level = cur.level - a[cur.level];</span><br><span class="line">		nex.steps = cur.steps + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (nex.level &gt;= <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[nex.level] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[nex.level] = <span class="number">1</span>;</span><br><span class="line">				qu.<span class="built_in">push</span>(nex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="comment">//程序流到这里说明上面的return语句没有执行,说明没有找到目标</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N) == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;Start, &amp;End);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">			vis[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题2-3"><a href="#例题2-3" class="headerlink" title="例题2"></a>例题2</h5><p>eg2 :  <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历 - 洛谷</a></p>
<p>审题,马走“日字形”所以在棋盘上体现的最多有8种不同的走法,这跟上一题不一样,方向数大大增加,可以用方向数组来写.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, x, y;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> startx, starty;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span> &gt;&gt;vis;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pos</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> steps;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pos cur, nex;</span><br><span class="line">	cur.x = startx;</span><br><span class="line">	cur.y = starty;</span><br><span class="line">	cur.steps = <span class="number">0</span>;</span><br><span class="line">	queue&lt;pos&gt;qu;</span><br><span class="line">	qu.<span class="built_in">push</span>(cur);</span><br><span class="line">	vis[startx][starty] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!qu.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cur = qu.<span class="built_in">front</span>();</span><br><span class="line">		qu.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (xx&lt;<span class="number">0</span> || yy&lt;<span class="number">0</span> || xx&gt;=n || yy&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (vis[xx][yy] == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[xx][yy] = cur.steps + <span class="number">1</span>;</span><br><span class="line">				nex.x = xx;</span><br><span class="line">				nex.y = yy;</span><br><span class="line">				nex.steps = cur.steps + <span class="number">1</span>;</span><br><span class="line">				qu.<span class="built_in">push</span>(nex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	startx = x - <span class="number">1</span>;</span><br><span class="line">	starty = y - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	vis.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">-1</span>));</span><br><span class="line">	vis[startx][starty] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;vis[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>从初始状态S开始,利用规则,生成所有可能的状态,构成树的下一个节点.</p>
<p>检查是否出现目标状态G,若未出现,就对该层所有状态节点,分别依次利用规则,生成再下一的所有状态的节点.</p>
<p>对新一层的所有状态节点继续检查是否出现G,若未出现,继续按上面思想生成在下一层的所有状态节点,这样一层一层往下展开,直至出现目标状态为止.</p>
<h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">bfs</span><span class="params">(node source,node target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line">    queue&lt;node&gt;Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(source);</span><br><span class="line">    visit[source]=<span class="number">1</span>;<span class="comment">//不一定是1根据需要而定</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node a=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(a==target) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">for</span>(对于a所有的后继节点b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">visir</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line">            visit[b]=<span class="number">1</span>;<span class="comment">//剪枝,保证节点只进队列一次,不一定是1根据需要而定</span></span><br><span class="line">            <span class="comment">//如果是迷宫类的BFS要更新坐标</span></span><br><span class="line">            <span class="comment">//if(vis[xx][yy]==?)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//	  vis[xx][yy] = cur.steps + 1;</span></span><br><span class="line">            <span class="comment">//    nex.x = xx;</span></span><br><span class="line">            <span class="comment">//    nex.y = yy;</span></span><br><span class="line">            <span class="comment">//    nex.steps = cur.steps + 1;</span></span><br><span class="line">            <span class="comment">//    qu.push(nex);</span></span><br><span class="line">        	<span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迷宫类注意坐标</span></span><br><span class="line"><span class="comment">//int startx,starty;要减1</span></span><br><span class="line"><span class="comment">//数组下标从0开始.</span></span><br></pre></td></tr></table></figure>



<h2 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="sign-1"><a href="#sign-1" class="headerlink" title="sign"></a>sign</h3><h3 id="easy-1"><a href="#easy-1" class="headerlink" title="easy"></a>easy</h3><h5 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/15552">逃离迷宫</a></h5><p>刚刚学习BFS做此题吃力,我觉得此题注重思维,不要一上来就就写两个BFS一个判断P到K最短,第二个判断K到E最短(亲历).那样子相当于把简单的问题复杂化.</p>
<p>思路:</p>
<p>反着想,我们原本想两段路径相加,但是我们用的是不共点,仔细一想就发现K这个共点,DFS两次分别算K到P,E的距离和,用数组或者map存起来.与一个我们设定好的大的min比较就行了.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 550</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9+7</span></span><br><span class="line"><span class="type">char</span> Map[N][N];<span class="comment">//地图</span></span><br><span class="line"><span class="type">int</span> vis[N][N];<span class="comment">//标记是否走过</span></span><br><span class="line"><span class="type">int</span> keys[N][N];<span class="comment">//标记是否有钥匙</span></span><br><span class="line"><span class="type">int</span> d[N][N];<span class="comment">//记录钥匙的距离</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pos</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> steps;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mem</span>(vis);</span><br><span class="line">	queue&lt;pos&gt;q;</span><br><span class="line">	pos cur,nex;</span><br><span class="line">	cur.x = x;</span><br><span class="line">	cur.y = y;</span><br><span class="line">	cur.steps = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(cur);</span><br><span class="line">	vis[x][y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cur = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> xx = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> yy = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (xx &gt; <span class="number">0</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &gt; <span class="number">0</span> &amp;&amp; yy &lt;= m &amp;&amp; Map[xx][yy] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; Map[xx][yy] != <span class="string">&#x27;E&#x27;</span> &amp;&amp; vis[xx][yy] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (Map[xx][yy] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					d[xx][yy] += cur.steps + <span class="number">1</span>;<span class="comment">//1是本身的要占一格</span></span><br><span class="line">					keys[xx][yy]++;</span><br><span class="line">				&#125;</span><br><span class="line">				nex.x = xx;</span><br><span class="line">				nex.y = yy;</span><br><span class="line">				nex.steps = cur.steps + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(nex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">mem</span>(Map);</span><br><span class="line">		<span class="built_in">mem</span>(keys);</span><br><span class="line">		<span class="built_in">mem</span>(d);</span><br><span class="line">		<span class="type">int</span> x1, y1, x2, y2, x3, y3;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; Map[i][j];</span><br><span class="line">				<span class="keyword">if</span> (Map[i][j] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					x1 = i, y1 = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (Map[i][j] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					x2 = i, y2 = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">bfs</span>(x1, y1);</span><br><span class="line">		<span class="built_in">bfs</span>(x2, y2);</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (keys[i][j] == <span class="number">2</span>)<span class="comment">//找到两个钥匙的位置，取最小值</span></span><br><span class="line">				&#123;</span><br><span class="line">					ans = <span class="built_in">min</span>(ans, d[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ans != <span class="number">1e9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;No solution&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="normal-1"><a href="#normal-1" class="headerlink" title="normal"></a>normal</h3><h3 id="difficult-1"><a href="#difficult-1" class="headerlink" title="difficult"></a>difficult</h3><h3 id="impossible-1"><a href="#impossible-1" class="headerlink" title="impossible"></a>impossible</h3><h1 id="常用STL"><a href="#常用STL" class="headerlink" title="常用STL"></a>常用STL</h1><p>前面在BFS中我们学习了C++STL库中的队列,其实无论在算法竞赛还是在工作中,STL的熟悉是必要的,下面将讲C++中常用的STL</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>谈到前面的队列,基本上都会出现栈.队列和栈都是很像的而且都属于线性表.都是输入输出受限的特殊的线性表.</p>
<h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><p>1.先进后出(FILO)</p>
<p>2.从<strong>栈顶</strong>删除元素</p>
<p>3.从<strong>栈顶</strong>加入元素</p>
<h3 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h3><p>1.判断栈<strong>是否为空</strong></p>
<p>2.查询栈的<strong>大小</strong></p>
<p>3.<strong>访问</strong>栈顶元素</p>
<p>4.栈顶<strong>加入</strong>元素</p>
<p>5.<strong>删除</strong>栈顶元素</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>创建栈对象:stack&lt;元素类型&gt;栈名;</p>
<p>栈顶添加元素:栈名.push(元素名);</p>
<p>删除栈顶元素:栈名.pop();</p>
<p>访问栈顶元素:栈名.top();&#x2F;&#x2F;要首先确保栈非空</p>
<p>判断是否为空:栈名.empty();</p>
<p>返回栈的大小:栈名.size();</p>
<p>注意:栈和队列一样,没有clear之类的函数,如果要想清空一个栈,需要<strong>循环调用出栈函数</strong>.</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">pop</span>();<span class="comment">//删除3</span></span><br><span class="line">s.<span class="built_in">top</span>()+=<span class="number">3</span>;<span class="comment">//2+3</span></span><br><span class="line">cout&lt;s.<span class="built_in">top</span>()&lt;&lt;endl;<span class="comment">//5</span></span><br><span class="line">cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;<span class="comment">//2</span></span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>())<span class="comment">//当s不空的时候是假的,循环继续</span></span><br><span class="line">&#123;</span><br><span class="line">	s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="例题-15"><a href="#例题-15" class="headerlink" title="例题"></a>例题</h3><h4 id="例题1-6"><a href="#例题1-6" class="headerlink" title="例题1"></a>例题1</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA673">UVA673 平衡的括号 Parentheses Balance - 洛谷</a></p>
<h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>经典栈的应用问题,可以用数组模拟栈,用stack更方便.</p>
<p>读到左括号一定是入栈的,读到右括号再去判断和栈顶是否匹配.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD  1e9 + 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; p;</span><br><span class="line">    p.<span class="built_in">push</span>(<span class="string">&#x27;#&#x27;</span>);<span class="comment">//设置&quot;哨兵&quot;防RE,</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];<span class="comment">//string访问方式</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)<span class="comment">//如果不设.这里要判断是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>)<span class="comment">//如果不设.这里要判断是否为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> p.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (p.<span class="built_in">size</span>() == <span class="number">1</span>);<span class="comment">//是否只剩&quot;哨兵&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;<span class="comment">//保存每一行的串</span></span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(s))<span class="comment">//是否合法?</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>主要解决比如C语言字符数组表示字符串的比较不方便的问题</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str1=<span class="string">&quot;qwertyui&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string strTest=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">strTest.<span class="built_in">length</span>();<span class="comment">//4</span></span><br><span class="line">strTest.<span class="built_in">size</span>();<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h4 id="对象连接"><a href="#对象连接" class="headerlink" title="对象连接"></a>对象连接</h4><p>可以使用+和+&#x3D;运算符对string对象执行字符串的连接操作.</p>
<h4 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h4><p>可以用&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;,&gt;&#x3D;,&gt;运算符比较string对象.</p>
<h4 id="求对象字串"><a href="#求对象字串" class="headerlink" title="求对象字串"></a>求对象字串</h4><p>substr 成员函数可以用于求字串(n,m);</p>
<p>调用时,如果省略m或m超过字符串的长度,则求出来的字串就是从下标n开始一直到字符串结束的部分.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1=<span class="string">&quot;this is ok&quot;</span>;</span><br><span class="line">string s2=s<span class="number">1.</span><span class="built_in">substr</span>(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">//s2=&quot;is i&quot;</span></span><br><span class="line">s2=s<span class="number">1.</span><span class="built_in">substr</span>(<span class="number">2</span>);<span class="comment">//s2=&quot;is is ok&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h4><p>insert成员函数可以在string对象中插入另一个字符串,返回值为对象自身的引用.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Limitless&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;00&quot;</span>)</span></span>;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//s1=&quot;Li123mitless&quot;,前面是起点,也就是下标2</span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">3</span>,s2);<span class="comment">//s1=&quot;Li10023mitless&quot;</span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>);<span class="comment">//s1=&quot;Li1XXXXX0023mitless&quot;//中间的5表示数量5个&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h4><p>erase成员函数可以删除string对象中的子串,返回值为对象自身的引用.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//s1=&quot;R Steel&quot;删除指定长度,从下标1开始删除3个单位长度</span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">5</span>);<span class="comment">//s1=&quot;R Ste&quot;从某个下标开始一直到尾</span></span><br></pre></td></tr></table></figure>

<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p>swap成员函数可以交换两个string 对象的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;West&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;East&quot;</span>)</span></span>;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">swap</span>(s2);</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;The apple thinks apple is delicious&quot;</span>;</span><br><span class="line">string key=<span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="type">int</span> pos1=str.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="type">int</span> pos2=str.<span class="built_in">find</span>(key,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.find(str) 查找字符串str在当前字符串s中第一次出现的位置</span></span><br><span class="line"><span class="comment">//s.find(str,pos) 查找字符串str在当前字符串s的[pos,end]中第一次出现的位置.</span></span><br></pre></td></tr></table></figure>

<h4 id="算法操作"><a href="#算法操作" class="headerlink" title="算法操作"></a>算法操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;afgcbed&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;<span class="comment">//abcdefg</span></span><br><span class="line"><span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());<span class="comment">//下一个 全排列</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;<span class="comment">//abcdegf</span></span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());<span class="comment">//翻转字符串</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="基本含义-6"><a href="#基本含义-6" class="headerlink" title="基本含义"></a>基本含义</h3><p><strong>向量,动态数组</strong></p>
<p><strong>初始化</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; abc;<span class="comment">//初始化一个size为0的vector,注意如果在全局变量定义且直接输入数据会RE,需要abc=resize(n);</span></span><br><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">abc</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//初始化了10个默认值为0的元素.</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cde</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;<span class="comment">//初始化了10个值为1的元素.</span></span><br></pre></td></tr></table></figure>

<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">取向量首元素的迭代器:向量名.<span class="built_in">begin</span>();</span><br><span class="line">取向量尾元素下一个地址:向量名.<span class="built_in">end</span>();<span class="comment">//左闭右开</span></span><br><span class="line">取向量首元素的值:向量名.<span class="built_in">front</span>();</span><br><span class="line">取向量尾元素的值:向量名.<span class="built_in">back</span>();</span><br><span class="line">下标形式访问:<span class="type">int</span> value0=向量名[<span class="number">0</span>];<span class="comment">//类似于普通数组的访问</span></span><br><span class="line">往尾部添加一个元素:向量名.<span class="built_in">push_back</span>(value);<span class="comment">//主要操作</span></span><br><span class="line">删除尾部第一个元素:向量名.<span class="built_in">pop_back</span>();</span><br><span class="line">判断向量是否为空:向量名.<span class="built_in">empty</span>();</span><br><span class="line">求向量元素个数:向量名.<span class="built_in">size</span>();<span class="comment">//实际元素的个数,不是容量</span></span><br><span class="line">翻转向量:<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h3 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和一维数组一样,这里的myVector中没有任何元素,myVector.size() == 0,直接访问会报错.</span></span><br><span class="line"><span class="comment">//可以先使用myVector.resize(n)来初始化这个二维数组的第一维,然后使用一个for循环再初始化第二维.此时myVector中的元素都是0,不是空格.</span></span><br><span class="line">	vector &lt; vector &lt; <span class="type">int</span> &gt; &gt; myVector;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	myVector.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		myVector[i].<span class="built_in">resize</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 输出的是一片空格 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; myVector[i].<span class="built_in">size</span>(); j++) </span><br><span class="line">        &#123;</span><br><span class="line">			cout &lt;&lt; myVector[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h2><p>含义就是集合,TA是一个有序的容器,里面的元素都是排序好的,支持插入,删除,查找等操作,所有的操作都是按照log(n)时间内完成.(二叉树实现)</p>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set的声明:		set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">set的清空:		s.<span class="built_in">clear</span>();</span><br><span class="line">插入一个元素x:	s.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="comment">//如果集合中之前没有,则成功插入并自动排序,否则不插入;</span></span><br><span class="line">查询是否有元素x:	<span class="type">int</span> hav=s.<span class="built_in">count</span>(x)<span class="comment">//返回0或1</span></span><br><span class="line">查找x并返回迭代器:	set&lt;<span class="type">int</span>&gt;::iterator it=s.<span class="built_in">find</span>(x);</span><br><span class="line">判断是否为空集:	<span class="type">bool</span> isempty =s.<span class="built_in">empty</span>();</span><br><span class="line">求集合元素的个数:	<span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">删除元素x:	s.<span class="built_in">erase</span>(x);</span><br></pre></td></tr></table></figure>

<h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><p>自动<strong>去重</strong>并按<strong>升序</strong>排序</p>
<p>set只能通过迭代器(iterator)访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it=st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*it);<span class="comment">//2 3 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想对set中的元素降序排序,任何处理?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果不是结构体类型.加一个greater&lt;<span class="type">int</span>&gt;就行了</span><br><span class="line">set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt;st;</span><br><span class="line">set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt;::iterator it;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>); </span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it=st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*it);<span class="comment">//5 3 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果set中的元素是结构体类型,如何处理排序问题?</p>
<p>方案:在结构体中重载小于运算符即可.</p>
<h2 id="map-映射"><a href="#map-映射" class="headerlink" title="map(映射)"></a>map(映射)</h2><p>map是一个键值对(key&#x2F;value)容器,对于迭代器来说,可以修改value,而不能修改key.<strong>Map会根据key自动排序</strong>.</p>
<p>map类型通常可以理解为关联数组:可使用<strong>键作为下标</strong>来获取一个值.关联的本质在于:元素的值与某个特定的键相关联,而并非通过元素在数组中的位置来获取.</p>
<p>特别说明:<strong>key不一定就是int类型</strong>!只要是–重载了”&lt;”操作符的类型均可.</p>
<h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt; m;<span class="comment">//定义一个空map m;</span></span><br><span class="line">m.<span class="built_in">count</span>(k);<span class="comment">//返回m中键值等于k的元素个数(1或0)</span></span><br><span class="line">m.<span class="built_in">find</span>(k);<span class="comment">//存在则返回指向该元素的迭代器,否则返回结束的地址end()</span></span><br><span class="line">m.<span class="built_in">erase</span>(k);<span class="comment">//删除m中键为k的元素,返回删除元素的个数(1或0)</span></span><br><span class="line">m.<span class="built_in">erase</span>(p);<span class="comment">//从m中删除迭代器p指向的元素</span></span><br><span class="line">m.<span class="built_in">insert</span>(e);<span class="comment">//e是一个用在m上的value_type类型的值(一个pair)</span></span><br><span class="line"><span class="comment">//如果键e.first不在m中,则插入一个值为e.second的新元素;如果该键在m中已经存在,那么不再进行如何操作.</span></span><br><span class="line">m.<span class="built_in">clear</span>();<span class="comment">//清空map m;</span></span><br><span class="line">m.<span class="built_in">empty</span>();<span class="comment">//判断map m 是否为空;</span></span><br></pre></td></tr></table></figure>

<h3 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> utd;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; mp;</span><br><span class="line">    mp[<span class="number">1</span>]=<span class="string">&quot;one&quot;</span>;</span><br><span class="line">    mp[<span class="number">2</span>]=<span class="string">&quot;two&quot;</span>;</span><br><span class="line">    mp[<span class="number">3</span>]=<span class="string">&quot;three&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="主要含义"><a href="#主要含义" class="headerlink" title="主要含义"></a>主要含义</h3><p>遍历容器中数据的对象.对存储于容器中的数据进行处理时,迭代器能按照<strong>预先定义的顺序</strong>从一个成员移向另一个成员.</p>
<p>也就是说,<strong>通过迭代器可以在不了解容器内部原理的情况下遍历容器</strong>.</p>
<p>总之,迭代器的作用就是提供一个<strong>遍历容器内部所有元素</strong>的接口,内部有一个与容器相关联的指针,然后<strong>重载各种运算操作</strong>来实现元素的遍历.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; aq;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    aq.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    aq.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    aq.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(it=aq.<span class="built_in">begin</span>();it!=aq.<span class="built_in">end</span>();it++)<span class="comment">//可以直接用auto</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ETalien</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/">http://example.com/2024/11/09/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">一位元宇宙爱好者的随笔</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-share"><div class="social-share" data-image="/image/yuanshen209.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2025/01/21/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51/" title="牛客寒假算法基础集训营1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/yuanshen53.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">牛客寒假算法基础集训营1</div></div></a><a class="next-post pull-right" href="/2024/10/15/%E5%85%89%E5%90%88%E8%BF%9C%E8%A7%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%AF%94%E8%B5%9B%E5%9B%9E%E9%A1%BE/" title="光合远见实验室比赛回顾"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/yuanshen186.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">光合远见实验室比赛回顾</div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/yuanshen103.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ETalien</div><div class="author-info-description">表世界的隐居者，里世界的幻想者，欢迎各位来到幻想乡！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://ETalien404.github.io"><i class="fab fa-github"></i><span>幻想乡!启动!</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到幻想乡!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%A8%80"><span class="toc-text">导言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ACM%E7%AB%9E%E8%B5%9B%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">ACM竞赛注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-text">输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB"><span class="toc-text">第一类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB"><span class="toc-text">第二类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%B1%BB"><span class="toc-text">第三类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%B1%BB"><span class="toc-text">第四类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB-1"><span class="toc-text">第一类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB-1"><span class="toc-text">第二类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%B1%BB-1"><span class="toc-text">第三类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA"><span class="toc-text">溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OJ%E5%88%A4%E9%A2%98%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">OJ判题的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90"><span class="toc-text">关键区别分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E9%A2%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">判题系统的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">输入文件结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">程序生命周期</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">两种输入方式的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-text">循环读取方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-text">单次读取方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACM%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%BB%93%E8%AE%BA"><span class="toc-text">ACM中的小结论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-text">欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%8A%82-%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86"><span class="toc-text">循环节(抽屉原理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%B9%98"><span class="toc-text">快速乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-text">统计问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">一维前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80"><span class="toc-text">入门基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E8%B4%AA%E5%BF%83"><span class="toc-text">初识贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%93%8D%E4%BD%9C"><span class="toc-text">前提操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E2%80%94sort"><span class="toc-text">排序—sort</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sort%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="toc-text">sort简单理解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sort%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">sort对结构体数组排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88"><span class="toc-text">经验之谈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-text">例题2</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-text">方法思路</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%983"><span class="toc-text">例题3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%984"><span class="toc-text">例题4</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">方法—逆序对</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%985"><span class="toc-text">例题5</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E2%80%94%E5%8F%AF%E5%9B%BE%E6%80%A7%E5%88%A4%E5%AE%9A%E2%80%93%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6"><span class="toc-text">方法—可图性判定–离散数学</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Havel-Hakimi%E7%AE%97%E6%B3%95"><span class="toc-text">Havel-Hakimi算法</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-DISJOINT-SET"><span class="toc-text">并查集(DISJOINT SET)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-1"><span class="toc-text">入门基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89"><span class="toc-text">基本含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1"><span class="toc-text">方式1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-text">效率分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2"><span class="toc-text">方式2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1"><span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-1"><span class="toc-text">效率分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3"><span class="toc-text">方式3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-%E7%90%86%E8%AE%BA"><span class="toc-text">基本思路(理论)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E2%80%94%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">优化—路径压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-2"><span class="toc-text">效率分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">经典应用—最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89%E2%80%93%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">基本含义–什么是生成树?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">如何求最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">Kruskal算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-1"><span class="toc-text">例题1</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E6%B1%82%E8%A7%A3"><span class="toc-text">递推求解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-2"><span class="toc-text">入门基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">递推常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-text">卡特兰数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-text">引入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3"><span class="toc-text">如何求解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E2%80%93%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-text">例题–高精度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E2%80%94%E8%A6%81%E7%94%A8%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">应用—要用高精度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">多边形三角形的数目</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">加括号的方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%B0%E8%B7%AF%E4%B8%8D%E5%90%8C%E8%B7%AF%E7%BA%BF%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">走路不同路线的数量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-2"><span class="toc-text">例题1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-1"><span class="toc-text">例题2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%983-1"><span class="toc-text">例题3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%984-1"><span class="toc-text">例题4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%985%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E8%BD%A6%E8%AF%86%E8%B7%AF%E7%AE%97%E6%B3%95"><span class="toc-text">例题5—嵌入式小车识路算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-text">基本方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP"><span class="toc-text">动态规划(DP)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-3"><span class="toc-text">入门基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E6%83%B3%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">思想和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-text">思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-text">主要特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DP%E5%88%9D%E6%8E%A2"><span class="toc-text">DP初探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E2%80%94%E6%95%B0%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-text">经典问题—数塔问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E2%80%94%E6%9C%80%E9%95%BF%E6%9C%89%E5%BA%8F%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">经典问题—最长有序子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E2%80%94%E5%BA%8F%E5%88%97"><span class="toc-text">前置知识—序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E2%80%93%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F"><span class="toc-text">经典问题–最少拦截系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E2%80%94Dilworth%E5%AE%9A%E7%90%86"><span class="toc-text">前置知识—Dilworth定理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8"><span class="toc-text">问题本质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-3"><span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-2"><span class="toc-text">例题2</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85DP"><span class="toc-text">背包DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-text">基本模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-text">01背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3"><span class="toc-text">问题分解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-text">伪代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-%E4%BA%8C%E7%BB%B4dp"><span class="toc-text">代码(二维dp)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-%E4%B8%80%E7%BB%B4dp"><span class="toc-text">代码(一维dp)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-text">完全背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83"><span class="toc-text">深度思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-text">多重背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96"><span class="toc-text">二进制优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%83%A8%E5%88%86%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="toc-text">优化部分参考代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85"><span class="toc-text">二维费用背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-1"><span class="toc-text">算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7"><span class="toc-text">例题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">高精度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">1.大整数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%87%8F"><span class="toc-text">2.大整数相减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95"><span class="toc-text">3.大整数乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-text">4.大整数相除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%98%B6%E4%B9%98"><span class="toc-text">5.高精度阶乘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%8D%9A%E5%BC%88-Simple-Game-Theory"><span class="toc-text">组合博弈(Simple Game Theory)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-4"><span class="toc-text">入门基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8F%96%E5%AD%90%E6%B8%B8%E6%88%8F-%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E7%9A%84%E4%B8%80%E7%A7%8D"><span class="toc-text">简单取子游戏(组合游戏的一种)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%90%AB%E4%B9%89-%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">简单含义(组合游戏的定义)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E8%B4%A5%E7%82%B9%E5%92%8C%E5%BF%85%E8%83%9C%E7%82%B9-P%E7%82%B9-N%E7%82%B9"><span class="toc-text">必败点和必胜点(P点&amp;N点)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-2"><span class="toc-text">算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIM%E6%B8%B8%E6%88%8F"><span class="toc-text">NIM游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E2%80%94Nim-Sum"><span class="toc-text">引入—Nim-Sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%861"><span class="toc-text">定理1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-text">思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-8"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%8D%9A%E5%BC%88%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE%E4%BB%A5%E5%8F%8AS%E7%BA%A7%E5%87%BD%E6%95%B0"><span class="toc-text">组合博弈的状态转移图以及S级函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89-1"><span class="toc-text">基本含义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SG%E5%87%BD%E6%95%B0"><span class="toc-text">SG函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E7%9A%84%E5%B9%B6"><span class="toc-text">组合游戏的并</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E7%90%862"><span class="toc-text">定理2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-9"><span class="toc-text">例题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">DFS(深度优先搜索)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-5"><span class="toc-text">入门基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">预备知识—二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%A0%B9%E5%B7%A6%E5%8F%B3"><span class="toc-text">先序遍历(根左右)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%B7%A6%E6%A0%B9%E5%8F%B3"><span class="toc-text">中序遍历(左根右)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%B7%A6%E5%8F%B3%E6%A0%B9"><span class="toc-text">后序遍历(左右根)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="toc-text">题外话</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS%E5%88%9D%E6%8E%A2"><span class="toc-text">DFS初探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B-1"><span class="toc-text">基本模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%B8%80%E4%B8%AA%E5%9B%BE%E4%B8%8A%E6%9C%80%E5%A4%A7%E8%81%94%E9%80%9A%E5%AD%90%E5%9D%97-%E6%9D%BF%E5%AD%90%E9%A2%98-%E2%80%93%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">求一个图上最大联通子块(板子题)–示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D"><span class="toc-text">剪枝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%89%AA%E6%9E%9D"><span class="toc-text">基本剪枝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%80%A7%E5%89%AA%E6%9E%9D"><span class="toc-text">奇偶性剪枝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D"><span class="toc-text">二分匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-Bipartite-Graph"><span class="toc-text">二分图及其应用(Bipartite Graph)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89-2"><span class="toc-text">基本含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E2%80%94%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-text">二分图的最大匹配—匈牙利算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%BA%90%E7%A0%81-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92"><span class="toc-text">参考源码(任务安排)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E5%8C%96%E4%B8%80%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96"><span class="toc-text">变化一—二分图的最小顶点覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89-3"><span class="toc-text">基本含义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-10"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E5%8C%96%E4%BA%8C%E2%80%94DAG%E5%9B%BE-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE-%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96"><span class="toc-text">变化二—DAG图(有向无环图)的最小路径覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89-4"><span class="toc-text">基本含义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-11"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E5%8C%96%E4%B8%89%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86"><span class="toc-text">变化三—二分图的最大独立集</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89-5"><span class="toc-text">基本含义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-12"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-13"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-4"><span class="toc-text">例题1</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96DFS"><span class="toc-text">记忆化DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-text">相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sign"><span class="toc-text">sign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#easy"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kotori%E5%92%8C%E7%B4%A0%E5%9B%A0%E5%AD%90"><span class="toc-text">kotori和素因子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#normal"><span class="toc-text">normal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#difficult"><span class="toc-text">difficult</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#impossible"><span class="toc-text">impossible</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">BFS（广度优先搜索）适用场景:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">DFS（深度优先搜索）适用场景:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">BFS(广度优先搜索)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-6"><span class="toc-text">入门基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E2%80%94%E9%98%9F%E5%88%97"><span class="toc-text">预备知识—队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-text">常见操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">STL队列的基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="toc-text">简单例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">预备知识—二叉树的层次遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">算法思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E2%80%94%E5%85%B3%E4%BA%8E%E7%BD%91%E6%A0%BC%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%9B%9B%E6%96%B9%E8%AE%BF%E9%97%AE"><span class="toc-text">预备知识—关于网格地图的四方访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS%E5%88%9D%E6%8E%A2"><span class="toc-text">BFS初探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-14"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-5"><span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-3"><span class="toc-text">例题2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-1"><span class="toc-text">伪代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-1"><span class="toc-text">相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sign-1"><span class="toc-text">sign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#easy-1"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%83%E7%A6%BB%E8%BF%B7%E5%AE%AB"><span class="toc-text">逃离迷宫</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#normal-1"><span class="toc-text">normal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#difficult-1"><span class="toc-text">difficult</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#impossible-1"><span class="toc-text">impossible</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8STL"><span class="toc-text">常用STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C-1"><span class="toc-text">常见操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">简单示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-15"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-6"><span class="toc-text">例题1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-text">思路</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB"><span class="toc-text">string类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E"><span class="toc-text">对象声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6"><span class="toc-text">长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%9E%E6%8E%A5"><span class="toc-text">对象连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83"><span class="toc-text">对象比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%AF%B9%E8%B1%A1%E5%AD%97%E4%B8%B2"><span class="toc-text">求对象字串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">插入字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%90%E4%B8%B2"><span class="toc-text">删除子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-text">交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%93%8D%E4%BD%9C"><span class="toc-text">算法操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89-6"><span class="toc-text">基本含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">二维数组初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-%E9%9B%86%E5%90%88"><span class="toc-text">set(集合)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-2"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-%E6%98%A0%E5%B0%84"><span class="toc-text">map(映射)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-3"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%90%AB%E4%B9%89"><span class="toc-text">主要含义</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By ETalien</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tsumiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>